\echo Use "CREATE EXTENSION dashboard" to load this file. \quit
CREATE SCHEMA dashboard_public;

GRANT USAGE ON SCHEMA dashboard_public TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_public 
 GRANT ALL ON TABLES  TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_public 
 GRANT ALL ON SEQUENCES  TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_public 
 GRANT ALL ON FUNCTIONS  TO administrator;

GRANT USAGE ON SCHEMA dashboard_public TO authenticated;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_public 
 GRANT ALL ON FUNCTIONS  TO authenticated;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_public 
 GRANT USAGE, SELECT ON SEQUENCES  TO authenticated;

GRANT USAGE ON SCHEMA dashboard_public TO anonymous;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_public 
 GRANT ALL ON FUNCTIONS  TO anonymous;

CREATE SCHEMA dashboard_private;

GRANT USAGE ON SCHEMA dashboard_private TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_private 
 GRANT ALL ON TABLES  TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_private 
 GRANT ALL ON SEQUENCES  TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_private 
 GRANT ALL ON FUNCTIONS  TO administrator;

GRANT USAGE ON SCHEMA dashboard_private TO authenticated;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_private 
 GRANT ALL ON FUNCTIONS  TO authenticated;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_private 
 GRANT USAGE, SELECT ON SEQUENCES  TO authenticated;

GRANT USAGE ON SCHEMA dashboard_private TO anonymous;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_private 
 GRANT ALL ON FUNCTIONS  TO anonymous;

CREATE FUNCTION dashboard_private.uuid_generate_v4 (  ) RETURNS uuid AS $EOFCODE$
    SELECT uuids.pseudo_order_seed_uuid('dashboard');
$EOFCODE$ LANGUAGE sql;

GRANT EXECUTE ON FUNCTION dashboard_private.uuid_generate_v4 TO PUBLIC;

CREATE TABLE dashboard_public.users (
  
);

ALTER TABLE dashboard_public.users DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.users ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.users ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.users ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.users ADD CONSTRAINT users_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.users ADD COLUMN  username citext;

ALTER TABLE dashboard_public.users ADD CONSTRAINT users_username_chk CHECK ( character_length(username) <= 256 );

ALTER TABLE dashboard_public.users ADD CONSTRAINT users_username_key UNIQUE ( username );

ALTER TABLE dashboard_public.users ADD COLUMN  display_name text;

ALTER TABLE dashboard_public.users ADD CONSTRAINT users_display_name_chk CHECK ( character_length(display_name) <= 256 );

ALTER TABLE dashboard_public.users ADD COLUMN  profile_picture image;

ALTER TABLE dashboard_public.users ADD COLUMN  search_tsv tsvector;

CREATE FUNCTION dashboard_private.users_search_tsv_tsv (  ) RETURNS trigger AS $EOFCODE$ 
 
BEGIN
NEW.search_tsv = (setweight(to_tsvector('pg_catalog.simple', COALESCE(NEW.display_name, '')), 'B') || setweight(to_tsvector('pg_catalog.simple', COALESCE(NEW.username, '')), 'A'));
RETURN NEW;
END; 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER users_search_tsv_tsv_insert_tg 
 BEFORE INSERT ON dashboard_public.users 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. users_search_tsv_tsv (  );

CREATE TRIGGER users_search_tsv_tsv_update_tg 
 BEFORE UPDATE ON dashboard_public.users 
 FOR EACH ROW
 WHEN ( old.username IS DISTINCT FROM new.username OR old.display_name IS DISTINCT FROM new.display_name ) 
 EXECUTE PROCEDURE dashboard_private. users_search_tsv_tsv (  );

CREATE INDEX users_search_tsv_idx ON dashboard_public.users USING GIN ( search_tsv );

CREATE TABLE dashboard_public.role_types (
  
);

ALTER TABLE dashboard_public.role_types DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.role_types ADD COLUMN  id int;

ALTER TABLE dashboard_public.role_types ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.role_types ADD CONSTRAINT role_types_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.role_types ADD COLUMN  name citext;

ALTER TABLE dashboard_public.role_types ALTER COLUMN name SET NOT NULL;

ALTER TABLE dashboard_public.role_types ADD CONSTRAINT role_types_name_key UNIQUE ( name );

ALTER TABLE dashboard_public.users ADD COLUMN  type int;

ALTER TABLE dashboard_public.users ALTER COLUMN type SET NOT NULL;

ALTER TABLE dashboard_public.users ALTER COLUMN type SET DEFAULT 0;

ALTER TABLE dashboard_public.users ADD CONSTRAINT users_type_fkey FOREIGN KEY ( type ) REFERENCES dashboard_public.role_types ( id ) ON DELETE CASCADE;

INSERT INTO dashboard_public.role_types ( id, name ) VALUES (0, 'User'), (1, 'Organization');

ALTER TABLE dashboard_public.users ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.users ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.users ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.users ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.users 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.users ( created_at );

CREATE INDEX ON dashboard_public.users ( updated_at );

ALTER TABLE dashboard_public.users ENABLE ROW LEVEL SECURITY;

GRANT SELECT ON TABLE dashboard_public.users TO authenticated;

GRANT DELETE ON TABLE dashboard_public.users TO authenticated;

GRANT UPDATE ( display_name, profile_picture ) ON TABLE dashboard_public.users TO authenticated;

GRANT INSERT ( type, display_name, profile_picture ) ON TABLE dashboard_public.users TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.users FOR SELECT TO authenticated USING ( TRUE );

CREATE SCHEMA dashboard_memberships_public;

GRANT USAGE ON SCHEMA dashboard_memberships_public TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_memberships_public 
 GRANT ALL ON TABLES  TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_memberships_public 
 GRANT ALL ON SEQUENCES  TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_memberships_public 
 GRANT ALL ON FUNCTIONS  TO administrator;

GRANT USAGE ON SCHEMA dashboard_memberships_public TO authenticated;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_memberships_public 
 GRANT ALL ON FUNCTIONS  TO authenticated;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_memberships_public 
 GRANT USAGE, SELECT ON SEQUENCES  TO authenticated;

GRANT USAGE ON SCHEMA dashboard_memberships_public TO anonymous;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_memberships_public 
 GRANT ALL ON FUNCTIONS  TO anonymous;

CREATE TABLE dashboard_memberships_public.membership_types (
  
);

ALTER TABLE dashboard_memberships_public.membership_types DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_memberships_public.membership_types ADD COLUMN  id int;

ALTER TABLE dashboard_memberships_public.membership_types ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_memberships_public.membership_types ADD CONSTRAINT membership_types_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_memberships_public.membership_types ADD COLUMN  name citext;

ALTER TABLE dashboard_memberships_public.membership_types ALTER COLUMN name SET NOT NULL;

ALTER TABLE dashboard_memberships_public.membership_types ADD COLUMN  description text;

ALTER TABLE dashboard_memberships_public.membership_types ALTER COLUMN description SET NOT NULL;

ALTER TABLE dashboard_memberships_public.membership_types ADD COLUMN  prefix text;

ALTER TABLE dashboard_memberships_public.membership_types ALTER COLUMN prefix SET NOT NULL;

ALTER TABLE dashboard_memberships_public.membership_types ADD CONSTRAINT membership_types_name_key UNIQUE ( name );

INSERT INTO dashboard_memberships_public.membership_types ( id, name, description, prefix ) VALUES (1, 'App Member', 'Memberships to the app.', 'app'), (2, 'Organization Member', 'Membership to an organization.', 'membership'), (3, 'Group Member', 'User''s membership to a group.', 'group');

ALTER TABLE dashboard_memberships_public.membership_types ENABLE ROW LEVEL SECURITY;

GRANT SELECT ON TABLE dashboard_memberships_public.membership_types TO authenticated;

CREATE POLICY auth_sel ON dashboard_memberships_public.membership_types FOR SELECT TO authenticated USING ( TRUE );

CREATE SCHEMA dashboard_permissions_public;

GRANT USAGE ON SCHEMA dashboard_permissions_public TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_permissions_public 
 GRANT ALL ON TABLES  TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_permissions_public 
 GRANT ALL ON SEQUENCES  TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_permissions_public 
 GRANT ALL ON FUNCTIONS  TO administrator;

GRANT USAGE ON SCHEMA dashboard_permissions_public TO authenticated;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_permissions_public 
 GRANT ALL ON FUNCTIONS  TO authenticated;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_permissions_public 
 GRANT USAGE, SELECT ON SEQUENCES  TO authenticated;

GRANT USAGE ON SCHEMA dashboard_permissions_public TO anonymous;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_permissions_public 
 GRANT ALL ON FUNCTIONS  TO anonymous;

CREATE SCHEMA dashboard_permissions_private;

GRANT USAGE ON SCHEMA dashboard_permissions_private TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_permissions_private 
 GRANT ALL ON TABLES  TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_permissions_private 
 GRANT ALL ON SEQUENCES  TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_permissions_private 
 GRANT ALL ON FUNCTIONS  TO administrator;

GRANT USAGE ON SCHEMA dashboard_permissions_private TO authenticated;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_permissions_private 
 GRANT ALL ON FUNCTIONS  TO authenticated;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_permissions_private 
 GRANT USAGE, SELECT ON SEQUENCES  TO authenticated;

GRANT USAGE ON SCHEMA dashboard_permissions_private TO anonymous;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_permissions_private 
 GRANT ALL ON FUNCTIONS  TO anonymous;

CREATE TABLE dashboard_permissions_public.app_permissions (
  
);

ALTER TABLE dashboard_permissions_public.app_permissions DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_permissions_public.app_permissions ADD COLUMN  id uuid;

ALTER TABLE dashboard_permissions_public.app_permissions ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_permissions_public.app_permissions ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_permissions_public.app_permissions ADD CONSTRAINT app_permissions_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_permissions_public.app_permissions ADD COLUMN  name citext;

ALTER TABLE dashboard_permissions_public.app_permissions ADD CONSTRAINT app_permissions_name_key UNIQUE ( name );

ALTER TABLE dashboard_permissions_public.app_permissions ADD COLUMN  bitnum int;

ALTER TABLE dashboard_permissions_public.app_permissions ADD CONSTRAINT app_permissions_bitnum_chk CHECK ( bitnum >= 1 AND bitnum <= 32 );

ALTER TABLE dashboard_permissions_public.app_permissions ADD CONSTRAINT app_permissions_bitnum_key UNIQUE ( bitnum );

ALTER TABLE dashboard_permissions_public.app_permissions ADD COLUMN  bitstr bit(32);

ALTER TABLE dashboard_permissions_public.app_permissions ALTER COLUMN bitstr SET NOT NULL;

ALTER TABLE dashboard_permissions_public.app_permissions ALTER COLUMN bitstr SET DEFAULT lpad('', 32, '0')::bit(32);

ALTER TABLE dashboard_permissions_public.app_permissions ADD COLUMN  description text;

CREATE OR REPLACE FUNCTION dashboard_permissions_public.app_permissions_get_padded_mask ( mask pg_catalog.varbit ) RETURNS pg_catalog.varbit AS $EOFCODE$
    SELECT utils.bitmask_pad(mask, 32, '0');
$EOFCODE$ LANGUAGE sql IMMUTABLE;

GRANT EXECUTE ON FUNCTION dashboard_permissions_public.app_permissions_get_padded_mask TO authenticated;

CREATE FUNCTION dashboard_permissions_public.app_permissions_get_by_mask ( mask pg_catalog.varbit ) RETURNS SETOF dashboard_permissions_public.app_permissions AS $EOFCODE$
    SELECT * FROM 
      "dashboard_permissions_public".app_permissions
    WHERE bitstr & "dashboard_permissions_public".app_permissions_get_padded_mask(mask) = bitstr;
$EOFCODE$ LANGUAGE sql STABLE;

GRANT EXECUTE ON FUNCTION dashboard_permissions_public.app_permissions_get_by_mask TO authenticated;

CREATE FUNCTION dashboard_permissions_public.app_permissions_get_mask ( ids uuid[] ) RETURNS pg_catalog.varbit AS $EOFCODE$
    SELECT bit_or(bitstr) FROM 
      "dashboard_permissions_public".app_permissions
    WHERE id = ANY (ids);
$EOFCODE$ LANGUAGE sql STABLE;

GRANT EXECUTE ON FUNCTION dashboard_permissions_public.app_permissions_get_mask TO authenticated;

CREATE FUNCTION dashboard_permissions_public.app_permissions_get_mask_by_names ( names citext[] ) RETURNS pg_catalog.varbit AS $EOFCODE$
    SELECT bit_or(bitstr) FROM 
      "dashboard_permissions_public".app_permissions
    WHERE name = ANY (names);
$EOFCODE$ LANGUAGE sql STABLE;

GRANT EXECUTE ON FUNCTION dashboard_permissions_public.app_permissions_get_mask_by_names TO authenticated;

CREATE FUNCTION dashboard_permissions_private.app_permissions_bitnum_tg (  ) RETURNS trigger AS $EOFCODE$
DECLARE
    bitlen int = bit_length(NEW.bitstr);
BEGIN
    NEW.bitstr = 
        lpad('', bitlen - NEW.bitnum, '0') ||
	    '1' ||
	    lpad('', NEW.bitnum - 1, '0');
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER app_permissions_insert_trg 
 BEFORE INSERT ON dashboard_permissions_public.app_permissions 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_permissions_private. app_permissions_bitnum_tg (  );

CREATE TABLE dashboard_permissions_public.app_permission_defaults (
  
);

ALTER TABLE dashboard_permissions_public.app_permission_defaults DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_permissions_public.app_permission_defaults ADD COLUMN  id uuid;

ALTER TABLE dashboard_permissions_public.app_permission_defaults ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_permissions_public.app_permission_defaults ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_permissions_public.app_permission_defaults ADD CONSTRAINT app_permission_defaults_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_permissions_public.app_permission_defaults ADD COLUMN  permissions bit(32);

ALTER TABLE dashboard_permissions_public.app_permission_defaults ALTER COLUMN permissions SET NOT NULL;

ALTER TABLE dashboard_permissions_public.app_permission_defaults ALTER COLUMN permissions SET DEFAULT lpad('', 32, '0')::bit(32);

CREATE TRIGGER app_permission_defaults_insert_trg 
 BEFORE INSERT ON dashboard_permissions_public.app_permission_defaults 
 FOR EACH ROW
 EXECUTE PROCEDURE utils. ensure_singleton (  );

CREATE SCHEMA dashboard_limits_public;

GRANT USAGE ON SCHEMA dashboard_limits_public TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_limits_public 
 GRANT ALL ON TABLES  TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_limits_public 
 GRANT ALL ON SEQUENCES  TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_limits_public 
 GRANT ALL ON FUNCTIONS  TO administrator;

GRANT USAGE ON SCHEMA dashboard_limits_public TO authenticated;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_limits_public 
 GRANT ALL ON FUNCTIONS  TO authenticated;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_limits_public 
 GRANT USAGE, SELECT ON SEQUENCES  TO authenticated;

GRANT USAGE ON SCHEMA dashboard_limits_public TO anonymous;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_limits_public 
 GRANT ALL ON FUNCTIONS  TO anonymous;

CREATE SCHEMA dashboard_limits_private;

GRANT USAGE ON SCHEMA dashboard_limits_private TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_limits_private 
 GRANT ALL ON TABLES  TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_limits_private 
 GRANT ALL ON SEQUENCES  TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_limits_private 
 GRANT ALL ON FUNCTIONS  TO administrator;

GRANT USAGE ON SCHEMA dashboard_limits_private TO authenticated;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_limits_private 
 GRANT ALL ON FUNCTIONS  TO authenticated;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_limits_private 
 GRANT USAGE, SELECT ON SEQUENCES  TO authenticated;

GRANT USAGE ON SCHEMA dashboard_limits_private TO anonymous;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_limits_private 
 GRANT ALL ON FUNCTIONS  TO anonymous;

CREATE TABLE dashboard_limits_public.app_limits (
  
);

ALTER TABLE dashboard_limits_public.app_limits DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_limits_public.app_limits ADD COLUMN  id uuid;

ALTER TABLE dashboard_limits_public.app_limits ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_limits_public.app_limits ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_limits_public.app_limits ADD CONSTRAINT app_limits_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_limits_public.app_limits ADD COLUMN  name citext;

ALTER TABLE dashboard_limits_public.app_limits ADD COLUMN  actor_id uuid;

ALTER TABLE dashboard_limits_public.app_limits ALTER COLUMN actor_id SET NOT NULL;

ALTER TABLE dashboard_limits_public.app_limits ADD CONSTRAINT app_limits_actor_id_fkey FOREIGN KEY ( actor_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

ALTER TABLE dashboard_limits_public.app_limits ADD COLUMN  num int;

ALTER TABLE dashboard_limits_public.app_limits ADD COLUMN  max int;

ALTER TABLE dashboard_limits_public.app_limits ADD CONSTRAINT app_limits_name_actor_id_key UNIQUE ( name, actor_id );

CREATE TABLE dashboard_limits_public.app_limit_defaults (
  
);

ALTER TABLE dashboard_limits_public.app_limit_defaults DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_limits_public.app_limit_defaults ADD COLUMN  id uuid;

ALTER TABLE dashboard_limits_public.app_limit_defaults ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_limits_public.app_limit_defaults ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_limits_public.app_limit_defaults ADD CONSTRAINT app_limit_defaults_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_limits_public.app_limit_defaults ADD COLUMN  name citext;

ALTER TABLE dashboard_limits_public.app_limit_defaults ALTER COLUMN name SET NOT NULL;

ALTER TABLE dashboard_limits_public.app_limit_defaults ADD COLUMN  max int;

ALTER TABLE dashboard_limits_public.app_limit_defaults ADD CONSTRAINT app_limit_defaults_name_key UNIQUE ( name );

CREATE FUNCTION dashboard_limits_private.app_limits_inc ( limitname citext, actor_id uuid DEFAULT jwt_public.current_user_id(), amount int DEFAULT 1 ) RETURNS boolean AS $EOFCODE$
DECLARE
    limit_exists boolean;
    max_default int = 0;
    rec "dashboard_limits_public".app_limits;
BEGIN
    SELECT EXISTS (SELECT 1 FROM "dashboard_limits_public".app_limits l
        WHERE l.name = limitname
        AND l.actor_id = app_limits_inc.actor_id
    ) INTO limit_exists;
    IF (limit_exists IS FALSE) THEN 
        SELECT max FROM "dashboard_limits_public".app_limit_defaults
            WHERE name = limitname
        INTO max_default;
        IF (NOT FOUND) THEN 
            max_default = 0;
        END IF;
        INSERT INTO "dashboard_limits_public".app_limits (name, num, max, actor_id)
        VALUES (limitname, 0, max_default, actor_id);
    END IF;
    SELECT * FROM "dashboard_limits_public".app_limits l
        WHERE l.name = limitname
        AND l.actor_id = app_limits_inc.actor_id
    INTO rec;
    IF (rec.max < 0 OR rec.max >= rec.num + amount) THEN 
        UPDATE "dashboard_limits_public".app_limits l 
        SET num = num + amount
        WHERE l.name = limitname
        AND l.actor_id = app_limits_inc.actor_id;
        RETURN TRUE;
    ELSE
        RETURN FALSE;
    END IF;
    RETURN FALSE;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

CREATE FUNCTION dashboard_limits_private.app_limits_dec ( limitname citext, actor_id uuid DEFAULT jwt_public.current_user_id(), amount int DEFAULT 1 ) RETURNS boolean AS $EOFCODE$
DECLARE
    limit_exists boolean;
    max_default int = 0;
    rec "dashboard_limits_public".app_limits;
BEGIN
    SELECT EXISTS (SELECT 1 FROM "dashboard_limits_public".app_limits l
        WHERE l.name = limitname
        AND l.actor_id = app_limits_dec.actor_id
    ) INTO limit_exists;
    IF (limit_exists IS FALSE) THEN 
        SELECT max FROM "dashboard_limits_public".app_limit_defaults
            WHERE name = limitname
        INTO max_default;
        IF (NOT FOUND) THEN 
            max_default = 0;
        END IF;
        INSERT INTO "dashboard_limits_public".app_limits (name, num, max, actor_id)
        VALUES (limitname, 0, max_default, actor_id);
    END IF;
    UPDATE "dashboard_limits_public".app_limits l
    SET num = greatest(num - amount, 0)
    WHERE l.name = limitname
    AND l.actor_id = app_limits_dec.actor_id;
    RETURN TRUE;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

CREATE FUNCTION dashboard_limits_private.app_limits_inc_tg (  ) RETURNS trigger AS $EOFCODE$
DECLARE
    limit_ok boolean;
    actor_id uuid;
    limitname citext;
BEGIN
    IF (TG_NARGS < 1) THEN 
        RAISE EXCEPTION 'LIMIT_TRIGGER_ARGS (%)', TG_NAME;
    ELSIF (TG_NARGS = 1) THEN 
        limitname = TG_ARGV[0];        
        limit_ok = "dashboard_limits_private".app_limits_inc(
            limitname
        );
    ELSIF (TG_NARGS = 2) THEN 
        limitname = TG_ARGV[0];        
        EXECUTE format('SELECT ($1).%s', TG_ARGV[1])
        USING NEW INTO actor_id;
        limit_ok = "dashboard_limits_private".app_limits_inc(
            limitname, actor_id
        );
    END IF;
    IF (limit_ok IS FALSE) THEN 
        RAISE EXCEPTION 'LIMIT_REACHED';
    END IF;
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE FUNCTION dashboard_limits_private.app_limits_dec_tg (  ) RETURNS trigger AS $EOFCODE$
DECLARE
    actor_id uuid;
    limitname citext;
BEGIN
    IF (TG_NARGS < 1) THEN 
        RAISE EXCEPTION 'LIMIT_TRIGGER_ARGS (%)', TG_NAME;
    ELSIF (TG_NARGS = 1) THEN 
        limitname = TG_ARGV[0];        
        PERFORM "dashboard_limits_private".app_limits_dec(
            limitname
        );
    ELSIF (TG_NARGS = 2) THEN 
        limitname = TG_ARGV[0];        
        EXECUTE format('SELECT ($1).%s', TG_ARGV[1])
        USING OLD INTO actor_id;
        PERFORM "dashboard_limits_private".app_limits_dec(
            limitname, actor_id
        );
    END IF;
    RETURN OLD;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE FUNCTION dashboard_limits_private.app_limits_upd_tg (  ) RETURNS trigger AS $EOFCODE$
DECLARE
    limit_ok boolean;
    old_actor_id uuid;
    new_actor_id uuid;
    limitname citext;
BEGIN
    IF (TG_NARGS < 1) THEN 
        RAISE EXCEPTION 'LIMIT_TRIGGER_ARGS (%)', TG_NAME;
    ELSIF (TG_NARGS = 1) THEN 
        RAISE EXCEPTION 'LIMIT_TRIGGER_ARGS (%)', TG_NAME;
    ELSIF (TG_NARGS = 2) THEN 
        limitname = TG_ARGV[0];        
        EXECUTE format('SELECT ($1).%s', TG_ARGV[1])
        USING NEW INTO new_actor_id;
        EXECUTE format('SELECT ($1).%s', TG_ARGV[1])
        USING OLD INTO old_actor_id;
        PERFORM "dashboard_limits_private".app_limits_dec(
            limitname, old_actor_id
        );
        limit_ok = "dashboard_limits_private".app_limits_inc(
            limitname, new_actor_id
        );
        
    END IF;
    IF (limit_ok IS FALSE) THEN 
        RAISE EXCEPTION 'LIMIT_REACHED';
    END IF;
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE FUNCTION dashboard_limits_private.app_limits_check ( limitname citext, amount int DEFAULT 1, user_id uuid DEFAULT jwt_public.current_user_id() ) RETURNS boolean AS $EOFCODE$
DECLARE
    limit_exists boolean;
    max_default int = 0;
    rec "dashboard_limits_public".app_limits;
BEGIN
    SELECT EXISTS (SELECT 1 FROM "dashboard_limits_public".app_limits 
        WHERE name = limitname
        AND actor_id = user_id
    ) INTO limit_exists;
    IF (limit_exists IS FALSE) THEN 
        SELECT max FROM "dashboard_limits_public".app_limit_defaults
            WHERE name = limitname
        INTO max_default;
        IF (NOT FOUND) THEN 
            max_default = 0;
        END IF;
        INSERT INTO "dashboard_limits_public".app_limits (name, num, max, actor_id)
        VALUES (limitname, 0, max_default, user_id);
    END IF;
    SELECT * FROM "dashboard_limits_public".app_limits
        WHERE name = limitname
        AND actor_id = user_id
    INTO rec;
    IF (rec.max >= rec.num + amount) THEN 
        RETURN TRUE;
    ELSE
        RETURN FALSE;
    END IF;
    RETURN FALSE;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE SCHEMA dashboard_memberships_private;

GRANT USAGE ON SCHEMA dashboard_memberships_private TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_memberships_private 
 GRANT ALL ON TABLES  TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_memberships_private 
 GRANT ALL ON SEQUENCES  TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_memberships_private 
 GRANT ALL ON FUNCTIONS  TO administrator;

GRANT USAGE ON SCHEMA dashboard_memberships_private TO authenticated;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_memberships_private 
 GRANT ALL ON FUNCTIONS  TO authenticated;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_memberships_private 
 GRANT USAGE, SELECT ON SEQUENCES  TO authenticated;

GRANT USAGE ON SCHEMA dashboard_memberships_private TO anonymous;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_memberships_private 
 GRANT ALL ON FUNCTIONS  TO anonymous;

CREATE TABLE dashboard_memberships_public.app_memberships (
  
);

ALTER TABLE dashboard_memberships_public.app_memberships DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_memberships_public.app_memberships ADD COLUMN  id uuid;

ALTER TABLE dashboard_memberships_public.app_memberships ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_memberships_public.app_memberships ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_memberships_public.app_memberships ADD CONSTRAINT app_memberships_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_memberships_public.app_memberships ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_memberships_public.app_memberships ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_memberships_public.app_memberships ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_memberships_public.app_memberships ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_memberships_public.app_memberships 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_memberships_public.app_memberships ( created_at );

CREATE INDEX ON dashboard_memberships_public.app_memberships ( updated_at );

ALTER TABLE dashboard_memberships_public.app_memberships ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_memberships_public.app_memberships ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_memberships_public.app_memberships 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_memberships_public.app_memberships ( created_by );

CREATE INDEX ON dashboard_memberships_public.app_memberships ( updated_by );

CREATE TABLE dashboard_memberships_public.app_membership_defaults (
  
);

ALTER TABLE dashboard_memberships_public.app_membership_defaults DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_memberships_public.app_membership_defaults ADD COLUMN  id uuid;

ALTER TABLE dashboard_memberships_public.app_membership_defaults ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_memberships_public.app_membership_defaults ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_memberships_public.app_membership_defaults ADD CONSTRAINT app_membership_defaults_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_memberships_public.app_membership_defaults ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_memberships_public.app_membership_defaults ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_memberships_public.app_membership_defaults ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_memberships_public.app_membership_defaults ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_memberships_public.app_membership_defaults 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_memberships_public.app_membership_defaults ( created_at );

CREATE INDEX ON dashboard_memberships_public.app_membership_defaults ( updated_at );

ALTER TABLE dashboard_memberships_public.app_membership_defaults ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_memberships_public.app_membership_defaults ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_memberships_public.app_membership_defaults 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_memberships_public.app_membership_defaults ( created_by );

CREATE INDEX ON dashboard_memberships_public.app_membership_defaults ( updated_by );

CREATE TABLE dashboard_memberships_private.app_memberships_acl (
  
);

ALTER TABLE dashboard_memberships_private.app_memberships_acl DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_memberships_private.app_memberships_acl ADD COLUMN  is_owner boolean;

ALTER TABLE dashboard_memberships_private.app_memberships_acl ALTER COLUMN is_owner SET NOT NULL;

ALTER TABLE dashboard_memberships_private.app_memberships_acl ALTER COLUMN is_owner SET DEFAULT FALSE;

ALTER TABLE dashboard_memberships_private.app_memberships_acl ADD COLUMN  is_admin boolean;

ALTER TABLE dashboard_memberships_private.app_memberships_acl ALTER COLUMN is_admin SET NOT NULL;

ALTER TABLE dashboard_memberships_private.app_memberships_acl ALTER COLUMN is_admin SET DEFAULT FALSE;

ALTER TABLE dashboard_memberships_private.app_memberships_acl ADD COLUMN  permissions bit(32);

ALTER TABLE dashboard_memberships_private.app_memberships_acl ALTER COLUMN permissions SET NOT NULL;

ALTER TABLE dashboard_memberships_private.app_memberships_acl ALTER COLUMN permissions SET DEFAULT lpad('', 32, '0')::bit(32);

CREATE INDEX app_memberships_acls_is_admin_idx ON dashboard_memberships_private.app_memberships_acl ( is_admin );

CREATE INDEX app_memberships_acls_is_owner_idx ON dashboard_memberships_private.app_memberships_acl ( is_owner );

ALTER TABLE dashboard_memberships_private.app_memberships_acl ADD COLUMN  actor_id uuid;

ALTER TABLE dashboard_memberships_private.app_memberships_acl ALTER COLUMN actor_id SET NOT NULL;

CREATE UNIQUE INDEX app_memberships_acls_actor_id_idx ON dashboard_memberships_private.app_memberships_acl ( actor_id ) INCLUDE ( permissions, is_owner, is_admin );

GRANT SELECT ON TABLE dashboard_memberships_private.app_memberships_acl TO PUBLIC;

ALTER TABLE dashboard_memberships_public.app_membership_defaults ADD COLUMN  is_approved boolean;

ALTER TABLE dashboard_memberships_public.app_membership_defaults ALTER COLUMN is_approved SET NOT NULL;

ALTER TABLE dashboard_memberships_public.app_membership_defaults ALTER COLUMN is_approved SET DEFAULT TRUE;

ALTER TABLE dashboard_memberships_public.app_membership_defaults ADD COLUMN  is_verified boolean;

ALTER TABLE dashboard_memberships_public.app_membership_defaults ALTER COLUMN is_verified SET NOT NULL;

ALTER TABLE dashboard_memberships_public.app_membership_defaults ALTER COLUMN is_verified SET DEFAULT FALSE;

INSERT INTO dashboard_memberships_public.app_membership_defaults ( is_verified, is_approved ) VALUES (TRUE, TRUE);

ALTER TABLE dashboard_memberships_public.app_memberships ADD COLUMN  is_approved boolean;

ALTER TABLE dashboard_memberships_public.app_memberships ALTER COLUMN is_approved SET NOT NULL;

ALTER TABLE dashboard_memberships_public.app_memberships ALTER COLUMN is_approved SET DEFAULT FALSE;

ALTER TABLE dashboard_memberships_public.app_memberships ADD COLUMN  is_banned boolean;

ALTER TABLE dashboard_memberships_public.app_memberships ALTER COLUMN is_banned SET NOT NULL;

ALTER TABLE dashboard_memberships_public.app_memberships ALTER COLUMN is_banned SET DEFAULT FALSE;

ALTER TABLE dashboard_memberships_public.app_memberships ADD COLUMN  is_disabled boolean;

ALTER TABLE dashboard_memberships_public.app_memberships ALTER COLUMN is_disabled SET NOT NULL;

ALTER TABLE dashboard_memberships_public.app_memberships ALTER COLUMN is_disabled SET DEFAULT FALSE;

ALTER TABLE dashboard_memberships_public.app_memberships ADD COLUMN  is_verified boolean;

ALTER TABLE dashboard_memberships_public.app_memberships ALTER COLUMN is_verified SET NOT NULL;

ALTER TABLE dashboard_memberships_public.app_memberships ALTER COLUMN is_verified SET DEFAULT FALSE;

ALTER TABLE dashboard_memberships_public.app_memberships ADD COLUMN  is_active boolean;

ALTER TABLE dashboard_memberships_public.app_memberships ALTER COLUMN is_active SET NOT NULL;

ALTER TABLE dashboard_memberships_public.app_memberships ALTER COLUMN is_active SET DEFAULT FALSE;

ALTER TABLE dashboard_memberships_public.app_memberships ADD COLUMN  is_owner boolean;

ALTER TABLE dashboard_memberships_public.app_memberships ALTER COLUMN is_owner SET NOT NULL;

ALTER TABLE dashboard_memberships_public.app_memberships ALTER COLUMN is_owner SET DEFAULT FALSE;

ALTER TABLE dashboard_memberships_public.app_memberships ADD COLUMN  is_admin boolean;

ALTER TABLE dashboard_memberships_public.app_memberships ALTER COLUMN is_admin SET NOT NULL;

ALTER TABLE dashboard_memberships_public.app_memberships ALTER COLUMN is_admin SET DEFAULT FALSE;

ALTER TABLE dashboard_memberships_public.app_memberships ADD COLUMN  permissions bit(32);

ALTER TABLE dashboard_memberships_public.app_memberships ALTER COLUMN permissions SET NOT NULL;

ALTER TABLE dashboard_memberships_public.app_memberships ALTER COLUMN permissions SET DEFAULT lpad('', 32, '0')::bit(32);

ALTER TABLE dashboard_memberships_public.app_memberships ADD COLUMN  granted bit(32);

ALTER TABLE dashboard_memberships_public.app_memberships ALTER COLUMN granted SET NOT NULL;

ALTER TABLE dashboard_memberships_public.app_memberships ALTER COLUMN granted SET DEFAULT lpad('', 32, '0')::bit(32);

ALTER TABLE dashboard_memberships_public.app_memberships ADD COLUMN  actor_id uuid;

ALTER TABLE dashboard_memberships_public.app_memberships ALTER COLUMN actor_id SET NOT NULL;

CREATE INDEX app_memberships_is_admin_idx ON dashboard_memberships_public.app_memberships ( is_admin );

CREATE INDEX app_memberships_is_owner_idx ON dashboard_memberships_public.app_memberships ( is_owner );

ALTER TABLE dashboard_memberships_public.app_memberships ADD CONSTRAINT app_memberships_actor_id_fkey FOREIGN KEY ( actor_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

ALTER TABLE dashboard_memberships_public.app_memberships ADD CONSTRAINT app_memberships_actor_id_key UNIQUE ( actor_id );

CREATE FUNCTION dashboard_memberships_private.app_memberships_insert_acl_tg (  ) RETURNS trigger AS $EOFCODE$
DECLARE
BEGIN
    IF (NEW.is_owner IS TRUE) THEN 
      NEW.is_admin = TRUE;
      NEW.is_verified = TRUE;
      NEW.is_approved = TRUE;
      NEW.is_disabled = FALSE;
      NEW.is_banned = FALSE;
    END IF;
    SELECT (
        NEW.is_verified IS TRUE
    AND
        NEW.is_approved IS TRUE
    AND
        NEW.is_disabled IS FALSE
    AND
        NEW.is_banned IS FALSE 
    ) INTO NEW.is_active;
    IF (NEW.is_active IS TRUE) THEN 
        INSERT INTO "dashboard_memberships_private".app_memberships_acl 
            (is_owner, is_admin, permissions, actor_id)
        VALUES 
            (NEW.is_owner, NEW.is_admin, NEW.permissions, NEW.actor_id)
        ;
    END IF;
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

CREATE FUNCTION dashboard_memberships_private.app_memberships_update_acl_tg (  ) RETURNS trigger AS $EOFCODE$
DECLARE
    v_num_updated int;
BEGIN
    IF (NEW.is_owner IS TRUE) THEN 
      NEW.is_admin = TRUE;
      NEW.is_approved = TRUE;
      NEW.is_verified = TRUE;
      NEW.is_disabled = FALSE;
      NEW.is_banned = FALSE;
    END IF;
    SELECT (
        NEW.is_approved IS TRUE
    AND
        NEW.is_verified IS TRUE
    AND
        NEW.is_disabled IS FALSE
    AND
        NEW.is_banned IS FALSE 
    ) INTO NEW.is_active;
    IF ( NEW.is_active IS FALSE ) THEN 
        DELETE FROM "dashboard_memberships_private".app_memberships_acl 
            WHERE actor_id = NEW.actor_id;
    ELSE 
        INSERT INTO "dashboard_memberships_private".app_memberships_acl 
            (is_owner, is_admin, permissions, actor_id)
        VALUES 
            (NEW.is_owner, NEW.is_admin, NEW.permissions, NEW.actor_id)
        ON CONFLICT (actor_id)
        DO UPDATE
          SET
            is_owner = EXCLUDED.is_owner,
            is_admin = EXCLUDED.is_admin,
            permissions = EXCLUDED.permissions
        ;
    END IF;
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

CREATE FUNCTION dashboard_memberships_private.app_memberships_delete_acl_tg (  ) RETURNS trigger AS $EOFCODE$
DECLARE
    v_num_updated int;
BEGIN
    DELETE FROM "dashboard_memberships_private".app_memberships_acl 
        WHERE actor_id = OLD.actor_id;
    RETURN OLD;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

CREATE FUNCTION dashboard_memberships_private.app_memberships_perm_check ( perm text, actor_id uuid DEFAULT jwt_public.current_user_id() ) RETURNS boolean AS $EOFCODE$
SELECT EXISTS (
      SELECT 1 FROM "dashboard_memberships_public".app_memberships m,
		      "dashboard_permissions_public".app_permissions p
          WHERE
          	p.name = perm
          AND m.permissions & p.bitstr = p.bitstr
          AND m.actor_id = app_memberships_perm_check.actor_id
);
$EOFCODE$ LANGUAGE sql STABLE SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION dashboard_memberships_private.app_memberships_perm_check TO authenticated;

CREATE FUNCTION dashboard_memberships_private.app_memberships_mask_check ( mask pg_catalog.varbit, actor_id uuid DEFAULT jwt_public.current_user_id() ) RETURNS boolean AS $EOFCODE$
    SELECT EXISTS (
        SELECT 1 FROM "dashboard_memberships_public".app_memberships m
            WHERE m.permissions & mask = mask
            AND m.actor_id = app_memberships_mask_check.actor_id
    );
$EOFCODE$ LANGUAGE sql STABLE SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION dashboard_memberships_private.app_memberships_mask_check TO authenticated;

CREATE TABLE dashboard_memberships_public.app_admin_grants (
  
);

ALTER TABLE dashboard_memberships_public.app_admin_grants DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_memberships_public.app_admin_grants ADD COLUMN  id uuid;

ALTER TABLE dashboard_memberships_public.app_admin_grants ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_memberships_public.app_admin_grants ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_memberships_public.app_admin_grants ADD CONSTRAINT app_admin_grants_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_memberships_public.app_admin_grants ADD COLUMN  is_grant boolean;

ALTER TABLE dashboard_memberships_public.app_admin_grants ALTER COLUMN is_grant SET NOT NULL;

ALTER TABLE dashboard_memberships_public.app_admin_grants ALTER COLUMN is_grant SET DEFAULT TRUE;

ALTER TABLE dashboard_memberships_public.app_admin_grants ADD COLUMN  actor_id uuid;

ALTER TABLE dashboard_memberships_public.app_admin_grants ALTER COLUMN actor_id SET NOT NULL;

ALTER TABLE dashboard_memberships_public.app_admin_grants ADD CONSTRAINT app_admin_grants_actor_id_fkey FOREIGN KEY ( actor_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

ALTER TABLE dashboard_memberships_public.app_admin_grants ADD COLUMN  grantor_id uuid;

ALTER TABLE dashboard_memberships_public.app_admin_grants ALTER COLUMN grantor_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_memberships_public.app_admin_grants ADD CONSTRAINT app_admin_grants_grantor_id_fkey FOREIGN KEY ( grantor_id ) REFERENCES dashboard_public.users ( id ) ON DELETE SET NULL;

CREATE INDEX app_admin_grants_grantor_id_idx ON dashboard_memberships_public.app_admin_grants ( grantor_id );

ALTER TABLE dashboard_memberships_public.app_admin_grants ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_memberships_public.app_admin_grants ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_memberships_public.app_admin_grants ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_memberships_public.app_admin_grants ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_memberships_public.app_admin_grants 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_memberships_public.app_admin_grants ( created_at );

CREATE INDEX ON dashboard_memberships_public.app_admin_grants ( updated_at );

CREATE TABLE dashboard_memberships_public.app_owner_grants (
  
);

ALTER TABLE dashboard_memberships_public.app_owner_grants DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_memberships_public.app_owner_grants ADD COLUMN  id uuid;

ALTER TABLE dashboard_memberships_public.app_owner_grants ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_memberships_public.app_owner_grants ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_memberships_public.app_owner_grants ADD CONSTRAINT app_owner_grants_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_memberships_public.app_owner_grants ADD COLUMN  is_grant boolean;

ALTER TABLE dashboard_memberships_public.app_owner_grants ALTER COLUMN is_grant SET NOT NULL;

ALTER TABLE dashboard_memberships_public.app_owner_grants ALTER COLUMN is_grant SET DEFAULT TRUE;

ALTER TABLE dashboard_memberships_public.app_owner_grants ADD COLUMN  actor_id uuid;

ALTER TABLE dashboard_memberships_public.app_owner_grants ALTER COLUMN actor_id SET NOT NULL;

ALTER TABLE dashboard_memberships_public.app_owner_grants ADD CONSTRAINT app_owner_grants_actor_id_fkey FOREIGN KEY ( actor_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

ALTER TABLE dashboard_memberships_public.app_owner_grants ADD COLUMN  grantor_id uuid;

ALTER TABLE dashboard_memberships_public.app_owner_grants ALTER COLUMN grantor_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_memberships_public.app_owner_grants ADD CONSTRAINT app_owner_grants_grantor_id_fkey FOREIGN KEY ( grantor_id ) REFERENCES dashboard_public.users ( id ) ON DELETE SET NULL;

CREATE INDEX app_owner_grants_grantor_id_idx ON dashboard_memberships_public.app_owner_grants ( grantor_id );

ALTER TABLE dashboard_memberships_public.app_owner_grants ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_memberships_public.app_owner_grants ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_memberships_public.app_owner_grants ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_memberships_public.app_owner_grants ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_memberships_public.app_owner_grants 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_memberships_public.app_owner_grants ( created_at );

CREATE INDEX ON dashboard_memberships_public.app_owner_grants ( updated_at );

CREATE TABLE dashboard_memberships_public.app_grants (
  
);

ALTER TABLE dashboard_memberships_public.app_grants DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_memberships_public.app_grants ADD COLUMN  id uuid;

ALTER TABLE dashboard_memberships_public.app_grants ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_memberships_public.app_grants ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_memberships_public.app_grants ADD CONSTRAINT app_grants_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_memberships_public.app_grants ADD COLUMN  permissions bit(32);

ALTER TABLE dashboard_memberships_public.app_grants ALTER COLUMN permissions SET NOT NULL;

ALTER TABLE dashboard_memberships_public.app_grants ALTER COLUMN permissions SET DEFAULT lpad('', 32, '0')::bit(32);

ALTER TABLE dashboard_memberships_public.app_grants ADD COLUMN  is_grant boolean;

ALTER TABLE dashboard_memberships_public.app_grants ALTER COLUMN is_grant SET NOT NULL;

ALTER TABLE dashboard_memberships_public.app_grants ALTER COLUMN is_grant SET DEFAULT TRUE;

ALTER TABLE dashboard_memberships_public.app_grants ADD COLUMN  actor_id uuid;

ALTER TABLE dashboard_memberships_public.app_grants ALTER COLUMN actor_id SET NOT NULL;

ALTER TABLE dashboard_memberships_public.app_grants ADD CONSTRAINT app_grants_actor_id_fkey FOREIGN KEY ( actor_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

ALTER TABLE dashboard_memberships_public.app_grants ADD COLUMN  grantor_id uuid;

ALTER TABLE dashboard_memberships_public.app_grants ALTER COLUMN grantor_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_memberships_public.app_grants ADD CONSTRAINT app_grants_grantor_id_fkey FOREIGN KEY ( grantor_id ) REFERENCES dashboard_public.users ( id ) ON DELETE SET NULL;

CREATE INDEX app_grants_grantor_id_idx ON dashboard_memberships_public.app_grants ( grantor_id );

ALTER TABLE dashboard_memberships_public.app_grants ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_memberships_public.app_grants ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_memberships_public.app_grants ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_memberships_public.app_grants ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_memberships_public.app_grants 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_memberships_public.app_grants ( created_at );

CREATE INDEX ON dashboard_memberships_public.app_grants ( updated_at );

CREATE FUNCTION dashboard_memberships_private.app_memberships_itg (  ) RETURNS trigger AS $EOFCODE$
DECLARE
    bitlen int = bit_length(NEW.permissions);
    defaults bit varying;
    memdefs "dashboard_memberships_public".app_membership_defaults;
BEGIN
    SELECT * FROM
        "dashboard_memberships_public".app_membership_defaults t 
    LIMIT 1 
    INTO memdefs;
    IF (FOUND) THEN 
        NEW.is_approved = memdefs.is_approved;
        NEW.is_verified = memdefs.is_verified;
    END IF;
    IF (NEW.is_owner IS TRUE) THEN 
        NEW.is_admin = TRUE;
        NEW.is_approved = TRUE;
        NEW.is_verified = TRUE;
        NEW.is_disabled = FALSE;
        NEW.is_banned = FALSE;
    END IF;
    SELECT (
        NEW.is_approved IS TRUE
    AND
        NEW.is_verified IS TRUE
    AND
        NEW.is_disabled IS FALSE
    AND
        NEW.is_banned IS FALSE 
    ) INTO NEW.is_active;
    SELECT permissions FROM
        "dashboard_permissions_public".app_permission_defaults t 
    LIMIT 1 
    INTO defaults;
    IF (NOT FOUND) THEN 
        NEW.granted = lpad('', bitlen::int, '0');
    ELSE
        NEW.granted = defaults;
    END IF;
    IF (NEW.is_admin IS TRUE OR NEW.is_owner IS TRUE) THEN 
        NEW.permissions = lpad('', bitlen::int, '1');
    ELSE
        NEW.permissions = NEW.granted;
    END IF;
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

CREATE FUNCTION dashboard_memberships_private.app_memberships_utg (  ) RETURNS trigger AS $EOFCODE$
DECLARE
    bitlen int = bit_length(NEW.permissions);
BEGIN
    IF (NEW.is_owner IS TRUE) THEN 
        NEW.is_admin = TRUE;
        NEW.is_approved = TRUE;
        NEW.is_verified = TRUE;
        NEW.is_disabled = FALSE;
        NEW.is_banned = FALSE;
    END IF;
    SELECT (
        NEW.is_approved IS TRUE
    AND
        NEW.is_verified IS TRUE
    AND
        NEW.is_disabled IS FALSE
    AND
        NEW.is_banned IS FALSE 
    ) INTO NEW.is_active;
    IF (NEW.is_admin IS TRUE OR NEW.is_owner IS TRUE) THEN 
        NEW.permissions = lpad('', bitlen::int, '1');
    ELSE
        NEW.permissions = NEW.granted;
    END IF;
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

CREATE TRIGGER _00010_app_memberships_itrg 
 BEFORE INSERT ON dashboard_memberships_public.app_memberships 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_memberships_private. app_memberships_itg (  );

CREATE TRIGGER _00010_app_memberships_utrg 
 BEFORE UPDATE ON dashboard_memberships_public.app_memberships 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_memberships_private. app_memberships_utg (  );

CREATE TRIGGER _00020_app_memberships_insert_acl 
 AFTER INSERT ON dashboard_memberships_public.app_memberships 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_memberships_private. app_memberships_insert_acl_tg (  );

CREATE TRIGGER _00020_app_memberships_update_acl 
 AFTER UPDATE ON dashboard_memberships_public.app_memberships 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_memberships_private. app_memberships_update_acl_tg (  );

CREATE TRIGGER _99999_app_memberships_delete_acl 
 AFTER DELETE ON dashboard_memberships_public.app_memberships 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_memberships_private. app_memberships_delete_acl_tg (  );

CREATE FUNCTION dashboard_memberships_private.app_mbr_create (  ) RETURNS trigger AS $EOFCODE$
DECLARE
BEGIN
    INSERT INTO
    "dashboard_memberships_public".app_memberships
      (actor_id)
    VALUES
      (NEW.id);
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

CREATE TRIGGER app_mbr_trg 
 AFTER INSERT ON dashboard_public.users 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_memberships_private. app_mbr_create (  );

CREATE FUNCTION dashboard_memberships_private.app_grants_apply_tg (  ) RETURNS trigger AS $EOFCODE$
BEGIN
    IF (NEW.is_grant IS TRUE) THEN 
        UPDATE "dashboard_memberships_public".app_memberships 
            SET granted = granted | NEW.permissions
        WHERE actor_id = NEW.actor_id; 
    ELSE 
        UPDATE "dashboard_memberships_public".app_memberships 
            SET granted = granted & ~ NEW.permissions
        WHERE actor_id = NEW.actor_id; 
    END IF;
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER app_grants_insert_trg 
 BEFORE INSERT ON dashboard_memberships_public.app_grants 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_memberships_private. app_grants_apply_tg (  );

CREATE FUNCTION dashboard_memberships_private.app_admin_grants_apply_tg (  ) RETURNS trigger AS $EOFCODE$
BEGIN
    IF (NEW.is_grant IS TRUE) THEN 
        UPDATE "dashboard_memberships_public".app_memberships 
            SET is_admin = TRUE
        WHERE actor_id = NEW.actor_id; 
    ELSE 
        UPDATE "dashboard_memberships_public".app_memberships 
            SET is_admin = FALSE
        WHERE actor_id = NEW.actor_id
        AND is_owner = FALSE; -- cannot set owners 
    END IF;
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

CREATE TRIGGER app_admin_grants_insert_trg 
 BEFORE INSERT ON dashboard_memberships_public.app_admin_grants 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_memberships_private. app_admin_grants_apply_tg (  );

CREATE FUNCTION dashboard_memberships_private.app_owner_grants_apply_tg (  ) RETURNS trigger AS $EOFCODE$
BEGIN
    IF (NEW.is_grant IS TRUE) THEN 
        UPDATE "dashboard_memberships_public".app_memberships 
            SET is_owner = TRUE
        WHERE actor_id = NEW.actor_id; 
    ELSE 
        UPDATE "dashboard_memberships_public".app_memberships 
            SET is_owner = FALSE
        WHERE actor_id = NEW.actor_id; 
        IF (
            SELECT count(*) < 1 FROM "dashboard_memberships_public".app_memberships
            WHERE is_owner = TRUE
        ) THEN 
            RAISE EXCEPTION 'REQUIRES_ONE_OWNER';
        END IF;
    END IF;
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

CREATE TRIGGER app_owner_grants_insert_trg 
 BEFORE INSERT ON dashboard_memberships_public.app_owner_grants 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_memberships_private. app_owner_grants_apply_tg (  );

CREATE TRIGGER app_membership_defaults_insert_trg 
 BEFORE INSERT ON dashboard_memberships_public.app_membership_defaults 
 FOR EACH ROW
 EXECUTE PROCEDURE utils. ensure_singleton (  );

INSERT INTO dashboard_permissions_public.app_permissions ( bitnum, name, description ) VALUES (1, 'admin_members', 'Manage members of the app.'), (2, 'create_invites', 'Create invites for the app.'), (3, 'admin_invites', 'Approve invites of the app.'), (4, 'invites_approved', 'Invites sent are approved for the app.'), (5, 'create_organizations', 'Create organizations within the app.'), (6, 'create_groups', 'Create groups within the app.'), (7, 'admin_limits', 'Manage limits within the app.'), (8, 'admin_permissions', 'Manage permissions within the app.'), (9, 'admin_levels', 'Manage levels of the app.'), (10, 'admin_objects', 'Manage objects of the app.'), (11, 'admin_privileged_data', 'Manage privileged data within the app.');

INSERT INTO dashboard_permissions_public.app_permission_defaults ( permissions ) VALUES (dashboard_permissions_public.app_permissions_get_mask_by_names(ARRAY['invites_approved', 'create_invites']::citext[]));

CREATE SCHEMA dashboard_status_public;

GRANT USAGE ON SCHEMA dashboard_status_public TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_status_public 
 GRANT ALL ON TABLES  TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_status_public 
 GRANT ALL ON SEQUENCES  TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_status_public 
 GRANT ALL ON FUNCTIONS  TO administrator;

GRANT USAGE ON SCHEMA dashboard_status_public TO authenticated;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_status_public 
 GRANT ALL ON FUNCTIONS  TO authenticated;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_status_public 
 GRANT USAGE, SELECT ON SEQUENCES  TO authenticated;

GRANT USAGE ON SCHEMA dashboard_status_public TO anonymous;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_status_public 
 GRANT ALL ON FUNCTIONS  TO anonymous;

CREATE SCHEMA dashboard_status_private;

GRANT USAGE ON SCHEMA dashboard_status_private TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_status_private 
 GRANT ALL ON TABLES  TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_status_private 
 GRANT ALL ON SEQUENCES  TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_status_private 
 GRANT ALL ON FUNCTIONS  TO administrator;

GRANT USAGE ON SCHEMA dashboard_status_private TO authenticated;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_status_private 
 GRANT ALL ON FUNCTIONS  TO authenticated;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_status_private 
 GRANT USAGE, SELECT ON SEQUENCES  TO authenticated;

GRANT USAGE ON SCHEMA dashboard_status_private TO anonymous;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_status_private 
 GRANT ALL ON FUNCTIONS  TO anonymous;

CREATE TABLE dashboard_status_public.app_steps (
  
);

ALTER TABLE dashboard_status_public.app_steps DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_status_public.app_steps ADD COLUMN  id uuid;

ALTER TABLE dashboard_status_public.app_steps ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_status_public.app_steps ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_status_public.app_steps ADD CONSTRAINT app_steps_pkey PRIMARY KEY ( id );

COMMENT ON TABLE dashboard_status_public.app_steps IS E'The user achieving a requirement for a level. Log table that has every single step ever taken.';

ALTER TABLE dashboard_status_public.app_steps ADD COLUMN  actor_id uuid;

ALTER TABLE dashboard_status_public.app_steps ALTER COLUMN actor_id SET NOT NULL;

ALTER TABLE dashboard_status_public.app_steps ALTER COLUMN actor_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_status_public.app_steps ADD CONSTRAINT app_steps_actor_id_fkey FOREIGN KEY ( actor_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

ALTER TABLE dashboard_status_public.app_steps ADD COLUMN  name citext;

ALTER TABLE dashboard_status_public.app_steps ALTER COLUMN name SET NOT NULL;

ALTER TABLE dashboard_status_public.app_steps ADD COLUMN  count int;

ALTER TABLE dashboard_status_public.app_steps ALTER COLUMN count SET NOT NULL;

ALTER TABLE dashboard_status_public.app_steps ALTER COLUMN count SET DEFAULT 1;

CREATE INDEX app_steps_actor_id_name_idx ON dashboard_status_public.app_steps ( actor_id, name );

ALTER TABLE dashboard_status_public.app_steps ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_status_public.app_steps ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_status_public.app_steps ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_status_public.app_steps ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_status_public.app_steps 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_status_public.app_steps ( created_at );

CREATE INDEX ON dashboard_status_public.app_steps ( updated_at );

CREATE TABLE dashboard_status_public.app_achievements (
  
);

ALTER TABLE dashboard_status_public.app_achievements DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_status_public.app_achievements ADD COLUMN  id uuid;

ALTER TABLE dashboard_status_public.app_achievements ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_status_public.app_achievements ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_status_public.app_achievements ADD CONSTRAINT app_achievements_pkey PRIMARY KEY ( id );

COMMENT ON TABLE dashboard_status_public.app_achievements IS E'This table represents the users progress for particular level requirements, tallying the total count. This table is updated via triggers and should not be updated maually.';

ALTER TABLE dashboard_status_public.app_achievements ADD COLUMN  actor_id uuid;

ALTER TABLE dashboard_status_public.app_achievements ALTER COLUMN actor_id SET NOT NULL;

ALTER TABLE dashboard_status_public.app_achievements ALTER COLUMN actor_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_status_public.app_achievements ADD CONSTRAINT app_achievements_actor_id_fkey FOREIGN KEY ( actor_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

ALTER TABLE dashboard_status_public.app_achievements ADD COLUMN  name citext;

ALTER TABLE dashboard_status_public.app_achievements ALTER COLUMN name SET NOT NULL;

ALTER TABLE dashboard_status_public.app_achievements ADD COLUMN  count int;

ALTER TABLE dashboard_status_public.app_achievements ALTER COLUMN count SET NOT NULL;

ALTER TABLE dashboard_status_public.app_achievements ALTER COLUMN count SET DEFAULT 0;

ALTER TABLE dashboard_status_public.app_achievements ADD CONSTRAINT app_achievements_actor_id_name_key UNIQUE ( actor_id, name );

ALTER TABLE dashboard_status_public.app_achievements ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_status_public.app_achievements ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_status_public.app_achievements ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_status_public.app_achievements ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_status_public.app_achievements 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_status_public.app_achievements ( created_at );

CREATE INDEX ON dashboard_status_public.app_achievements ( updated_at );

CREATE TABLE dashboard_status_public.app_levels (
  
);

ALTER TABLE dashboard_status_public.app_levels DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_status_public.app_levels ADD COLUMN  id uuid;

ALTER TABLE dashboard_status_public.app_levels ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_status_public.app_levels ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_status_public.app_levels ADD CONSTRAINT app_levels_pkey PRIMARY KEY ( id );

COMMENT ON TABLE dashboard_status_public.app_levels IS E'Levels for achievement';

ALTER TABLE dashboard_status_public.app_levels ADD COLUMN  name citext;

ALTER TABLE dashboard_status_public.app_levels ALTER COLUMN name SET NOT NULL;

ALTER TABLE dashboard_status_public.app_levels ADD CONSTRAINT app_levels_name_key UNIQUE ( name );

ALTER TABLE dashboard_status_public.app_levels ADD COLUMN  description text;

ALTER TABLE dashboard_status_public.app_levels ADD COLUMN  image image;

ALTER TABLE dashboard_status_public.app_levels ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_status_public.app_levels ADD CONSTRAINT app_levels_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

ALTER TABLE dashboard_status_public.app_levels ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_status_public.app_levels ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_status_public.app_levels ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_status_public.app_levels ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_status_public.app_levels 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_status_public.app_levels ( created_at );

CREATE INDEX ON dashboard_status_public.app_levels ( updated_at );

CREATE TABLE dashboard_status_public.app_level_requirements (
  
);

ALTER TABLE dashboard_status_public.app_level_requirements DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_status_public.app_level_requirements ADD COLUMN  id uuid;

ALTER TABLE dashboard_status_public.app_level_requirements ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_status_public.app_level_requirements ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_status_public.app_level_requirements ADD CONSTRAINT app_level_requirements_pkey PRIMARY KEY ( id );

COMMENT ON TABLE dashboard_status_public.app_level_requirements IS E'Requirements to achieve a level';

ALTER TABLE dashboard_status_public.app_level_requirements ADD COLUMN  name citext;

ALTER TABLE dashboard_status_public.app_level_requirements ALTER COLUMN name SET NOT NULL;

ALTER TABLE dashboard_status_public.app_level_requirements ADD COLUMN  level citext;

ALTER TABLE dashboard_status_public.app_level_requirements ALTER COLUMN level SET NOT NULL;

ALTER TABLE dashboard_status_public.app_level_requirements ADD COLUMN  description text;

ALTER TABLE dashboard_status_public.app_level_requirements ADD COLUMN  required_count int;

ALTER TABLE dashboard_status_public.app_level_requirements ALTER COLUMN required_count SET NOT NULL;

ALTER TABLE dashboard_status_public.app_level_requirements ALTER COLUMN required_count SET DEFAULT 1;

ALTER TABLE dashboard_status_public.app_level_requirements ADD COLUMN  priority int;

ALTER TABLE dashboard_status_public.app_level_requirements ALTER COLUMN priority SET NOT NULL;

ALTER TABLE dashboard_status_public.app_level_requirements ALTER COLUMN priority SET DEFAULT 100;

ALTER TABLE dashboard_status_public.app_level_requirements ADD CONSTRAINT app_level_requirements_name_level_key UNIQUE ( name, level );

CREATE INDEX app_level_requirements_level_idx ON dashboard_status_public.app_level_requirements ( level );

CREATE INDEX app_level_requirements_name_level_priority_idx ON dashboard_status_public.app_level_requirements ( name, level, priority );

ALTER TABLE dashboard_status_public.app_level_requirements ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_status_public.app_level_requirements ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_status_public.app_level_requirements ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_status_public.app_level_requirements ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_status_public.app_level_requirements 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_status_public.app_level_requirements ( created_at );

CREATE INDEX ON dashboard_status_public.app_level_requirements ( updated_at );

CREATE FUNCTION dashboard_status_public.steps_required ( vlevel text, vrole_id uuid DEFAULT jwt_public.current_user_id() ) RETURNS SETOF dashboard_status_public.app_level_requirements AS $EOFCODE$
BEGIN
  RETURN QUERY
  SELECT 
      app_level_requirements.id,
      app_level_requirements.name,
      app_level_requirements.level,
      app_level_requirements.description,
      -1*(coalesce(app_achievements.count,0)-app_level_requirements.required_count) as required_count,
      app_level_requirements.priority
    FROM
      "dashboard_status_public".app_level_requirements 
    FULL OUTER JOIN "dashboard_status_public".app_achievements ON (
      app_achievements.name = app_level_requirements.name
      AND app_achievements.actor_id = vrole_id
    )	
    JOIN "dashboard_status_public".app_levels ON (app_level_requirements.level = app_levels.name)
  WHERE
    app_level_requirements.level = vlevel
    AND -1*(coalesce(app_achievements.count,0)-app_level_requirements.required_count) > 0
  ORDER BY priority ASC;
END;
$EOFCODE$ LANGUAGE plpgsql STABLE;

GRANT EXECUTE ON FUNCTION dashboard_status_public.steps_required TO authenticated;

CREATE FUNCTION dashboard_status_public.steps_achieved ( vlevel text, vrole_id uuid DEFAULT jwt_public.current_user_id() ) RETURNS boolean AS $EOFCODE$
DECLARE
  c int;
BEGIN
  SELECT COUNT(*) FROM
    "dashboard_status_public".steps_required(
      vlevel,
      vrole_id
    )
  INTO c;
  RETURN c <= 0;
END;
$EOFCODE$ LANGUAGE plpgsql STABLE;

GRANT EXECUTE ON FUNCTION dashboard_status_public.steps_achieved TO authenticated;

CREATE FUNCTION dashboard_status_private.completed_step ( step text, actor_id uuid DEFAULT jwt_public.current_user_id() ) RETURNS void AS $EOFCODE$
BEGIN
  IF (actor_id IS NOT NULL) THEN 
    INSERT INTO "dashboard_status_public".app_steps ( name, actor_id, count )
    VALUES ( step, actor_id, 1 );
  END IF;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION dashboard_status_private.completed_step TO authenticated;

CREATE FUNCTION dashboard_status_private.incompleted_step ( step text, actor_id uuid DEFAULT jwt_public.current_user_id() ) RETURNS void AS $EOFCODE$
BEGIN
  IF (incompleted_step.actor_id IS NOT NULL) THEN 
    DELETE FROM "dashboard_status_public".app_steps s
      WHERE s.actor_id = incompleted_step.actor_id
      AND s.name = step;
    DELETE FROM "dashboard_status_public".app_achievements a
      WHERE a.actor_id = incompleted_step.actor_id
      AND a.name = step;
  END IF;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION dashboard_status_private.incompleted_step TO authenticated;

CREATE FUNCTION dashboard_status_private.tg_achv (  ) RETURNS trigger AS $EOFCODE$
DECLARE
  is_null boolean;
  task_name text;
BEGIN
    IF (TG_OP = 'INSERT' OR TG_OP = 'UPDATE') THEN
        task_name = TG_ARGV[1]::text;
        EXECUTE format('SELECT ($1).%s IS NULL', TG_ARGV[0])
        USING NEW INTO is_null;
        IF (is_null IS FALSE) THEN
            PERFORM "dashboard_status_private".completed_step(task_name);
        END IF;
        RETURN NEW;
    END IF;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE;

GRANT EXECUTE ON FUNCTION dashboard_status_private.tg_achv TO authenticated;

CREATE FUNCTION dashboard_status_private.tg_achv_tgl (  ) RETURNS trigger AS $EOFCODE$
DECLARE
  is_null boolean;
  task_name text;
BEGIN
    IF (TG_OP = 'INSERT' OR TG_OP = 'UPDATE') THEN
        task_name = TG_ARGV[1]::text;
        EXECUTE format('SELECT ($1).%s IS NULL', TG_ARGV[0])
        USING NEW INTO is_null;
        IF (is_null IS TRUE) THEN
            PERFORM "dashboard_status_private".incompleted_step(task_name);
        ELSE
            PERFORM "dashboard_status_private".completed_step(task_name);
        END IF;
        RETURN NEW;
    END IF;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE;

GRANT EXECUTE ON FUNCTION dashboard_status_private.tg_achv_tgl TO authenticated;

CREATE FUNCTION dashboard_status_private.tg_achv_tgl_bool (  ) RETURNS trigger AS $EOFCODE$
DECLARE
  is_true boolean;
  task_name text;
BEGIN
    IF (TG_OP = 'INSERT' OR TG_OP = 'UPDATE') THEN
        task_name = TG_ARGV[1]::text;
        EXECUTE format('SELECT ($1).%s IS TRUE', TG_ARGV[0])
        USING NEW INTO is_true;
        IF (is_true IS TRUE) THEN
            PERFORM "dashboard_status_private".completed_step(task_name);
        ELSE
            PERFORM "dashboard_status_private".incompleted_step(task_name);
        END IF;
        RETURN NEW;
    END IF;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE;

GRANT EXECUTE ON FUNCTION dashboard_status_private.tg_achv_tgl_bool TO authenticated;

CREATE FUNCTION dashboard_status_private.tg_achv_bool (  ) RETURNS trigger AS $EOFCODE$
DECLARE
  is_true boolean;
  task_name text;
BEGIN
    IF (TG_OP = 'INSERT' OR TG_OP = 'UPDATE') THEN
        task_name = TG_ARGV[1]::text;
        EXECUTE format('SELECT ($1).%s IS TRUE', TG_ARGV[0])
        USING NEW INTO is_true;
        IF (is_true IS TRUE) THEN
            PERFORM "dashboard_status_private".completed_step(task_name);
        END IF;
        RETURN NEW;
    END IF;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE;

GRANT EXECUTE ON FUNCTION dashboard_status_private.tg_achv_bool TO authenticated;

CREATE FUNCTION dashboard_status_private.upsert_achve ( vactor_id uuid, vname text, vcount int ) RETURNS void AS $EOFCODE$
BEGIN
    INSERT INTO "dashboard_status_public".app_achievements (actor_id, name, count)
    VALUES 
        (vactor_id, vname, GREATEST(vcount, 0))
    ON CONFLICT ( actor_id, name )
    DO UPDATE SET 
        count = app_achievements.count + EXCLUDED.count
    ;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE;

GRANT EXECUTE ON FUNCTION dashboard_status_private.upsert_achve TO authenticated;

CREATE FUNCTION dashboard_status_private.tg_upd_achv (  ) RETURNS trigger AS $EOFCODE$
DECLARE
BEGIN
    PERFORM "dashboard_status_private".upsert_achve(NEW.actor_id, NEW.name, NEW.count);
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION dashboard_status_private.tg_upd_achv TO authenticated;

CREATE TRIGGER app_steps_after_insert_tgr 
 AFTER INSERT ON dashboard_status_public.app_steps 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_status_private. tg_upd_achv (  );

CREATE TABLE dashboard_permissions_public.membership_permissions (
  
);

ALTER TABLE dashboard_permissions_public.membership_permissions DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_permissions_public.membership_permissions ADD COLUMN  id uuid;

ALTER TABLE dashboard_permissions_public.membership_permissions ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_permissions_public.membership_permissions ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_permissions_public.membership_permissions ADD CONSTRAINT membership_permissions_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_permissions_public.membership_permissions ADD COLUMN  name citext;

ALTER TABLE dashboard_permissions_public.membership_permissions ADD CONSTRAINT membership_permissions_name_key UNIQUE ( name );

ALTER TABLE dashboard_permissions_public.membership_permissions ADD COLUMN  bitnum int;

ALTER TABLE dashboard_permissions_public.membership_permissions ADD CONSTRAINT membership_permissions_bitnum_chk CHECK ( bitnum >= 1 AND bitnum <= 32 );

ALTER TABLE dashboard_permissions_public.membership_permissions ADD CONSTRAINT membership_permissions_bitnum_key UNIQUE ( bitnum );

ALTER TABLE dashboard_permissions_public.membership_permissions ADD COLUMN  bitstr bit(32);

ALTER TABLE dashboard_permissions_public.membership_permissions ALTER COLUMN bitstr SET NOT NULL;

ALTER TABLE dashboard_permissions_public.membership_permissions ALTER COLUMN bitstr SET DEFAULT lpad('', 32, '0')::bit(32);

ALTER TABLE dashboard_permissions_public.membership_permissions ADD COLUMN  description text;

CREATE OR REPLACE FUNCTION dashboard_permissions_public.membership_permissions_get_padded_mask ( mask pg_catalog.varbit ) RETURNS pg_catalog.varbit AS $EOFCODE$
    SELECT utils.bitmask_pad(mask, 32, '0');
$EOFCODE$ LANGUAGE sql IMMUTABLE;

GRANT EXECUTE ON FUNCTION dashboard_permissions_public.membership_permissions_get_padded_mask TO authenticated;

CREATE FUNCTION dashboard_permissions_public.membership_permissions_get_by_mask ( mask pg_catalog.varbit ) RETURNS SETOF dashboard_permissions_public.membership_permissions AS $EOFCODE$
    SELECT * FROM 
      "dashboard_permissions_public".membership_permissions
    WHERE bitstr & "dashboard_permissions_public".membership_permissions_get_padded_mask(mask) = bitstr;
$EOFCODE$ LANGUAGE sql STABLE;

GRANT EXECUTE ON FUNCTION dashboard_permissions_public.membership_permissions_get_by_mask TO authenticated;

CREATE FUNCTION dashboard_permissions_public.membership_permissions_get_mask ( ids uuid[] ) RETURNS pg_catalog.varbit AS $EOFCODE$
    SELECT bit_or(bitstr) FROM 
      "dashboard_permissions_public".membership_permissions
    WHERE id = ANY (ids);
$EOFCODE$ LANGUAGE sql STABLE;

GRANT EXECUTE ON FUNCTION dashboard_permissions_public.membership_permissions_get_mask TO authenticated;

CREATE FUNCTION dashboard_permissions_public.membership_permissions_get_mask_by_names ( names citext[] ) RETURNS pg_catalog.varbit AS $EOFCODE$
    SELECT bit_or(bitstr) FROM 
      "dashboard_permissions_public".membership_permissions
    WHERE name = ANY (names);
$EOFCODE$ LANGUAGE sql STABLE;

GRANT EXECUTE ON FUNCTION dashboard_permissions_public.membership_permissions_get_mask_by_names TO authenticated;

CREATE FUNCTION dashboard_permissions_private.membership_permissions_bitnum_tg (  ) RETURNS trigger AS $EOFCODE$
DECLARE
    bitlen int = bit_length(NEW.bitstr);
BEGIN
    NEW.bitstr = 
        lpad('', bitlen - NEW.bitnum, '0') ||
	    '1' ||
	    lpad('', NEW.bitnum - 1, '0');
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER membership_permissions_insert_trg 
 BEFORE INSERT ON dashboard_permissions_public.membership_permissions 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_permissions_private. membership_permissions_bitnum_tg (  );

CREATE TABLE dashboard_permissions_public.membership_permission_defaults (
  
);

ALTER TABLE dashboard_permissions_public.membership_permission_defaults DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_permissions_public.membership_permission_defaults ADD COLUMN  id uuid;

ALTER TABLE dashboard_permissions_public.membership_permission_defaults ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_permissions_public.membership_permission_defaults ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_permissions_public.membership_permission_defaults ADD CONSTRAINT membership_permission_defaults_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_permissions_public.membership_permission_defaults ADD COLUMN  permissions bit(32);

ALTER TABLE dashboard_permissions_public.membership_permission_defaults ALTER COLUMN permissions SET NOT NULL;

ALTER TABLE dashboard_permissions_public.membership_permission_defaults ALTER COLUMN permissions SET DEFAULT lpad('', 32, '0')::bit(32);

ALTER TABLE dashboard_permissions_public.membership_permission_defaults ADD COLUMN  entity_id uuid;

ALTER TABLE dashboard_permissions_public.membership_permission_defaults ALTER COLUMN entity_id SET NOT NULL;

ALTER TABLE dashboard_permissions_public.membership_permission_defaults ADD CONSTRAINT membership_permission_defaults_entity_id_fkey FOREIGN KEY ( entity_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

CREATE TABLE dashboard_limits_public.membership_limits (
  
);

ALTER TABLE dashboard_limits_public.membership_limits DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_limits_public.membership_limits ADD COLUMN  id uuid;

ALTER TABLE dashboard_limits_public.membership_limits ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_limits_public.membership_limits ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_limits_public.membership_limits ADD CONSTRAINT membership_limits_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_limits_public.membership_limits ADD COLUMN  name citext;

ALTER TABLE dashboard_limits_public.membership_limits ADD COLUMN  actor_id uuid;

ALTER TABLE dashboard_limits_public.membership_limits ALTER COLUMN actor_id SET NOT NULL;

ALTER TABLE dashboard_limits_public.membership_limits ADD CONSTRAINT membership_limits_actor_id_fkey FOREIGN KEY ( actor_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

ALTER TABLE dashboard_limits_public.membership_limits ADD COLUMN  num int;

ALTER TABLE dashboard_limits_public.membership_limits ADD COLUMN  max int;

ALTER TABLE dashboard_limits_public.membership_limits ADD COLUMN  entity_id uuid;

ALTER TABLE dashboard_limits_public.membership_limits ALTER COLUMN entity_id SET NOT NULL;

ALTER TABLE dashboard_limits_public.membership_limits ADD CONSTRAINT membership_limits_entity_id_fkey FOREIGN KEY ( entity_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

ALTER TABLE dashboard_limits_public.membership_limits ADD CONSTRAINT membership_limits_name_actor_id_entity_id_key UNIQUE ( name, actor_id, entity_id );

CREATE TABLE dashboard_limits_public.membership_limit_defaults (
  
);

ALTER TABLE dashboard_limits_public.membership_limit_defaults DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_limits_public.membership_limit_defaults ADD COLUMN  id uuid;

ALTER TABLE dashboard_limits_public.membership_limit_defaults ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_limits_public.membership_limit_defaults ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_limits_public.membership_limit_defaults ADD CONSTRAINT membership_limit_defaults_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_limits_public.membership_limit_defaults ADD COLUMN  name citext;

ALTER TABLE dashboard_limits_public.membership_limit_defaults ALTER COLUMN name SET NOT NULL;

ALTER TABLE dashboard_limits_public.membership_limit_defaults ADD COLUMN  max int;

ALTER TABLE dashboard_limits_public.membership_limit_defaults ADD CONSTRAINT membership_limit_defaults_name_key UNIQUE ( name );

CREATE FUNCTION dashboard_limits_private.membership_limits_inc ( limitname citext, entity_id uuid, actor_id uuid DEFAULT jwt_public.current_user_id(), amount int DEFAULT 1 ) RETURNS boolean AS $EOFCODE$
DECLARE
    limit_exists boolean;
    max_default int = 0;
    rec "dashboard_limits_public".membership_limits;
BEGIN
    SELECT EXISTS (SELECT 1 FROM "dashboard_limits_public".membership_limits l
        WHERE l.name = limitname
        AND l.actor_id = membership_limits_inc.actor_id
        AND l.entity_id = membership_limits_inc.entity_id
    ) INTO limit_exists;
    IF (limit_exists IS FALSE) THEN 
        SELECT max FROM "dashboard_limits_public".membership_limit_defaults
            WHERE name = limitname
        INTO max_default;
        IF (NOT FOUND) THEN 
            max_default = 0;
        END IF;
        INSERT INTO "dashboard_limits_public".membership_limits (name, num, max, actor_id, entity_id)
        VALUES (limitname, 0, max_default, actor_id, entity_id);
    END IF;
    SELECT * FROM "dashboard_limits_public".membership_limits l
        WHERE l.name = limitname
        AND l.actor_id = membership_limits_inc.actor_id
        AND l.entity_id = membership_limits_inc.entity_id
    INTO rec;
    IF (rec.max < 0 OR rec.max >= rec.num + amount) THEN 
        UPDATE "dashboard_limits_public".membership_limits l
        SET num = num + amount
        WHERE l.name = limitname
        AND l.actor_id = membership_limits_inc.actor_id
        AND l.entity_id = membership_limits_inc.entity_id;
        RETURN TRUE;
    ELSE
        RETURN FALSE;
    END IF;
    RETURN FALSE;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE FUNCTION dashboard_limits_private.membership_limits_dec ( limitname citext, entity_id uuid, actor_id uuid DEFAULT jwt_public.current_user_id(), amount int DEFAULT 1 ) RETURNS boolean AS $EOFCODE$
DECLARE
    limit_exists boolean;
    max_default int = 0;
    rec "dashboard_limits_public".membership_limits;
BEGIN
    SELECT EXISTS (SELECT 1 FROM "dashboard_limits_public".membership_limits l
        WHERE l.name = limitname
        AND l.actor_id = membership_limits_dec.actor_id
        AND l.entity_id = membership_limits_dec.entity_id
    ) INTO limit_exists;
    IF (limit_exists IS FALSE) THEN 
        SELECT max FROM "dashboard_limits_public".membership_limit_defaults
            WHERE name = limitname
        INTO max_default;
        IF (NOT FOUND) THEN 
            max_default = 0;
        END IF;
        INSERT INTO "dashboard_limits_public".membership_limits (name, num, max, actor_id, entity_id)
        VALUES (limitname, 0, max_default, actor_id, entity_id);
    END IF;
    UPDATE "dashboard_limits_public".membership_limits l
    SET num = greatest(num - amount, 0)
    WHERE l.name = limitname
    AND l.actor_id = membership_limits_dec.actor_id
    AND l.entity_id = membership_limits_dec.entity_id;
    RETURN TRUE;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE FUNCTION dashboard_limits_private.membership_limits_inc_tg (  ) RETURNS trigger AS $EOFCODE$
DECLARE
    limit_ok boolean;
    actor_id uuid;
    limitname citext;
BEGIN
    IF (TG_NARGS < 1) THEN 
        RAISE EXCEPTION 'LIMIT_TRIGGER_ARGS (%)', TG_NAME;
    ELSIF (TG_NARGS = 1) THEN 
        limitname = TG_ARGV[0];        
        limit_ok = "dashboard_limits_private".membership_limits_inc(
            limitname
        );
    ELSIF (TG_NARGS = 2) THEN 
        limitname = TG_ARGV[0];        
        EXECUTE format('SELECT ($1).%s', TG_ARGV[1])
        USING NEW INTO actor_id;
        limit_ok = "dashboard_limits_private".membership_limits_inc(
            limitname, actor_id
        );
    END IF;
    IF (limit_ok IS FALSE) THEN 
        RAISE EXCEPTION 'LIMIT_REACHED';
    END IF;
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE FUNCTION dashboard_limits_private.membership_limits_dec_tg (  ) RETURNS trigger AS $EOFCODE$
DECLARE
    actor_id uuid;
    limitname citext;
BEGIN
    IF (TG_NARGS < 1) THEN 
        RAISE EXCEPTION 'LIMIT_TRIGGER_ARGS (%)', TG_NAME;
    ELSIF (TG_NARGS = 1) THEN 
        limitname = TG_ARGV[0];        
        PERFORM "dashboard_limits_private".membership_limits_dec(
            limitname
        );
    ELSIF (TG_NARGS = 2) THEN 
        limitname = TG_ARGV[0];        
        EXECUTE format('SELECT ($1).%s', TG_ARGV[1])
        USING OLD INTO actor_id;
        PERFORM "dashboard_limits_private".membership_limits_dec(
            limitname, actor_id
        );
    END IF;
    RETURN OLD;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE FUNCTION dashboard_limits_private.membership_limits_upd_tg (  ) RETURNS trigger AS $EOFCODE$
DECLARE
    limit_ok boolean;
    old_actor_id uuid;
    new_actor_id uuid;
    limitname citext;
BEGIN
    IF (TG_NARGS < 1) THEN 
        RAISE EXCEPTION 'LIMIT_TRIGGER_ARGS (%)', TG_NAME;
    ELSIF (TG_NARGS = 1) THEN 
        RAISE EXCEPTION 'LIMIT_TRIGGER_ARGS (%)', TG_NAME;
    ELSIF (TG_NARGS = 2) THEN 
        limitname = TG_ARGV[0];        
        EXECUTE format('SELECT ($1).%s', TG_ARGV[1])
        USING NEW INTO new_actor_id;
        EXECUTE format('SELECT ($1).%s', TG_ARGV[1])
        USING OLD INTO old_actor_id;
        PERFORM "dashboard_limits_private".membership_limits_dec(
            limitname, old_actor_id
        );
        limit_ok = "dashboard_limits_private".membership_limits_inc(
            limitname, new_actor_id
        );
        
    END IF;
    IF (limit_ok IS FALSE) THEN 
        RAISE EXCEPTION 'LIMIT_REACHED';
    END IF;
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE FUNCTION dashboard_limits_private.membership_limits_check ( limitname citext, amount int DEFAULT 1, user_id uuid DEFAULT jwt_public.current_user_id() ) RETURNS boolean AS $EOFCODE$
DECLARE
    limit_exists boolean;
    max_default int = 0;
    rec "dashboard_limits_public".membership_limits;
BEGIN
    SELECT EXISTS (SELECT 1 FROM "dashboard_limits_public".membership_limits 
        WHERE name = limitname
        AND actor_id = user_id
    ) INTO limit_exists;
    IF (limit_exists IS FALSE) THEN 
        SELECT max FROM "dashboard_limits_public".membership_limit_defaults
            WHERE name = limitname
        INTO max_default;
        IF (NOT FOUND) THEN 
            max_default = 0;
        END IF;
        INSERT INTO "dashboard_limits_public".membership_limits (name, num, max, actor_id)
        VALUES (limitname, 0, max_default, user_id);
    END IF;
    SELECT * FROM "dashboard_limits_public".membership_limits
        WHERE name = limitname
        AND actor_id = user_id
    INTO rec;
    IF (rec.max >= rec.num + amount) THEN 
        RETURN TRUE;
    ELSE
        RETURN FALSE;
    END IF;
    RETURN FALSE;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TABLE dashboard_memberships_public.memberships (
  
);

ALTER TABLE dashboard_memberships_public.memberships DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_memberships_public.memberships ADD COLUMN  id uuid;

ALTER TABLE dashboard_memberships_public.memberships ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_memberships_public.memberships ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_memberships_public.memberships ADD CONSTRAINT memberships_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_memberships_public.memberships ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_memberships_public.memberships ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_memberships_public.memberships ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_memberships_public.memberships ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_memberships_public.memberships 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_memberships_public.memberships ( created_at );

CREATE INDEX ON dashboard_memberships_public.memberships ( updated_at );

ALTER TABLE dashboard_memberships_public.memberships ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_memberships_public.memberships ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_memberships_public.memberships 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_memberships_public.memberships ( created_by );

CREATE INDEX ON dashboard_memberships_public.memberships ( updated_by );

CREATE TABLE dashboard_memberships_public.membership_defaults (
  
);

ALTER TABLE dashboard_memberships_public.membership_defaults DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_memberships_public.membership_defaults ADD COLUMN  id uuid;

ALTER TABLE dashboard_memberships_public.membership_defaults ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_memberships_public.membership_defaults ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_memberships_public.membership_defaults ADD CONSTRAINT membership_defaults_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_memberships_public.membership_defaults ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_memberships_public.membership_defaults ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_memberships_public.membership_defaults ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_memberships_public.membership_defaults ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_memberships_public.membership_defaults 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_memberships_public.membership_defaults ( created_at );

CREATE INDEX ON dashboard_memberships_public.membership_defaults ( updated_at );

ALTER TABLE dashboard_memberships_public.membership_defaults ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_memberships_public.membership_defaults ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_memberships_public.membership_defaults 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_memberships_public.membership_defaults ( created_by );

CREATE INDEX ON dashboard_memberships_public.membership_defaults ( updated_by );

CREATE TABLE dashboard_memberships_private.memberships_acl (
  
);

ALTER TABLE dashboard_memberships_private.memberships_acl DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_memberships_private.memberships_acl ADD COLUMN  is_owner boolean;

ALTER TABLE dashboard_memberships_private.memberships_acl ALTER COLUMN is_owner SET NOT NULL;

ALTER TABLE dashboard_memberships_private.memberships_acl ALTER COLUMN is_owner SET DEFAULT FALSE;

ALTER TABLE dashboard_memberships_private.memberships_acl ADD COLUMN  is_admin boolean;

ALTER TABLE dashboard_memberships_private.memberships_acl ALTER COLUMN is_admin SET NOT NULL;

ALTER TABLE dashboard_memberships_private.memberships_acl ALTER COLUMN is_admin SET DEFAULT FALSE;

ALTER TABLE dashboard_memberships_private.memberships_acl ADD COLUMN  permissions bit(32);

ALTER TABLE dashboard_memberships_private.memberships_acl ALTER COLUMN permissions SET NOT NULL;

ALTER TABLE dashboard_memberships_private.memberships_acl ALTER COLUMN permissions SET DEFAULT lpad('', 32, '0')::bit(32);

CREATE INDEX memberships_acls_is_admin_idx ON dashboard_memberships_private.memberships_acl ( is_admin );

CREATE INDEX memberships_acls_is_owner_idx ON dashboard_memberships_private.memberships_acl ( is_owner );

ALTER TABLE dashboard_memberships_private.memberships_acl ADD COLUMN  actor_id uuid;

ALTER TABLE dashboard_memberships_private.memberships_acl ALTER COLUMN actor_id SET NOT NULL;

ALTER TABLE dashboard_memberships_private.memberships_acl ADD COLUMN  entity_id uuid;

ALTER TABLE dashboard_memberships_private.memberships_acl ALTER COLUMN entity_id SET NOT NULL;

CREATE UNIQUE INDEX memberships_acls_actor_id_entity_id_idx ON dashboard_memberships_private.memberships_acl ( actor_id, entity_id ) INCLUDE ( permissions );

CREATE INDEX memberships_acls_actor_id_idx ON dashboard_memberships_private.memberships_acl ( actor_id ) INCLUDE ( permissions, is_owner, is_admin );

CREATE INDEX memberships_acls_entity_id_idx ON dashboard_memberships_private.memberships_acl ( entity_id ) INCLUDE ( permissions, is_owner, is_admin );

GRANT SELECT ON TABLE dashboard_memberships_private.memberships_acl TO PUBLIC;

ALTER TABLE dashboard_memberships_public.membership_defaults ADD COLUMN  is_approved boolean;

ALTER TABLE dashboard_memberships_public.membership_defaults ALTER COLUMN is_approved SET NOT NULL;

ALTER TABLE dashboard_memberships_public.membership_defaults ALTER COLUMN is_approved SET DEFAULT TRUE;

ALTER TABLE dashboard_memberships_public.membership_defaults ADD COLUMN  entity_id uuid;

ALTER TABLE dashboard_memberships_public.membership_defaults ALTER COLUMN entity_id SET NOT NULL;

ALTER TABLE dashboard_memberships_public.membership_defaults ADD CONSTRAINT membership_defaults_entity_id_fkey FOREIGN KEY ( entity_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

ALTER TABLE dashboard_memberships_public.membership_defaults ADD CONSTRAINT membership_defaults_entity_id_key UNIQUE ( entity_id );

ALTER TABLE dashboard_memberships_public.membership_defaults ADD COLUMN  delete_member_cascade_groups boolean;

ALTER TABLE dashboard_memberships_public.membership_defaults ALTER COLUMN delete_member_cascade_groups SET NOT NULL;

ALTER TABLE dashboard_memberships_public.membership_defaults ALTER COLUMN delete_member_cascade_groups SET DEFAULT FALSE;

ALTER TABLE dashboard_memberships_public.membership_defaults ADD COLUMN  create_groups_cascade_members boolean;

ALTER TABLE dashboard_memberships_public.membership_defaults ALTER COLUMN create_groups_cascade_members SET NOT NULL;

ALTER TABLE dashboard_memberships_public.membership_defaults ALTER COLUMN create_groups_cascade_members SET DEFAULT FALSE;

ALTER TABLE dashboard_memberships_public.memberships ADD COLUMN  is_approved boolean;

ALTER TABLE dashboard_memberships_public.memberships ALTER COLUMN is_approved SET NOT NULL;

ALTER TABLE dashboard_memberships_public.memberships ALTER COLUMN is_approved SET DEFAULT FALSE;

ALTER TABLE dashboard_memberships_public.memberships ADD COLUMN  is_banned boolean;

ALTER TABLE dashboard_memberships_public.memberships ALTER COLUMN is_banned SET NOT NULL;

ALTER TABLE dashboard_memberships_public.memberships ALTER COLUMN is_banned SET DEFAULT FALSE;

ALTER TABLE dashboard_memberships_public.memberships ADD COLUMN  is_disabled boolean;

ALTER TABLE dashboard_memberships_public.memberships ALTER COLUMN is_disabled SET NOT NULL;

ALTER TABLE dashboard_memberships_public.memberships ALTER COLUMN is_disabled SET DEFAULT FALSE;

ALTER TABLE dashboard_memberships_public.memberships ADD COLUMN  is_active boolean;

ALTER TABLE dashboard_memberships_public.memberships ALTER COLUMN is_active SET NOT NULL;

ALTER TABLE dashboard_memberships_public.memberships ALTER COLUMN is_active SET DEFAULT FALSE;

ALTER TABLE dashboard_memberships_public.memberships ADD COLUMN  is_owner boolean;

ALTER TABLE dashboard_memberships_public.memberships ALTER COLUMN is_owner SET NOT NULL;

ALTER TABLE dashboard_memberships_public.memberships ALTER COLUMN is_owner SET DEFAULT FALSE;

ALTER TABLE dashboard_memberships_public.memberships ADD COLUMN  is_admin boolean;

ALTER TABLE dashboard_memberships_public.memberships ALTER COLUMN is_admin SET NOT NULL;

ALTER TABLE dashboard_memberships_public.memberships ALTER COLUMN is_admin SET DEFAULT FALSE;

ALTER TABLE dashboard_memberships_public.memberships ADD COLUMN  permissions bit(32);

ALTER TABLE dashboard_memberships_public.memberships ALTER COLUMN permissions SET NOT NULL;

ALTER TABLE dashboard_memberships_public.memberships ALTER COLUMN permissions SET DEFAULT lpad('', 32, '0')::bit(32);

ALTER TABLE dashboard_memberships_public.memberships ADD COLUMN  granted bit(32);

ALTER TABLE dashboard_memberships_public.memberships ALTER COLUMN granted SET NOT NULL;

ALTER TABLE dashboard_memberships_public.memberships ALTER COLUMN granted SET DEFAULT lpad('', 32, '0')::bit(32);

ALTER TABLE dashboard_memberships_public.memberships ADD COLUMN  actor_id uuid;

ALTER TABLE dashboard_memberships_public.memberships ALTER COLUMN actor_id SET NOT NULL;

CREATE INDEX memberships_is_admin_idx ON dashboard_memberships_public.memberships ( is_admin );

CREATE INDEX memberships_is_owner_idx ON dashboard_memberships_public.memberships ( is_owner );

ALTER TABLE dashboard_memberships_public.memberships ADD CONSTRAINT memberships_actor_id_fkey FOREIGN KEY ( actor_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

ALTER TABLE dashboard_memberships_public.memberships ADD COLUMN  entity_id uuid;

ALTER TABLE dashboard_memberships_public.memberships ALTER COLUMN entity_id SET NOT NULL;

ALTER TABLE dashboard_memberships_public.memberships ADD CONSTRAINT memberships_entity_id_fkey FOREIGN KEY ( entity_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

ALTER TABLE dashboard_memberships_public.memberships ADD CONSTRAINT memberships_actor_id_entity_id_key UNIQUE ( actor_id, entity_id );

CREATE INDEX memberships_actor_id_idx ON dashboard_memberships_public.memberships ( actor_id );

CREATE INDEX memberships_entity_id_idx ON dashboard_memberships_public.memberships ( entity_id );

CREATE TABLE dashboard_memberships_public.members (
  
);

ALTER TABLE dashboard_memberships_public.members DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_memberships_public.members ADD COLUMN  id uuid;

ALTER TABLE dashboard_memberships_public.members ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_memberships_public.members ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_memberships_public.members ADD CONSTRAINT members_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_memberships_public.members ADD COLUMN  is_admin boolean;

ALTER TABLE dashboard_memberships_public.members ALTER COLUMN is_admin SET NOT NULL;

ALTER TABLE dashboard_memberships_public.members ALTER COLUMN is_admin SET DEFAULT FALSE;

ALTER TABLE dashboard_memberships_public.members ADD COLUMN  actor_id uuid;

ALTER TABLE dashboard_memberships_public.members ALTER COLUMN actor_id SET NOT NULL;

CREATE INDEX members_is_admin_idx ON dashboard_memberships_public.members ( is_admin );

ALTER TABLE dashboard_memberships_public.members ADD CONSTRAINT members_actor_id_fkey FOREIGN KEY ( actor_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

ALTER TABLE dashboard_memberships_public.members ADD COLUMN  entity_id uuid;

ALTER TABLE dashboard_memberships_public.members ALTER COLUMN entity_id SET NOT NULL;

ALTER TABLE dashboard_memberships_public.members ADD CONSTRAINT members_entity_id_fkey FOREIGN KEY ( entity_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

ALTER TABLE dashboard_memberships_public.members ADD CONSTRAINT members_actor_id_entity_id_key UNIQUE ( actor_id, entity_id );

CREATE INDEX members_actor_id_idx ON dashboard_memberships_public.members ( actor_id );

CREATE INDEX members_entity_id_idx ON dashboard_memberships_public.members ( entity_id );

CREATE FUNCTION dashboard_memberships_private.memberships_insert_acl_tg (  ) RETURNS trigger AS $EOFCODE$
DECLARE
BEGIN
    IF (NEW.is_owner IS TRUE) THEN 
      NEW.is_admin = TRUE;
      NEW.is_approved = TRUE;
      NEW.is_disabled = FALSE;
      NEW.is_banned = FALSE;
    END IF;
    SELECT (
        NEW.is_approved IS TRUE
    AND
        NEW.is_disabled IS FALSE
    AND
        NEW.is_banned IS FALSE 
    ) INTO NEW.is_active;
    IF (NEW.is_active IS TRUE) THEN 
        INSERT INTO "dashboard_memberships_private".memberships_acl 
            (is_owner, is_admin, permissions, actor_id, entity_id)
        VALUES 
            (NEW.is_owner, NEW.is_admin, NEW.permissions, NEW.actor_id, NEW.entity_id)
        ;
        INSERT INTO "dashboard_memberships_public".members 
            (is_admin, actor_id, entity_id)
        VALUES 
            (NEW.is_admin, NEW.actor_id, NEW.entity_id)
        ;
    END IF;
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

CREATE FUNCTION dashboard_memberships_private.memberships_update_acl_tg (  ) RETURNS trigger AS $EOFCODE$
DECLARE
    v_num_updated int;
BEGIN
  
    IF (NEW.is_owner IS TRUE) THEN 
      NEW.is_admin = TRUE;
      NEW.is_approved = TRUE;
      NEW.is_disabled = FALSE;
      NEW.is_banned = FALSE;
    END IF;
    SELECT (
        NEW.is_approved IS TRUE
    AND
        NEW.is_disabled IS FALSE
    AND
        NEW.is_banned IS FALSE 
    ) INTO NEW.is_active;
    IF ( NEW.is_active IS FALSE ) THEN 
        DELETE FROM "dashboard_memberships_private".memberships_acl 
            WHERE actor_id = NEW.actor_id
                AND entity_id = NEW.entity_id;
        DELETE FROM "dashboard_memberships_public".members 
            WHERE actor_id = NEW.actor_id
                AND entity_id = NEW.entity_id;
    ELSE 
        INSERT INTO "dashboard_memberships_private".memberships_acl 
            (is_owner, is_admin, permissions, actor_id, entity_id)
        VALUES 
            (NEW.is_owner, NEW.is_admin, NEW.permissions, NEW.actor_id, NEW.entity_id)
        ON CONFLICT (actor_id, entity_id)
        DO UPDATE
          SET
            is_owner = EXCLUDED.is_owner,
            is_admin = EXCLUDED.is_admin,
            permissions = EXCLUDED.permissions
        ;
        INSERT INTO "dashboard_memberships_public".members 
            (is_admin, actor_id, entity_id)
        VALUES 
            (NEW.is_admin, NEW.actor_id, NEW.entity_id)
        ON CONFLICT (actor_id, entity_id)
        DO NOTHING;
    END IF;
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

CREATE FUNCTION dashboard_memberships_private.memberships_delete_acl_tg (  ) RETURNS trigger AS $EOFCODE$
DECLARE
    v_num_updated int;
BEGIN
  
    DELETE FROM "dashboard_memberships_private".memberships_acl 
    WHERE actor_id = OLD.actor_id
        AND entity_id = OLD.entity_id;
    DELETE FROM "dashboard_memberships_public".members 
    WHERE actor_id = OLD.actor_id
        AND entity_id = OLD.entity_id;
    RETURN OLD;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

CREATE FUNCTION dashboard_memberships_private.memberships_perm_check ( perm text, entity_id uuid, actor_id uuid DEFAULT jwt_public.current_user_id() ) RETURNS boolean AS $EOFCODE$
SELECT EXISTS (
      SELECT 1 FROM "dashboard_memberships_public".memberships m,
		      "dashboard_permissions_public".membership_permissions p
          WHERE
          	p.name = perm
          AND m.permissions & p.bitstr = p.bitstr
          AND m.entity_id = memberships_perm_check.entity_id
          AND m.actor_id = memberships_perm_check.actor_id
);
$EOFCODE$ LANGUAGE sql STABLE SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION dashboard_memberships_private.memberships_perm_check TO authenticated;

CREATE FUNCTION dashboard_memberships_private.memberships_mask_check ( mask pg_catalog.varbit, entity_id uuid, actor_id uuid DEFAULT jwt_public.current_user_id() ) RETURNS boolean AS $EOFCODE$
    SELECT EXISTS (
        SELECT 1 FROM "dashboard_memberships_public".memberships m
            WHERE m.permissions & mask = mask
            AND m.entity_id = memberships_mask_check.entity_id
            AND m.actor_id = memberships_mask_check.actor_id
    );
$EOFCODE$ LANGUAGE sql STABLE SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION dashboard_memberships_private.memberships_mask_check TO authenticated;

CREATE FUNCTION dashboard_memberships_private.memberships_perm_ids ( perm text ) RETURNS uuid[] AS $EOFCODE$
      SELECT array_agg(m.entity_id) FROM "dashboard_memberships_public".memberships m,
		      "dashboard_permissions_public".membership_permissions p
          WHERE
          	p.name = perm
          AND m.permissions & p.bitstr = p.bitstr
          AND m.actor_id = jwt_public.current_user_id()
$EOFCODE$ LANGUAGE sql STABLE SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION dashboard_memberships_private.memberships_perm_ids TO authenticated;

CREATE FUNCTION dashboard_memberships_private.memberships_mask_ids ( mask pg_catalog.varbit ) RETURNS uuid[] AS $EOFCODE$
    SELECT array_agg(m.entity_id) FROM "dashboard_memberships_public".memberships m
        WHERE m.permissions & mask = mask
        AND m.actor_id = jwt_public.current_user_id()
$EOFCODE$ LANGUAGE sql STABLE SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION dashboard_memberships_private.memberships_mask_ids TO authenticated;

CREATE FUNCTION dashboard_memberships_private.memberships_ids (  ) RETURNS uuid[] AS $EOFCODE$
    SELECT array_agg(m.entity_id) FROM "dashboard_memberships_public".memberships m
        WHERE m.actor_id = jwt_public.current_user_id()
$EOFCODE$ LANGUAGE sql STABLE SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION dashboard_memberships_private.memberships_ids TO authenticated;

CREATE TABLE dashboard_memberships_public.admin_grants (
  
);

ALTER TABLE dashboard_memberships_public.admin_grants DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_memberships_public.admin_grants ADD COLUMN  id uuid;

ALTER TABLE dashboard_memberships_public.admin_grants ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_memberships_public.admin_grants ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_memberships_public.admin_grants ADD CONSTRAINT admin_grants_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_memberships_public.admin_grants ADD COLUMN  is_grant boolean;

ALTER TABLE dashboard_memberships_public.admin_grants ALTER COLUMN is_grant SET NOT NULL;

ALTER TABLE dashboard_memberships_public.admin_grants ALTER COLUMN is_grant SET DEFAULT TRUE;

ALTER TABLE dashboard_memberships_public.admin_grants ADD COLUMN  actor_id uuid;

ALTER TABLE dashboard_memberships_public.admin_grants ALTER COLUMN actor_id SET NOT NULL;

ALTER TABLE dashboard_memberships_public.admin_grants ADD CONSTRAINT admin_grants_actor_id_fkey FOREIGN KEY ( actor_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

ALTER TABLE dashboard_memberships_public.admin_grants ADD COLUMN  entity_id uuid;

ALTER TABLE dashboard_memberships_public.admin_grants ALTER COLUMN entity_id SET NOT NULL;

ALTER TABLE dashboard_memberships_public.admin_grants ADD CONSTRAINT admin_grants_entity_id_fkey FOREIGN KEY ( entity_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

CREATE INDEX admin_grants_entity_id_idx ON dashboard_memberships_public.admin_grants ( entity_id );

ALTER TABLE dashboard_memberships_public.admin_grants ADD COLUMN  grantor_id uuid;

ALTER TABLE dashboard_memberships_public.admin_grants ALTER COLUMN grantor_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_memberships_public.admin_grants ADD CONSTRAINT admin_grants_grantor_id_fkey FOREIGN KEY ( grantor_id ) REFERENCES dashboard_public.users ( id ) ON DELETE SET NULL;

CREATE INDEX admin_grants_grantor_id_idx ON dashboard_memberships_public.admin_grants ( grantor_id );

ALTER TABLE dashboard_memberships_public.admin_grants ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_memberships_public.admin_grants ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_memberships_public.admin_grants ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_memberships_public.admin_grants ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_memberships_public.admin_grants 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_memberships_public.admin_grants ( created_at );

CREATE INDEX ON dashboard_memberships_public.admin_grants ( updated_at );

CREATE TABLE dashboard_memberships_public.owner_grants (
  
);

ALTER TABLE dashboard_memberships_public.owner_grants DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_memberships_public.owner_grants ADD COLUMN  id uuid;

ALTER TABLE dashboard_memberships_public.owner_grants ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_memberships_public.owner_grants ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_memberships_public.owner_grants ADD CONSTRAINT owner_grants_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_memberships_public.owner_grants ADD COLUMN  is_grant boolean;

ALTER TABLE dashboard_memberships_public.owner_grants ALTER COLUMN is_grant SET NOT NULL;

ALTER TABLE dashboard_memberships_public.owner_grants ALTER COLUMN is_grant SET DEFAULT TRUE;

ALTER TABLE dashboard_memberships_public.owner_grants ADD COLUMN  actor_id uuid;

ALTER TABLE dashboard_memberships_public.owner_grants ALTER COLUMN actor_id SET NOT NULL;

ALTER TABLE dashboard_memberships_public.owner_grants ADD CONSTRAINT owner_grants_actor_id_fkey FOREIGN KEY ( actor_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

ALTER TABLE dashboard_memberships_public.owner_grants ADD COLUMN  entity_id uuid;

ALTER TABLE dashboard_memberships_public.owner_grants ALTER COLUMN entity_id SET NOT NULL;

ALTER TABLE dashboard_memberships_public.owner_grants ADD CONSTRAINT owner_grants_entity_id_fkey FOREIGN KEY ( entity_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

CREATE INDEX owner_grants_entity_id_idx ON dashboard_memberships_public.owner_grants ( entity_id );

ALTER TABLE dashboard_memberships_public.owner_grants ADD COLUMN  grantor_id uuid;

ALTER TABLE dashboard_memberships_public.owner_grants ALTER COLUMN grantor_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_memberships_public.owner_grants ADD CONSTRAINT owner_grants_grantor_id_fkey FOREIGN KEY ( grantor_id ) REFERENCES dashboard_public.users ( id ) ON DELETE SET NULL;

CREATE INDEX owner_grants_grantor_id_idx ON dashboard_memberships_public.owner_grants ( grantor_id );

ALTER TABLE dashboard_memberships_public.owner_grants ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_memberships_public.owner_grants ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_memberships_public.owner_grants ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_memberships_public.owner_grants ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_memberships_public.owner_grants 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_memberships_public.owner_grants ( created_at );

CREATE INDEX ON dashboard_memberships_public.owner_grants ( updated_at );

CREATE TABLE dashboard_memberships_public.grants (
  
);

ALTER TABLE dashboard_memberships_public.grants DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_memberships_public.grants ADD COLUMN  id uuid;

ALTER TABLE dashboard_memberships_public.grants ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_memberships_public.grants ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_memberships_public.grants ADD CONSTRAINT grants_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_memberships_public.grants ADD COLUMN  permissions bit(32);

ALTER TABLE dashboard_memberships_public.grants ALTER COLUMN permissions SET NOT NULL;

ALTER TABLE dashboard_memberships_public.grants ALTER COLUMN permissions SET DEFAULT lpad('', 32, '0')::bit(32);

ALTER TABLE dashboard_memberships_public.grants ADD COLUMN  is_grant boolean;

ALTER TABLE dashboard_memberships_public.grants ALTER COLUMN is_grant SET NOT NULL;

ALTER TABLE dashboard_memberships_public.grants ALTER COLUMN is_grant SET DEFAULT TRUE;

ALTER TABLE dashboard_memberships_public.grants ADD COLUMN  actor_id uuid;

ALTER TABLE dashboard_memberships_public.grants ALTER COLUMN actor_id SET NOT NULL;

ALTER TABLE dashboard_memberships_public.grants ADD CONSTRAINT grants_actor_id_fkey FOREIGN KEY ( actor_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

ALTER TABLE dashboard_memberships_public.grants ADD COLUMN  entity_id uuid;

ALTER TABLE dashboard_memberships_public.grants ALTER COLUMN entity_id SET NOT NULL;

ALTER TABLE dashboard_memberships_public.grants ADD CONSTRAINT grants_entity_id_fkey FOREIGN KEY ( entity_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

CREATE INDEX grants_entity_id_idx ON dashboard_memberships_public.grants ( entity_id );

ALTER TABLE dashboard_memberships_public.grants ADD COLUMN  grantor_id uuid;

ALTER TABLE dashboard_memberships_public.grants ALTER COLUMN grantor_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_memberships_public.grants ADD CONSTRAINT grants_grantor_id_fkey FOREIGN KEY ( grantor_id ) REFERENCES dashboard_public.users ( id ) ON DELETE SET NULL;

CREATE INDEX grants_grantor_id_idx ON dashboard_memberships_public.grants ( grantor_id );

ALTER TABLE dashboard_memberships_public.grants ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_memberships_public.grants ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_memberships_public.grants ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_memberships_public.grants ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_memberships_public.grants 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_memberships_public.grants ( created_at );

CREATE INDEX ON dashboard_memberships_public.grants ( updated_at );

CREATE FUNCTION dashboard_memberships_private.memberships_itg (  ) RETURNS trigger AS $EOFCODE$
DECLARE
    bitlen int = bit_length(NEW.permissions);
    defaults bit varying;
    memdefs "dashboard_memberships_public".membership_defaults;
BEGIN
    SELECT * FROM
        "dashboard_memberships_public".membership_defaults t 
        WHERE t.entity_id = NEW.entity_id
    INTO memdefs;
    IF (FOUND) THEN 
        NEW.is_approved = memdefs.is_approved;
    END IF;
    IF (NEW.is_owner IS TRUE) THEN 
        NEW.is_admin = TRUE;
        NEW.is_approved = TRUE;
        NEW.is_disabled = FALSE;
        NEW.is_banned = FALSE;
    END IF;
    SELECT (
        NEW.is_approved IS TRUE
    AND
        NEW.is_disabled IS FALSE
    AND
        NEW.is_banned IS FALSE 
    ) INTO NEW.is_active;
    SELECT permissions FROM
        "dashboard_permissions_public".membership_permission_defaults t 
        WHERE t.entity_id = NEW.entity_id
    INTO defaults;
    IF (NOT FOUND) THEN 
        NEW.granted = lpad('', bitlen::int, '0');
    ELSE
        NEW.granted = defaults;
    END IF;
    IF (NEW.is_admin IS TRUE OR NEW.is_owner IS TRUE) THEN 
        NEW.permissions = lpad('', bitlen::int, '1');
    ELSE
        NEW.permissions = NEW.granted;
    END IF;
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

CREATE FUNCTION dashboard_memberships_private.memberships_utg (  ) RETURNS trigger AS $EOFCODE$
DECLARE
    bitlen int = bit_length(NEW.permissions);
BEGIN
    IF (NEW.is_owner IS TRUE) THEN 
        NEW.is_admin = TRUE;
        NEW.is_approved = TRUE;
        NEW.is_disabled = FALSE;
        NEW.is_banned = FALSE;
    END IF;
    SELECT (
        NEW.is_approved IS TRUE
    AND
        NEW.is_disabled IS FALSE
    AND
        NEW.is_banned IS FALSE 
    ) INTO NEW.is_active;
    IF (NEW.is_admin IS TRUE OR NEW.is_owner IS TRUE) THEN 
        NEW.permissions = lpad('', bitlen::int, '1');
    ELSE
        NEW.permissions = NEW.granted;
    END IF;
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

CREATE TRIGGER _00010_memberships_itrg 
 BEFORE INSERT ON dashboard_memberships_public.memberships 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_memberships_private. memberships_itg (  );

CREATE TRIGGER _00010_memberships_utrg 
 BEFORE UPDATE ON dashboard_memberships_public.memberships 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_memberships_private. memberships_utg (  );

CREATE TRIGGER _00020_memberships_insert_acl 
 AFTER INSERT ON dashboard_memberships_public.memberships 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_memberships_private. memberships_insert_acl_tg (  );

CREATE TRIGGER _00020_memberships_update_acl 
 AFTER UPDATE ON dashboard_memberships_public.memberships 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_memberships_private. memberships_update_acl_tg (  );

CREATE TRIGGER _99999_memberships_delete_acl 
 AFTER DELETE ON dashboard_memberships_public.memberships 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_memberships_private. memberships_delete_acl_tg (  );

CREATE FUNCTION dashboard_memberships_private.memberships_dtg (  ) RETURNS trigger AS $EOFCODE$
BEGIN
    IF (
        SELECT count(*) = 0 FROM "dashboard_memberships_public".memberships 
        WHERE is_owner = TRUE
        AND entity_id = OLD.entity_id
        AND actor_id <> OLD.actor_id
    ) THEN 
        IF (
            SELECT count(*) > 0 FROM "dashboard_memberships_public".memberships 
            WHERE entity_id = OLD.entity_id
            AND actor_id <> OLD.actor_id
        ) THEN 
            RAISE EXCEPTION 'REQUIRES_ONE_OWNER';
        END IF;
    END IF;
    RETURN OLD;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

CREATE TRIGGER _99990_memberships_owners_chk 
 BEFORE DELETE ON dashboard_memberships_public.memberships 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_memberships_private. memberships_dtg (  );

CREATE FUNCTION dashboard_memberships_private.membership_mbr_create (  ) RETURNS trigger AS $EOFCODE$
DECLARE
    owner_id uuid = jwt_public.current_user_id();
BEGIN
    IF (NEW.type = 0) THEN 
        INSERT INTO "dashboard_memberships_public".memberships
        ( is_owner, actor_id, entity_id  )
        VALUES ( TRUE, NEW.id, NEW.id );
    ELSEIF (owner_id IS NOT NULL) THEN 
        INSERT INTO "dashboard_memberships_public".memberships
        ( is_owner, actor_id, entity_id  )
        VALUES ( TRUE, owner_id, NEW.id );
        INSERT INTO "dashboard_memberships_public".membership_defaults
        ( entity_id  ) -- is_approved, etc., defaults from table itself
        VALUES ( NEW.id );
        INSERT INTO "dashboard_permissions_public".membership_permission_defaults 
            (permissions, entity_id)
        VALUES 
        (
            "dashboard_permissions_public".membership_permissions_get_mask_by_names(
                ARRAY['invites_approved', 'create_invites']::citext[]
            ),
            NEW.id
        );
    END IF;
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

CREATE TRIGGER membership_mbr_trg 
 AFTER INSERT ON dashboard_public.users 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_memberships_private. membership_mbr_create (  );

CREATE FUNCTION dashboard_memberships_private.grants_apply_tg (  ) RETURNS trigger AS $EOFCODE$
BEGIN
    IF (NEW.is_grant IS TRUE) THEN 
        UPDATE "dashboard_memberships_public".memberships 
            SET granted = granted | NEW.permissions
        WHERE actor_id = NEW.actor_id
        AND entity_id = NEW.entity_id; 
    ELSE 
        UPDATE "dashboard_memberships_public".memberships 
            SET granted = granted & ~ NEW.permissions
        WHERE actor_id = NEW.actor_id
        AND entity_id = NEW.entity_id; 
    END IF;
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER grants_insert_trg 
 BEFORE INSERT ON dashboard_memberships_public.grants 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_memberships_private. grants_apply_tg (  );

CREATE FUNCTION dashboard_memberships_private.admin_grants_apply_tg (  ) RETURNS trigger AS $EOFCODE$
BEGIN
    IF (NEW.is_grant IS TRUE) THEN 
        UPDATE "dashboard_memberships_public".memberships 
            SET is_admin = TRUE
        WHERE actor_id = NEW.actor_id
        AND entity_id = NEW.entity_id; 
    ELSE 
        UPDATE "dashboard_memberships_public".memberships 
            SET is_admin = FALSE
        WHERE actor_id = NEW.actor_id
        AND entity_id = NEW.entity_id
        AND is_owner = FALSE; 
    END IF;
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

CREATE TRIGGER admin_grants_insert_trg 
 BEFORE INSERT ON dashboard_memberships_public.admin_grants 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_memberships_private. admin_grants_apply_tg (  );

CREATE FUNCTION dashboard_memberships_private.owner_grants_apply_tg (  ) RETURNS trigger AS $EOFCODE$
BEGIN
    IF (NEW.is_grant IS TRUE) THEN 
        UPDATE "dashboard_memberships_public".memberships 
            SET is_owner = TRUE
        WHERE actor_id = NEW.actor_id
        AND entity_id = NEW.entity_id; 
    ELSE 
        UPDATE "dashboard_memberships_public".memberships 
            SET is_owner = FALSE
        WHERE actor_id = NEW.actor_id
        AND entity_id = NEW.entity_id; 
        IF (
            SELECT count(*) < 1 FROM "dashboard_memberships_public".memberships 
            WHERE is_owner = TRUE
            AND entity_id = NEW.entity_id
        ) THEN 
            RAISE EXCEPTION 'REQUIRES_ONE_OWNER';
        END IF;
    END IF;
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

CREATE TRIGGER owner_grants_insert_trg 
 BEFORE INSERT ON dashboard_memberships_public.owner_grants 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_memberships_private. owner_grants_apply_tg (  );

INSERT INTO dashboard_permissions_public.membership_permissions ( bitnum, name, description ) VALUES (1, 'admin_members', 'Manage members of the organization.'), (2, 'create_invites', 'Create invites for the organization.'), (3, 'admin_invites', 'Manage invites of the organization.'), (4, 'invites_approved', 'Invites sent are approved for the organization.'), (5, 'create_organizations', 'Create organizations within the organization.'), (6, 'create_groups', 'Create groups within the organization.'), (7, 'admin_limits', 'Manage limits within the organization.'), (8, 'admin_permissions', 'Manage permissions within the organization.'), (9, 'admin_levels', 'Manage levels of the organization.'), (10, 'admin_objects', 'Manage objects of the organization.'), (11, 'admin_privileged_data', 'Manage privileged data within the organization.'), (12, 'admin_account', 'Manage account of the organization.'), (13, 'admin_profile', 'Manage profile of the organization.');

CREATE TABLE dashboard_public.groups (
  
);

ALTER TABLE dashboard_public.groups DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.groups ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.groups ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.groups ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.groups ADD CONSTRAINT groups_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.groups ADD COLUMN  name text;

ALTER TABLE dashboard_public.groups ADD COLUMN  image image;

ALTER TABLE dashboard_public.groups ADD COLUMN  header_image image;

ALTER TABLE dashboard_public.groups ADD COLUMN  limited_to_location bool;

ALTER TABLE dashboard_public.groups ALTER COLUMN limited_to_location SET NOT NULL;

ALTER TABLE dashboard_public.groups ALTER COLUMN limited_to_location SET DEFAULT FALSE;

ALTER TABLE dashboard_public.groups ADD COLUMN  bounds geometry(geometrycollection, 4326);

COMMENT ON COLUMN dashboard_public.groups.bounds IS E'all locations combined using ST_Collect for search optimization';

ALTER TABLE dashboard_public.groups ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.groups ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.groups 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.groups ( created_by );

CREATE INDEX ON dashboard_public.groups ( updated_by );

ALTER TABLE dashboard_public.groups ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.groups ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.groups ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.groups ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.groups 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.groups ( created_at );

CREATE INDEX ON dashboard_public.groups ( updated_at );

CREATE INDEX groups_bounds_idx ON dashboard_public.groups USING GIST ( bounds );

ALTER TABLE dashboard_public.groups ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.groups ADD CONSTRAINT groups_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT groups_owner_id_fkey ON dashboard_public.groups IS NULL;

CREATE INDEX groups_owner_id_idx ON dashboard_public.groups ( owner_id );

CREATE TABLE dashboard_permissions_public.group_member_permissions (
  
);

ALTER TABLE dashboard_permissions_public.group_member_permissions DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_permissions_public.group_member_permissions ADD COLUMN  id uuid;

ALTER TABLE dashboard_permissions_public.group_member_permissions ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_permissions_public.group_member_permissions ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_permissions_public.group_member_permissions ADD CONSTRAINT group_member_permissions_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_permissions_public.group_member_permissions ADD COLUMN  name citext;

ALTER TABLE dashboard_permissions_public.group_member_permissions ADD CONSTRAINT group_member_permissions_name_key UNIQUE ( name );

ALTER TABLE dashboard_permissions_public.group_member_permissions ADD COLUMN  bitnum int;

ALTER TABLE dashboard_permissions_public.group_member_permissions ADD CONSTRAINT group_member_permissions_bitnum_chk CHECK ( bitnum >= 1 AND bitnum <= 32 );

ALTER TABLE dashboard_permissions_public.group_member_permissions ADD CONSTRAINT group_member_permissions_bitnum_key UNIQUE ( bitnum );

ALTER TABLE dashboard_permissions_public.group_member_permissions ADD COLUMN  bitstr bit(32);

ALTER TABLE dashboard_permissions_public.group_member_permissions ALTER COLUMN bitstr SET NOT NULL;

ALTER TABLE dashboard_permissions_public.group_member_permissions ALTER COLUMN bitstr SET DEFAULT lpad('', 32, '0')::bit(32);

ALTER TABLE dashboard_permissions_public.group_member_permissions ADD COLUMN  description text;

CREATE OR REPLACE FUNCTION dashboard_permissions_public.group_member_permissions_get_padded_mask ( mask pg_catalog.varbit ) RETURNS pg_catalog.varbit AS $EOFCODE$
    SELECT utils.bitmask_pad(mask, 32, '0');
$EOFCODE$ LANGUAGE sql IMMUTABLE;

GRANT EXECUTE ON FUNCTION dashboard_permissions_public.group_member_permissions_get_padded_mask TO authenticated;

CREATE FUNCTION dashboard_permissions_public.group_member_permissions_get_by_mask ( mask pg_catalog.varbit ) RETURNS SETOF dashboard_permissions_public.group_member_permissions AS $EOFCODE$
    SELECT * FROM 
      "dashboard_permissions_public".group_member_permissions
    WHERE bitstr & "dashboard_permissions_public".group_member_permissions_get_padded_mask(mask) = bitstr;
$EOFCODE$ LANGUAGE sql STABLE;

GRANT EXECUTE ON FUNCTION dashboard_permissions_public.group_member_permissions_get_by_mask TO authenticated;

CREATE FUNCTION dashboard_permissions_public.group_member_permissions_get_mask ( ids uuid[] ) RETURNS pg_catalog.varbit AS $EOFCODE$
    SELECT bit_or(bitstr) FROM 
      "dashboard_permissions_public".group_member_permissions
    WHERE id = ANY (ids);
$EOFCODE$ LANGUAGE sql STABLE;

GRANT EXECUTE ON FUNCTION dashboard_permissions_public.group_member_permissions_get_mask TO authenticated;

CREATE FUNCTION dashboard_permissions_public.group_member_permissions_get_mask_by_names ( names citext[] ) RETURNS pg_catalog.varbit AS $EOFCODE$
    SELECT bit_or(bitstr) FROM 
      "dashboard_permissions_public".group_member_permissions
    WHERE name = ANY (names);
$EOFCODE$ LANGUAGE sql STABLE;

GRANT EXECUTE ON FUNCTION dashboard_permissions_public.group_member_permissions_get_mask_by_names TO authenticated;

CREATE FUNCTION dashboard_permissions_private.group_member_permissions_bitnum_tg (  ) RETURNS trigger AS $EOFCODE$
DECLARE
    bitlen int = bit_length(NEW.bitstr);
BEGIN
    NEW.bitstr = 
        lpad('', bitlen - NEW.bitnum, '0') ||
	    '1' ||
	    lpad('', NEW.bitnum - 1, '0');
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER group_member_permissions_insert_trg 
 BEFORE INSERT ON dashboard_permissions_public.group_member_permissions 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_permissions_private. group_member_permissions_bitnum_tg (  );

CREATE TABLE dashboard_permissions_public.group_member_permission_defaults (
  
);

ALTER TABLE dashboard_permissions_public.group_member_permission_defaults DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_permissions_public.group_member_permission_defaults ADD COLUMN  id uuid;

ALTER TABLE dashboard_permissions_public.group_member_permission_defaults ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_permissions_public.group_member_permission_defaults ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_permissions_public.group_member_permission_defaults ADD CONSTRAINT group_member_permission_defaults_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_permissions_public.group_member_permission_defaults ADD COLUMN  permissions bit(32);

ALTER TABLE dashboard_permissions_public.group_member_permission_defaults ALTER COLUMN permissions SET NOT NULL;

ALTER TABLE dashboard_permissions_public.group_member_permission_defaults ALTER COLUMN permissions SET DEFAULT lpad('', 32, '0')::bit(32);

ALTER TABLE dashboard_permissions_public.group_member_permission_defaults ADD COLUMN  entity_id uuid;

ALTER TABLE dashboard_permissions_public.group_member_permission_defaults ALTER COLUMN entity_id SET NOT NULL;

ALTER TABLE dashboard_permissions_public.group_member_permission_defaults ADD CONSTRAINT group_member_permission_defaults_entity_id_fkey FOREIGN KEY ( entity_id ) REFERENCES dashboard_public.groups ( id ) ON DELETE CASCADE;

CREATE TABLE dashboard_limits_public.group_member_limits (
  
);

ALTER TABLE dashboard_limits_public.group_member_limits DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_limits_public.group_member_limits ADD COLUMN  id uuid;

ALTER TABLE dashboard_limits_public.group_member_limits ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_limits_public.group_member_limits ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_limits_public.group_member_limits ADD CONSTRAINT group_member_limits_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_limits_public.group_member_limits ADD COLUMN  name citext;

ALTER TABLE dashboard_limits_public.group_member_limits ADD COLUMN  actor_id uuid;

ALTER TABLE dashboard_limits_public.group_member_limits ALTER COLUMN actor_id SET NOT NULL;

ALTER TABLE dashboard_limits_public.group_member_limits ADD CONSTRAINT group_member_limits_actor_id_fkey FOREIGN KEY ( actor_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

ALTER TABLE dashboard_limits_public.group_member_limits ADD COLUMN  num int;

ALTER TABLE dashboard_limits_public.group_member_limits ADD COLUMN  max int;

ALTER TABLE dashboard_limits_public.group_member_limits ADD COLUMN  entity_id uuid;

ALTER TABLE dashboard_limits_public.group_member_limits ALTER COLUMN entity_id SET NOT NULL;

ALTER TABLE dashboard_limits_public.group_member_limits ADD CONSTRAINT group_member_limits_entity_id_fkey FOREIGN KEY ( entity_id ) REFERENCES dashboard_public.groups ( id ) ON DELETE CASCADE;

ALTER TABLE dashboard_limits_public.group_member_limits ADD CONSTRAINT group_member_limits_name_actor_id_entity_id_key UNIQUE ( name, actor_id, entity_id );

CREATE TABLE dashboard_limits_public.group_member_limit_defaults (
  
);

ALTER TABLE dashboard_limits_public.group_member_limit_defaults DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_limits_public.group_member_limit_defaults ADD COLUMN  id uuid;

ALTER TABLE dashboard_limits_public.group_member_limit_defaults ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_limits_public.group_member_limit_defaults ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_limits_public.group_member_limit_defaults ADD CONSTRAINT group_member_limit_defaults_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_limits_public.group_member_limit_defaults ADD COLUMN  name citext;

ALTER TABLE dashboard_limits_public.group_member_limit_defaults ALTER COLUMN name SET NOT NULL;

ALTER TABLE dashboard_limits_public.group_member_limit_defaults ADD COLUMN  max int;

ALTER TABLE dashboard_limits_public.group_member_limit_defaults ADD CONSTRAINT group_member_limit_defaults_name_key UNIQUE ( name );

CREATE FUNCTION dashboard_limits_private.group_member_limits_inc ( limitname citext, entity_id uuid, actor_id uuid DEFAULT jwt_public.current_user_id(), amount int DEFAULT 1 ) RETURNS boolean AS $EOFCODE$
DECLARE
    limit_exists boolean;
    max_default int = 0;
    rec "dashboard_limits_public".group_member_limits;
BEGIN
    SELECT EXISTS (SELECT 1 FROM "dashboard_limits_public".group_member_limits l
        WHERE l.name = limitname
        AND l.actor_id = group_member_limits_inc.actor_id
        AND l.entity_id = group_member_limits_inc.entity_id
    ) INTO limit_exists;
    IF (limit_exists IS FALSE) THEN 
        SELECT max FROM "dashboard_limits_public".group_member_limit_defaults
            WHERE name = limitname
        INTO max_default;
        IF (NOT FOUND) THEN 
            max_default = 0;
        END IF;
        INSERT INTO "dashboard_limits_public".group_member_limits (name, num, max, actor_id, entity_id)
        VALUES (limitname, 0, max_default, actor_id, entity_id);
    END IF;
    SELECT * FROM "dashboard_limits_public".group_member_limits l
        WHERE l.name = limitname
        AND l.actor_id = group_member_limits_inc.actor_id
        AND l.entity_id = group_member_limits_inc.entity_id
    INTO rec;
    IF (rec.max < 0 OR rec.max >= rec.num + amount) THEN 
        UPDATE "dashboard_limits_public".group_member_limits l
        SET num = num + amount
        WHERE l.name = limitname
        AND l.actor_id = group_member_limits_inc.actor_id
        AND l.entity_id = group_member_limits_inc.entity_id;
        RETURN TRUE;
    ELSE
        RETURN FALSE;
    END IF;
    RETURN FALSE;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE FUNCTION dashboard_limits_private.group_member_limits_dec ( limitname citext, entity_id uuid, actor_id uuid DEFAULT jwt_public.current_user_id(), amount int DEFAULT 1 ) RETURNS boolean AS $EOFCODE$
DECLARE
    limit_exists boolean;
    max_default int = 0;
    rec "dashboard_limits_public".group_member_limits;
BEGIN
    SELECT EXISTS (SELECT 1 FROM "dashboard_limits_public".group_member_limits l
        WHERE l.name = limitname
        AND l.actor_id = group_member_limits_dec.actor_id
        AND l.entity_id = group_member_limits_dec.entity_id
    ) INTO limit_exists;
    IF (limit_exists IS FALSE) THEN 
        SELECT max FROM "dashboard_limits_public".group_member_limit_defaults
            WHERE name = limitname
        INTO max_default;
        IF (NOT FOUND) THEN 
            max_default = 0;
        END IF;
        INSERT INTO "dashboard_limits_public".group_member_limits (name, num, max, actor_id, entity_id)
        VALUES (limitname, 0, max_default, actor_id, entity_id);
    END IF;
    UPDATE "dashboard_limits_public".group_member_limits l
    SET num = greatest(num - amount, 0)
    WHERE l.name = limitname
    AND l.actor_id = group_member_limits_dec.actor_id
    AND l.entity_id = group_member_limits_dec.entity_id;
    RETURN TRUE;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE FUNCTION dashboard_limits_private.group_member_limits_inc_tg (  ) RETURNS trigger AS $EOFCODE$
DECLARE
    limit_ok boolean;
    actor_id uuid;
    limitname citext;
BEGIN
    IF (TG_NARGS < 1) THEN 
        RAISE EXCEPTION 'LIMIT_TRIGGER_ARGS (%)', TG_NAME;
    ELSIF (TG_NARGS = 1) THEN 
        limitname = TG_ARGV[0];        
        limit_ok = "dashboard_limits_private".group_member_limits_inc(
            limitname
        );
    ELSIF (TG_NARGS = 2) THEN 
        limitname = TG_ARGV[0];        
        EXECUTE format('SELECT ($1).%s', TG_ARGV[1])
        USING NEW INTO actor_id;
        limit_ok = "dashboard_limits_private".group_member_limits_inc(
            limitname, actor_id
        );
    END IF;
    IF (limit_ok IS FALSE) THEN 
        RAISE EXCEPTION 'LIMIT_REACHED';
    END IF;
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE FUNCTION dashboard_limits_private.group_member_limits_dec_tg (  ) RETURNS trigger AS $EOFCODE$
DECLARE
    actor_id uuid;
    limitname citext;
BEGIN
    IF (TG_NARGS < 1) THEN 
        RAISE EXCEPTION 'LIMIT_TRIGGER_ARGS (%)', TG_NAME;
    ELSIF (TG_NARGS = 1) THEN 
        limitname = TG_ARGV[0];        
        PERFORM "dashboard_limits_private".group_member_limits_dec(
            limitname
        );
    ELSIF (TG_NARGS = 2) THEN 
        limitname = TG_ARGV[0];        
        EXECUTE format('SELECT ($1).%s', TG_ARGV[1])
        USING OLD INTO actor_id;
        PERFORM "dashboard_limits_private".group_member_limits_dec(
            limitname, actor_id
        );
    END IF;
    RETURN OLD;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE FUNCTION dashboard_limits_private.group_member_limits_upd_tg (  ) RETURNS trigger AS $EOFCODE$
DECLARE
    limit_ok boolean;
    old_actor_id uuid;
    new_actor_id uuid;
    limitname citext;
BEGIN
    IF (TG_NARGS < 1) THEN 
        RAISE EXCEPTION 'LIMIT_TRIGGER_ARGS (%)', TG_NAME;
    ELSIF (TG_NARGS = 1) THEN 
        RAISE EXCEPTION 'LIMIT_TRIGGER_ARGS (%)', TG_NAME;
    ELSIF (TG_NARGS = 2) THEN 
        limitname = TG_ARGV[0];        
        EXECUTE format('SELECT ($1).%s', TG_ARGV[1])
        USING NEW INTO new_actor_id;
        EXECUTE format('SELECT ($1).%s', TG_ARGV[1])
        USING OLD INTO old_actor_id;
        PERFORM "dashboard_limits_private".group_member_limits_dec(
            limitname, old_actor_id
        );
        limit_ok = "dashboard_limits_private".group_member_limits_inc(
            limitname, new_actor_id
        );
        
    END IF;
    IF (limit_ok IS FALSE) THEN 
        RAISE EXCEPTION 'LIMIT_REACHED';
    END IF;
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE FUNCTION dashboard_limits_private.group_member_limits_check ( limitname citext, amount int DEFAULT 1, user_id uuid DEFAULT jwt_public.current_user_id() ) RETURNS boolean AS $EOFCODE$
DECLARE
    limit_exists boolean;
    max_default int = 0;
    rec "dashboard_limits_public".group_member_limits;
BEGIN
    SELECT EXISTS (SELECT 1 FROM "dashboard_limits_public".group_member_limits 
        WHERE name = limitname
        AND actor_id = user_id
    ) INTO limit_exists;
    IF (limit_exists IS FALSE) THEN 
        SELECT max FROM "dashboard_limits_public".group_member_limit_defaults
            WHERE name = limitname
        INTO max_default;
        IF (NOT FOUND) THEN 
            max_default = 0;
        END IF;
        INSERT INTO "dashboard_limits_public".group_member_limits (name, num, max, actor_id)
        VALUES (limitname, 0, max_default, user_id);
    END IF;
    SELECT * FROM "dashboard_limits_public".group_member_limits
        WHERE name = limitname
        AND actor_id = user_id
    INTO rec;
    IF (rec.max >= rec.num + amount) THEN 
        RETURN TRUE;
    ELSE
        RETURN FALSE;
    END IF;
    RETURN FALSE;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TABLE dashboard_memberships_public.group_memberships (
  
);

ALTER TABLE dashboard_memberships_public.group_memberships DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_memberships_public.group_memberships ADD COLUMN  id uuid;

ALTER TABLE dashboard_memberships_public.group_memberships ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_memberships_public.group_memberships ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_memberships_public.group_memberships ADD CONSTRAINT group_memberships_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_memberships_public.group_memberships ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_memberships_public.group_memberships ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_memberships_public.group_memberships ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_memberships_public.group_memberships ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_memberships_public.group_memberships 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_memberships_public.group_memberships ( created_at );

CREATE INDEX ON dashboard_memberships_public.group_memberships ( updated_at );

ALTER TABLE dashboard_memberships_public.group_memberships ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_memberships_public.group_memberships ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_memberships_public.group_memberships 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_memberships_public.group_memberships ( created_by );

CREATE INDEX ON dashboard_memberships_public.group_memberships ( updated_by );

CREATE TABLE dashboard_memberships_public.group_membership_defaults (
  
);

ALTER TABLE dashboard_memberships_public.group_membership_defaults DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_memberships_public.group_membership_defaults ADD COLUMN  id uuid;

ALTER TABLE dashboard_memberships_public.group_membership_defaults ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_memberships_public.group_membership_defaults ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_memberships_public.group_membership_defaults ADD CONSTRAINT group_membership_defaults_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_memberships_public.group_membership_defaults ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_memberships_public.group_membership_defaults ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_memberships_public.group_membership_defaults ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_memberships_public.group_membership_defaults ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_memberships_public.group_membership_defaults 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_memberships_public.group_membership_defaults ( created_at );

CREATE INDEX ON dashboard_memberships_public.group_membership_defaults ( updated_at );

ALTER TABLE dashboard_memberships_public.group_membership_defaults ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_memberships_public.group_membership_defaults ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_memberships_public.group_membership_defaults 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_memberships_public.group_membership_defaults ( created_by );

CREATE INDEX ON dashboard_memberships_public.group_membership_defaults ( updated_by );

CREATE TABLE dashboard_memberships_private.group_memberships_acl (
  
);

ALTER TABLE dashboard_memberships_private.group_memberships_acl DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_memberships_private.group_memberships_acl ADD COLUMN  is_owner boolean;

ALTER TABLE dashboard_memberships_private.group_memberships_acl ALTER COLUMN is_owner SET NOT NULL;

ALTER TABLE dashboard_memberships_private.group_memberships_acl ALTER COLUMN is_owner SET DEFAULT FALSE;

ALTER TABLE dashboard_memberships_private.group_memberships_acl ADD COLUMN  is_admin boolean;

ALTER TABLE dashboard_memberships_private.group_memberships_acl ALTER COLUMN is_admin SET NOT NULL;

ALTER TABLE dashboard_memberships_private.group_memberships_acl ALTER COLUMN is_admin SET DEFAULT FALSE;

ALTER TABLE dashboard_memberships_private.group_memberships_acl ADD COLUMN  permissions bit(32);

ALTER TABLE dashboard_memberships_private.group_memberships_acl ALTER COLUMN permissions SET NOT NULL;

ALTER TABLE dashboard_memberships_private.group_memberships_acl ALTER COLUMN permissions SET DEFAULT lpad('', 32, '0')::bit(32);

CREATE INDEX group_memberships_acls_is_admin_idx ON dashboard_memberships_private.group_memberships_acl ( is_admin );

CREATE INDEX group_memberships_acls_is_owner_idx ON dashboard_memberships_private.group_memberships_acl ( is_owner );

ALTER TABLE dashboard_memberships_private.group_memberships_acl ADD COLUMN  actor_id uuid;

ALTER TABLE dashboard_memberships_private.group_memberships_acl ALTER COLUMN actor_id SET NOT NULL;

ALTER TABLE dashboard_memberships_private.group_memberships_acl ADD COLUMN  entity_id uuid;

ALTER TABLE dashboard_memberships_private.group_memberships_acl ALTER COLUMN entity_id SET NOT NULL;

CREATE UNIQUE INDEX group_memberships_acls_actor_id_entity_id_idx ON dashboard_memberships_private.group_memberships_acl ( actor_id, entity_id ) INCLUDE ( permissions );

CREATE INDEX group_memberships_acls_actor_id_idx ON dashboard_memberships_private.group_memberships_acl ( actor_id ) INCLUDE ( permissions, is_owner, is_admin );

CREATE INDEX group_memberships_acls_entity_id_idx ON dashboard_memberships_private.group_memberships_acl ( entity_id ) INCLUDE ( permissions, is_owner, is_admin );

GRANT SELECT ON TABLE dashboard_memberships_private.group_memberships_acl TO PUBLIC;

ALTER TABLE dashboard_memberships_public.group_membership_defaults ADD COLUMN  is_approved boolean;

ALTER TABLE dashboard_memberships_public.group_membership_defaults ALTER COLUMN is_approved SET NOT NULL;

ALTER TABLE dashboard_memberships_public.group_membership_defaults ALTER COLUMN is_approved SET DEFAULT TRUE;

ALTER TABLE dashboard_memberships_public.group_membership_defaults ADD COLUMN  entity_id uuid;

ALTER TABLE dashboard_memberships_public.group_membership_defaults ALTER COLUMN entity_id SET NOT NULL;

ALTER TABLE dashboard_memberships_public.group_membership_defaults ADD CONSTRAINT group_membership_defaults_entity_id_fkey FOREIGN KEY ( entity_id ) REFERENCES dashboard_public.groups ( id ) ON DELETE CASCADE;

ALTER TABLE dashboard_memberships_public.group_membership_defaults ADD CONSTRAINT group_membership_defaults_entity_id_key UNIQUE ( entity_id );

ALTER TABLE dashboard_memberships_public.group_memberships ADD COLUMN  is_approved boolean;

ALTER TABLE dashboard_memberships_public.group_memberships ALTER COLUMN is_approved SET NOT NULL;

ALTER TABLE dashboard_memberships_public.group_memberships ALTER COLUMN is_approved SET DEFAULT FALSE;

ALTER TABLE dashboard_memberships_public.group_memberships ADD COLUMN  is_banned boolean;

ALTER TABLE dashboard_memberships_public.group_memberships ALTER COLUMN is_banned SET NOT NULL;

ALTER TABLE dashboard_memberships_public.group_memberships ALTER COLUMN is_banned SET DEFAULT FALSE;

ALTER TABLE dashboard_memberships_public.group_memberships ADD COLUMN  is_disabled boolean;

ALTER TABLE dashboard_memberships_public.group_memberships ALTER COLUMN is_disabled SET NOT NULL;

ALTER TABLE dashboard_memberships_public.group_memberships ALTER COLUMN is_disabled SET DEFAULT FALSE;

ALTER TABLE dashboard_memberships_public.group_memberships ADD COLUMN  is_active boolean;

ALTER TABLE dashboard_memberships_public.group_memberships ALTER COLUMN is_active SET NOT NULL;

ALTER TABLE dashboard_memberships_public.group_memberships ALTER COLUMN is_active SET DEFAULT FALSE;

ALTER TABLE dashboard_memberships_public.group_memberships ADD COLUMN  is_owner boolean;

ALTER TABLE dashboard_memberships_public.group_memberships ALTER COLUMN is_owner SET NOT NULL;

ALTER TABLE dashboard_memberships_public.group_memberships ALTER COLUMN is_owner SET DEFAULT FALSE;

ALTER TABLE dashboard_memberships_public.group_memberships ADD COLUMN  is_admin boolean;

ALTER TABLE dashboard_memberships_public.group_memberships ALTER COLUMN is_admin SET NOT NULL;

ALTER TABLE dashboard_memberships_public.group_memberships ALTER COLUMN is_admin SET DEFAULT FALSE;

ALTER TABLE dashboard_memberships_public.group_memberships ADD COLUMN  permissions bit(32);

ALTER TABLE dashboard_memberships_public.group_memberships ALTER COLUMN permissions SET NOT NULL;

ALTER TABLE dashboard_memberships_public.group_memberships ALTER COLUMN permissions SET DEFAULT lpad('', 32, '0')::bit(32);

ALTER TABLE dashboard_memberships_public.group_memberships ADD COLUMN  granted bit(32);

ALTER TABLE dashboard_memberships_public.group_memberships ALTER COLUMN granted SET NOT NULL;

ALTER TABLE dashboard_memberships_public.group_memberships ALTER COLUMN granted SET DEFAULT lpad('', 32, '0')::bit(32);

ALTER TABLE dashboard_memberships_public.group_memberships ADD COLUMN  actor_id uuid;

ALTER TABLE dashboard_memberships_public.group_memberships ALTER COLUMN actor_id SET NOT NULL;

CREATE INDEX group_memberships_is_admin_idx ON dashboard_memberships_public.group_memberships ( is_admin );

CREATE INDEX group_memberships_is_owner_idx ON dashboard_memberships_public.group_memberships ( is_owner );

ALTER TABLE dashboard_memberships_public.group_memberships ADD CONSTRAINT group_memberships_actor_id_fkey FOREIGN KEY ( actor_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

ALTER TABLE dashboard_memberships_public.group_memberships ADD COLUMN  entity_id uuid;

ALTER TABLE dashboard_memberships_public.group_memberships ALTER COLUMN entity_id SET NOT NULL;

ALTER TABLE dashboard_memberships_public.group_memberships ADD CONSTRAINT group_memberships_entity_id_fkey FOREIGN KEY ( entity_id ) REFERENCES dashboard_public.groups ( id ) ON DELETE CASCADE;

ALTER TABLE dashboard_memberships_public.group_memberships ADD CONSTRAINT group_memberships_actor_id_entity_id_key UNIQUE ( actor_id, entity_id );

CREATE INDEX group_memberships_actor_id_idx ON dashboard_memberships_public.group_memberships ( actor_id );

CREATE INDEX group_memberships_entity_id_idx ON dashboard_memberships_public.group_memberships ( entity_id );

CREATE TABLE dashboard_memberships_public.group_members (
  
);

ALTER TABLE dashboard_memberships_public.group_members DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_memberships_public.group_members ADD COLUMN  id uuid;

ALTER TABLE dashboard_memberships_public.group_members ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_memberships_public.group_members ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_memberships_public.group_members ADD CONSTRAINT group_members_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_memberships_public.group_members ADD COLUMN  is_admin boolean;

ALTER TABLE dashboard_memberships_public.group_members ALTER COLUMN is_admin SET NOT NULL;

ALTER TABLE dashboard_memberships_public.group_members ALTER COLUMN is_admin SET DEFAULT FALSE;

ALTER TABLE dashboard_memberships_public.group_members ADD COLUMN  actor_id uuid;

ALTER TABLE dashboard_memberships_public.group_members ALTER COLUMN actor_id SET NOT NULL;

CREATE INDEX group_members_is_admin_idx ON dashboard_memberships_public.group_members ( is_admin );

ALTER TABLE dashboard_memberships_public.group_members ADD CONSTRAINT group_members_actor_id_fkey FOREIGN KEY ( actor_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

ALTER TABLE dashboard_memberships_public.group_members ADD COLUMN  entity_id uuid;

ALTER TABLE dashboard_memberships_public.group_members ALTER COLUMN entity_id SET NOT NULL;

ALTER TABLE dashboard_memberships_public.group_members ADD CONSTRAINT group_members_entity_id_fkey FOREIGN KEY ( entity_id ) REFERENCES dashboard_public.groups ( id ) ON DELETE CASCADE;

ALTER TABLE dashboard_memberships_public.group_members ADD CONSTRAINT group_members_actor_id_entity_id_key UNIQUE ( actor_id, entity_id );

CREATE INDEX group_members_actor_id_idx ON dashboard_memberships_public.group_members ( actor_id );

CREATE INDEX group_members_entity_id_idx ON dashboard_memberships_public.group_members ( entity_id );

CREATE FUNCTION dashboard_memberships_private.group_memberships_insert_acl_tg (  ) RETURNS trigger AS $EOFCODE$
DECLARE
BEGIN
    IF (NEW.is_owner IS TRUE) THEN 
      NEW.is_admin = TRUE;
      NEW.is_approved = TRUE;
      NEW.is_disabled = FALSE;
      NEW.is_banned = FALSE;
    END IF;
    SELECT (
        NEW.is_approved IS TRUE
    AND
        NEW.is_disabled IS FALSE
    AND
        NEW.is_banned IS FALSE 
    ) INTO NEW.is_active;
    IF (NEW.is_active IS TRUE) THEN 
        INSERT INTO "dashboard_memberships_private".group_memberships_acl 
            (is_owner, is_admin, permissions, actor_id, entity_id)
        VALUES 
            (NEW.is_owner, NEW.is_admin, NEW.permissions, NEW.actor_id, NEW.entity_id)
        ;
        INSERT INTO "dashboard_memberships_public".group_members 
            (is_admin, actor_id, entity_id)
        VALUES 
            (NEW.is_admin, NEW.actor_id, NEW.entity_id)
        ;
    END IF;
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

CREATE FUNCTION dashboard_memberships_private.group_memberships_update_acl_tg (  ) RETURNS trigger AS $EOFCODE$
DECLARE
    v_num_updated int;
BEGIN
  
    IF (NEW.is_owner IS TRUE) THEN 
      NEW.is_admin = TRUE;
      NEW.is_approved = TRUE;
      NEW.is_disabled = FALSE;
      NEW.is_banned = FALSE;
    END IF;
    SELECT (
        NEW.is_approved IS TRUE
    AND
        NEW.is_disabled IS FALSE
    AND
        NEW.is_banned IS FALSE 
    ) INTO NEW.is_active;
    IF ( NEW.is_active IS FALSE ) THEN 
        DELETE FROM "dashboard_memberships_private".group_memberships_acl 
            WHERE actor_id = NEW.actor_id
                AND entity_id = NEW.entity_id;
        DELETE FROM "dashboard_memberships_public".group_members 
            WHERE actor_id = NEW.actor_id
                AND entity_id = NEW.entity_id;
    ELSE 
        INSERT INTO "dashboard_memberships_private".group_memberships_acl 
            (is_owner, is_admin, permissions, actor_id, entity_id)
        VALUES 
            (NEW.is_owner, NEW.is_admin, NEW.permissions, NEW.actor_id, NEW.entity_id)
        ON CONFLICT (actor_id, entity_id)
        DO UPDATE
          SET
            is_owner = EXCLUDED.is_owner,
            is_admin = EXCLUDED.is_admin,
            permissions = EXCLUDED.permissions
        ;
        INSERT INTO "dashboard_memberships_public".group_members 
            (is_admin, actor_id, entity_id)
        VALUES 
            (NEW.is_admin, NEW.actor_id, NEW.entity_id)
        ON CONFLICT (actor_id, entity_id)
        DO NOTHING;
    END IF;
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

CREATE FUNCTION dashboard_memberships_private.group_memberships_delete_acl_tg (  ) RETURNS trigger AS $EOFCODE$
DECLARE
    v_num_updated int;
BEGIN
  
    DELETE FROM "dashboard_memberships_private".group_memberships_acl 
    WHERE actor_id = OLD.actor_id
        AND entity_id = OLD.entity_id;
    DELETE FROM "dashboard_memberships_public".group_members 
    WHERE actor_id = OLD.actor_id
        AND entity_id = OLD.entity_id;
    RETURN OLD;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

CREATE FUNCTION dashboard_memberships_private.group_memberships_perm_check ( perm text, entity_id uuid, actor_id uuid DEFAULT jwt_public.current_user_id() ) RETURNS boolean AS $EOFCODE$
SELECT EXISTS (
      SELECT 1 FROM "dashboard_memberships_public".group_memberships m,
		      "dashboard_permissions_public".group_member_permissions p
          WHERE
          	p.name = perm
          AND m.permissions & p.bitstr = p.bitstr
          AND m.entity_id = group_memberships_perm_check.entity_id
          AND m.actor_id = group_memberships_perm_check.actor_id
);
$EOFCODE$ LANGUAGE sql STABLE SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION dashboard_memberships_private.group_memberships_perm_check TO authenticated;

CREATE FUNCTION dashboard_memberships_private.group_memberships_mask_check ( mask pg_catalog.varbit, entity_id uuid, actor_id uuid DEFAULT jwt_public.current_user_id() ) RETURNS boolean AS $EOFCODE$
    SELECT EXISTS (
        SELECT 1 FROM "dashboard_memberships_public".group_memberships m
            WHERE m.permissions & mask = mask
            AND m.entity_id = group_memberships_mask_check.entity_id
            AND m.actor_id = group_memberships_mask_check.actor_id
    );
$EOFCODE$ LANGUAGE sql STABLE SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION dashboard_memberships_private.group_memberships_mask_check TO authenticated;

CREATE FUNCTION dashboard_memberships_private.group_memberships_perm_ids ( perm text ) RETURNS uuid[] AS $EOFCODE$
      SELECT array_agg(m.entity_id) FROM "dashboard_memberships_public".group_memberships m,
		      "dashboard_permissions_public".group_member_permissions p
          WHERE
          	p.name = perm
          AND m.permissions & p.bitstr = p.bitstr
          AND m.actor_id = jwt_public.current_user_id()
$EOFCODE$ LANGUAGE sql STABLE SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION dashboard_memberships_private.group_memberships_perm_ids TO authenticated;

CREATE FUNCTION dashboard_memberships_private.group_memberships_mask_ids ( mask pg_catalog.varbit ) RETURNS uuid[] AS $EOFCODE$
    SELECT array_agg(m.entity_id) FROM "dashboard_memberships_public".group_memberships m
        WHERE m.permissions & mask = mask
        AND m.actor_id = jwt_public.current_user_id()
$EOFCODE$ LANGUAGE sql STABLE SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION dashboard_memberships_private.group_memberships_mask_ids TO authenticated;

CREATE FUNCTION dashboard_memberships_private.group_memberships_ids (  ) RETURNS uuid[] AS $EOFCODE$
    SELECT array_agg(m.entity_id) FROM "dashboard_memberships_public".group_memberships m
        WHERE m.actor_id = jwt_public.current_user_id()
$EOFCODE$ LANGUAGE sql STABLE SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION dashboard_memberships_private.group_memberships_ids TO authenticated;

CREATE TABLE dashboard_memberships_public.group_admin_grants (
  
);

ALTER TABLE dashboard_memberships_public.group_admin_grants DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_memberships_public.group_admin_grants ADD COLUMN  id uuid;

ALTER TABLE dashboard_memberships_public.group_admin_grants ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_memberships_public.group_admin_grants ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_memberships_public.group_admin_grants ADD CONSTRAINT group_admin_grants_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_memberships_public.group_admin_grants ADD COLUMN  is_grant boolean;

ALTER TABLE dashboard_memberships_public.group_admin_grants ALTER COLUMN is_grant SET NOT NULL;

ALTER TABLE dashboard_memberships_public.group_admin_grants ALTER COLUMN is_grant SET DEFAULT TRUE;

ALTER TABLE dashboard_memberships_public.group_admin_grants ADD COLUMN  actor_id uuid;

ALTER TABLE dashboard_memberships_public.group_admin_grants ALTER COLUMN actor_id SET NOT NULL;

ALTER TABLE dashboard_memberships_public.group_admin_grants ADD CONSTRAINT group_admin_grants_actor_id_fkey FOREIGN KEY ( actor_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

ALTER TABLE dashboard_memberships_public.group_admin_grants ADD COLUMN  entity_id uuid;

ALTER TABLE dashboard_memberships_public.group_admin_grants ALTER COLUMN entity_id SET NOT NULL;

ALTER TABLE dashboard_memberships_public.group_admin_grants ADD CONSTRAINT group_admin_grants_entity_id_fkey FOREIGN KEY ( entity_id ) REFERENCES dashboard_public.groups ( id ) ON DELETE CASCADE;

CREATE INDEX group_admin_grants_entity_id_idx ON dashboard_memberships_public.group_admin_grants ( entity_id );

ALTER TABLE dashboard_memberships_public.group_admin_grants ADD COLUMN  grantor_id uuid;

ALTER TABLE dashboard_memberships_public.group_admin_grants ALTER COLUMN grantor_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_memberships_public.group_admin_grants ADD CONSTRAINT group_admin_grants_grantor_id_fkey FOREIGN KEY ( grantor_id ) REFERENCES dashboard_public.users ( id ) ON DELETE SET NULL;

CREATE INDEX group_admin_grants_grantor_id_idx ON dashboard_memberships_public.group_admin_grants ( grantor_id );

ALTER TABLE dashboard_memberships_public.group_admin_grants ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_memberships_public.group_admin_grants ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_memberships_public.group_admin_grants ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_memberships_public.group_admin_grants ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_memberships_public.group_admin_grants 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_memberships_public.group_admin_grants ( created_at );

CREATE INDEX ON dashboard_memberships_public.group_admin_grants ( updated_at );

CREATE TABLE dashboard_memberships_public.group_owner_grants (
  
);

ALTER TABLE dashboard_memberships_public.group_owner_grants DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_memberships_public.group_owner_grants ADD COLUMN  id uuid;

ALTER TABLE dashboard_memberships_public.group_owner_grants ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_memberships_public.group_owner_grants ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_memberships_public.group_owner_grants ADD CONSTRAINT group_owner_grants_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_memberships_public.group_owner_grants ADD COLUMN  is_grant boolean;

ALTER TABLE dashboard_memberships_public.group_owner_grants ALTER COLUMN is_grant SET NOT NULL;

ALTER TABLE dashboard_memberships_public.group_owner_grants ALTER COLUMN is_grant SET DEFAULT TRUE;

ALTER TABLE dashboard_memberships_public.group_owner_grants ADD COLUMN  actor_id uuid;

ALTER TABLE dashboard_memberships_public.group_owner_grants ALTER COLUMN actor_id SET NOT NULL;

ALTER TABLE dashboard_memberships_public.group_owner_grants ADD CONSTRAINT group_owner_grants_actor_id_fkey FOREIGN KEY ( actor_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

ALTER TABLE dashboard_memberships_public.group_owner_grants ADD COLUMN  entity_id uuid;

ALTER TABLE dashboard_memberships_public.group_owner_grants ALTER COLUMN entity_id SET NOT NULL;

ALTER TABLE dashboard_memberships_public.group_owner_grants ADD CONSTRAINT group_owner_grants_entity_id_fkey FOREIGN KEY ( entity_id ) REFERENCES dashboard_public.groups ( id ) ON DELETE CASCADE;

CREATE INDEX group_owner_grants_entity_id_idx ON dashboard_memberships_public.group_owner_grants ( entity_id );

ALTER TABLE dashboard_memberships_public.group_owner_grants ADD COLUMN  grantor_id uuid;

ALTER TABLE dashboard_memberships_public.group_owner_grants ALTER COLUMN grantor_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_memberships_public.group_owner_grants ADD CONSTRAINT group_owner_grants_grantor_id_fkey FOREIGN KEY ( grantor_id ) REFERENCES dashboard_public.users ( id ) ON DELETE SET NULL;

CREATE INDEX group_owner_grants_grantor_id_idx ON dashboard_memberships_public.group_owner_grants ( grantor_id );

ALTER TABLE dashboard_memberships_public.group_owner_grants ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_memberships_public.group_owner_grants ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_memberships_public.group_owner_grants ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_memberships_public.group_owner_grants ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_memberships_public.group_owner_grants 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_memberships_public.group_owner_grants ( created_at );

CREATE INDEX ON dashboard_memberships_public.group_owner_grants ( updated_at );

CREATE TABLE dashboard_memberships_public.group_grants (
  
);

ALTER TABLE dashboard_memberships_public.group_grants DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_memberships_public.group_grants ADD COLUMN  id uuid;

ALTER TABLE dashboard_memberships_public.group_grants ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_memberships_public.group_grants ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_memberships_public.group_grants ADD CONSTRAINT group_grants_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_memberships_public.group_grants ADD COLUMN  permissions bit(32);

ALTER TABLE dashboard_memberships_public.group_grants ALTER COLUMN permissions SET NOT NULL;

ALTER TABLE dashboard_memberships_public.group_grants ALTER COLUMN permissions SET DEFAULT lpad('', 32, '0')::bit(32);

ALTER TABLE dashboard_memberships_public.group_grants ADD COLUMN  is_grant boolean;

ALTER TABLE dashboard_memberships_public.group_grants ALTER COLUMN is_grant SET NOT NULL;

ALTER TABLE dashboard_memberships_public.group_grants ALTER COLUMN is_grant SET DEFAULT TRUE;

ALTER TABLE dashboard_memberships_public.group_grants ADD COLUMN  actor_id uuid;

ALTER TABLE dashboard_memberships_public.group_grants ALTER COLUMN actor_id SET NOT NULL;

ALTER TABLE dashboard_memberships_public.group_grants ADD CONSTRAINT group_grants_actor_id_fkey FOREIGN KEY ( actor_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

ALTER TABLE dashboard_memberships_public.group_grants ADD COLUMN  entity_id uuid;

ALTER TABLE dashboard_memberships_public.group_grants ALTER COLUMN entity_id SET NOT NULL;

ALTER TABLE dashboard_memberships_public.group_grants ADD CONSTRAINT group_grants_entity_id_fkey FOREIGN KEY ( entity_id ) REFERENCES dashboard_public.groups ( id ) ON DELETE CASCADE;

CREATE INDEX group_grants_entity_id_idx ON dashboard_memberships_public.group_grants ( entity_id );

ALTER TABLE dashboard_memberships_public.group_grants ADD COLUMN  grantor_id uuid;

ALTER TABLE dashboard_memberships_public.group_grants ALTER COLUMN grantor_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_memberships_public.group_grants ADD CONSTRAINT group_grants_grantor_id_fkey FOREIGN KEY ( grantor_id ) REFERENCES dashboard_public.users ( id ) ON DELETE SET NULL;

CREATE INDEX group_grants_grantor_id_idx ON dashboard_memberships_public.group_grants ( grantor_id );

ALTER TABLE dashboard_memberships_public.group_grants ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_memberships_public.group_grants ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_memberships_public.group_grants ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_memberships_public.group_grants ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_memberships_public.group_grants 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_memberships_public.group_grants ( created_at );

CREATE INDEX ON dashboard_memberships_public.group_grants ( updated_at );

CREATE FUNCTION dashboard_memberships_private.group_memberships_itg (  ) RETURNS trigger AS $EOFCODE$
DECLARE
    bitlen int = bit_length(NEW.permissions);
    defaults bit varying;
    memdefs "dashboard_memberships_public".group_membership_defaults;
BEGIN
    SELECT * FROM
        "dashboard_memberships_public".group_membership_defaults t 
        WHERE t.entity_id = NEW.entity_id
    INTO memdefs;
    IF (FOUND) THEN 
        NEW.is_approved = memdefs.is_approved;
    END IF;
    IF (NEW.is_owner IS TRUE) THEN 
        NEW.is_admin = TRUE;
        NEW.is_approved = TRUE;
        NEW.is_disabled = FALSE;
        NEW.is_banned = FALSE;
    END IF;
    SELECT (
        NEW.is_approved IS TRUE
    AND
        NEW.is_disabled IS FALSE
    AND
        NEW.is_banned IS FALSE 
    ) INTO NEW.is_active;
    SELECT permissions FROM
        "dashboard_permissions_public".group_member_permission_defaults t 
        WHERE t.entity_id = NEW.entity_id
    INTO defaults;
    IF (NOT FOUND) THEN 
        NEW.granted = lpad('', bitlen::int, '0');
    ELSE
        NEW.granted = defaults;
    END IF;
    IF (NEW.is_admin IS TRUE OR NEW.is_owner IS TRUE) THEN 
        NEW.permissions = lpad('', bitlen::int, '1');
    ELSE
        NEW.permissions = NEW.granted;
    END IF;
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

CREATE FUNCTION dashboard_memberships_private.group_memberships_utg (  ) RETURNS trigger AS $EOFCODE$
DECLARE
    bitlen int = bit_length(NEW.permissions);
BEGIN
    IF (NEW.is_owner IS TRUE) THEN 
        NEW.is_admin = TRUE;
        NEW.is_approved = TRUE;
        NEW.is_disabled = FALSE;
        NEW.is_banned = FALSE;
    END IF;
    SELECT (
        NEW.is_approved IS TRUE
    AND
        NEW.is_disabled IS FALSE
    AND
        NEW.is_banned IS FALSE 
    ) INTO NEW.is_active;
    IF (NEW.is_admin IS TRUE OR NEW.is_owner IS TRUE) THEN 
        NEW.permissions = lpad('', bitlen::int, '1');
    ELSE
        NEW.permissions = NEW.granted;
    END IF;
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

CREATE TRIGGER _00010_group_memberships_itrg 
 BEFORE INSERT ON dashboard_memberships_public.group_memberships 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_memberships_private. group_memberships_itg (  );

CREATE TRIGGER _00010_group_memberships_utrg 
 BEFORE UPDATE ON dashboard_memberships_public.group_memberships 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_memberships_private. group_memberships_utg (  );

CREATE TRIGGER _00020_group_memberships_insert_acl 
 AFTER INSERT ON dashboard_memberships_public.group_memberships 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_memberships_private. group_memberships_insert_acl_tg (  );

CREATE TRIGGER _00020_group_memberships_update_acl 
 AFTER UPDATE ON dashboard_memberships_public.group_memberships 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_memberships_private. group_memberships_update_acl_tg (  );

CREATE TRIGGER _99999_group_memberships_delete_acl 
 AFTER DELETE ON dashboard_memberships_public.group_memberships 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_memberships_private. group_memberships_delete_acl_tg (  );

CREATE FUNCTION dashboard_memberships_private.group_memberships_dtg (  ) RETURNS trigger AS $EOFCODE$
BEGIN
    IF (
        SELECT count(*) = 0 FROM "dashboard_memberships_public".group_memberships 
        WHERE is_owner = TRUE
        AND entity_id = OLD.entity_id
        AND actor_id <> OLD.actor_id
    ) THEN 
        IF (
            SELECT count(*) > 0 FROM "dashboard_memberships_public".group_memberships 
            WHERE entity_id = OLD.entity_id
            AND actor_id <> OLD.actor_id
        ) THEN 
            RAISE EXCEPTION 'REQUIRES_ONE_OWNER';
        END IF;
    END IF;
    RETURN OLD;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

CREATE TRIGGER _99990_group_memberships_owners_chk 
 BEFORE DELETE ON dashboard_memberships_public.group_memberships 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_memberships_private. group_memberships_dtg (  );

CREATE FUNCTION dashboard_memberships_private.create_group_add_mbrs (  ) RETURNS trigger AS $EOFCODE$
DECLARE
    first_owner uuid = jwt_public.current_user_id();
    uid uuid;
    create_groups_cascade_members boolean;
BEGIN
    SELECT 
        owd.create_groups_cascade_members
    FROM "dashboard_memberships_public".membership_defaults owd 
        WHERE owd.entity_id = NEW.id
    INTO create_groups_cascade_members;
    IF (NOT FOUND) THEN 
        create_groups_cascade_members = FALSE;
    END IF;
    INSERT INTO "dashboard_memberships_public".group_membership_defaults
    ( is_approved, entity_id  )
    VALUES ( TRUE, NEW.id );
    INSERT INTO "dashboard_permissions_public".group_member_permission_defaults 
        (permissions, entity_id)
    VALUES 
    (
        "dashboard_permissions_public".group_member_permissions_get_mask_by_names(
            ARRAY['invites_approved', 'create_invites']::citext[]
        ),
        NEW.id
    );
    FOR uid in
        SELECT m.actor_id FROM 
            "dashboard_memberships_public".memberships m
        WHERE m.entity_id = NEW.owner_id
        AND m.is_admin IS TRUE
    LOOP 
        IF (first_owner = uid) THEN 
            CONTINUE;
        END IF;
        INSERT INTO 
            "dashboard_memberships_public".group_memberships
        (actor_id, entity_id, is_admin) VALUES 
        (uid, NEW.id, TRUE);
    END LOOP;
    IF (create_groups_cascade_members IS TRUE) THEN 
        FOR uid in
            SELECT m.actor_id FROM 
                "dashboard_memberships_public".memberships m
            WHERE m.entity_id = NEW.owner_id
            AND m.is_admin IS FALSE
        LOOP 
            IF (first_owner = uid) THEN 
                CONTINUE;
            END IF;
            INSERT INTO 
                "dashboard_memberships_public".group_memberships
            (actor_id, entity_id) VALUES 
            (uid, NEW.id);
        END LOOP;
    END IF;
    IF (first_owner IS NOT NULL) THEN 
        INSERT INTO 
            "dashboard_memberships_public".group_memberships
            (actor_id, entity_id, is_owner) VALUES 
            (first_owner, NEW.id, TRUE);
    END IF;
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

CREATE TRIGGER _99999_groups_mbr_trg 
 AFTER INSERT ON dashboard_public.groups 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_memberships_private. create_group_add_mbrs (  );

CREATE FUNCTION dashboard_memberships_private.create_groups_add_mbrs (  ) RETURNS trigger AS $EOFCODE$
DECLARE
    gid uuid;
    create_groups_cascade_members boolean;
BEGIN
    SELECT 
        owd.create_groups_cascade_members
    FROM "dashboard_memberships_public".membership_defaults owd 
        WHERE owd.entity_id = NEW.entity_id
    INTO create_groups_cascade_members;
    IF (NOT FOUND) THEN 
        create_groups_cascade_members = FALSE;
    END IF;
    FOR gid in
        SELECT g.id FROM 
            "dashboard_public".groups g
        WHERE g.owner_id = NEW.entity_id
    LOOP 
        IF (NEW.is_owner IS TRUE) THEN 
       
            INSERT INTO 
                "dashboard_memberships_public".group_memberships
                (actor_id, entity_id, is_owner) VALUES 
                (NEW.actor_id, gid, TRUE)
                ON CONFLICT (actor_id, entity_id) DO
                UPDATE SET is_owner = EXCLUDED.is_owner;
        ELSIF (NEW.is_admin IS TRUE) THEN 
            INSERT INTO 
                "dashboard_memberships_public".group_memberships
                (actor_id, entity_id, is_admin) VALUES 
                (NEW.actor_id, gid, TRUE)
                ON CONFLICT (actor_id, entity_id) DO
                UPDATE SET is_admin = EXCLUDED.is_admin;
        ELSE 
            IF (create_groups_cascade_members IS TRUE) THEN 
                INSERT INTO 
                    "dashboard_memberships_public".group_memberships
                    (actor_id, entity_id, is_owner, is_admin) VALUES 
                    (NEW.actor_id, gid, FALSE, FALSE)
                    ON CONFLICT (actor_id, entity_id)
                    DO UPDATE
                    SET is_admin = EXCLUDED.is_admin, is_owner = EXCLUDED.is_owner;
            ELSE 
                UPDATE "dashboard_memberships_public".group_memberships m
                    SET is_admin = FALSE, is_owner = FALSE
                WHERE m.actor_id = NEW.actor_id AND 
                m.entity_id = gid;
            END IF;
        END IF;
    END LOOP;
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

CREATE TRIGGER _99999_groups_mbr_itrg 
 BEFORE INSERT ON dashboard_memberships_public.memberships 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_memberships_private. create_groups_add_mbrs (  );

CREATE TRIGGER _99999_groups_mbr_utrg 
 BEFORE UPDATE ON dashboard_memberships_public.memberships 
 FOR EACH ROW
 WHEN ( old.is_admin IS DISTINCT FROM new.is_admin OR old.is_owner IS DISTINCT FROM new.is_owner ) 
 EXECUTE PROCEDURE dashboard_memberships_private. create_groups_add_mbrs (  );

CREATE FUNCTION dashboard_memberships_private.delete_groups_remove_mbrs (  ) RETURNS trigger AS $EOFCODE$
DECLARE
    gid uuid;
    delete_member_cascade_groups boolean;
BEGIN
    SELECT 
        owd.delete_member_cascade_groups
    FROM "dashboard_memberships_public".membership_defaults owd 
        WHERE owd.entity_id = OLD.entity_id
    INTO delete_member_cascade_groups;
    IF (NOT FOUND) THEN 
        delete_member_cascade_groups = FALSE;
    END IF;
    FOR gid in
        SELECT g.id FROM 
            "dashboard_public".groups g
        WHERE g.owner_id = OLD.entity_id
    LOOP 
        IF (delete_member_cascade_groups IS TRUE) THEN 
            DELETE FROM "dashboard_memberships_public".group_memberships m
            WHERE m.actor_id = OLD.actor_id AND 
            m.entity_id = gid;
        ELSE
            UPDATE "dashboard_memberships_public".group_memberships m
                SET is_admin = FALSE, is_owner = FALSE
            WHERE m.actor_id = OLD.actor_id AND 
            m.entity_id = gid;
        END IF;
    END LOOP;
    RETURN OLD;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

CREATE TRIGGER _99999_groups_mbr_dtrg 
 BEFORE DELETE ON dashboard_memberships_public.memberships 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_memberships_private. delete_groups_remove_mbrs (  );

CREATE FUNCTION dashboard_memberships_private.group_grants_apply_tg (  ) RETURNS trigger AS $EOFCODE$
BEGIN
    IF (NEW.is_grant IS TRUE) THEN 
        UPDATE "dashboard_memberships_public".group_memberships 
            SET granted = granted | NEW.permissions
        WHERE actor_id = NEW.actor_id
        AND entity_id = NEW.entity_id; 
    ELSE 
        UPDATE "dashboard_memberships_public".group_memberships 
            SET granted = granted & ~ NEW.permissions
        WHERE actor_id = NEW.actor_id
        AND entity_id = NEW.entity_id; 
    END IF;
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER group_grants_insert_trg 
 BEFORE INSERT ON dashboard_memberships_public.group_grants 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_memberships_private. group_grants_apply_tg (  );

CREATE FUNCTION dashboard_memberships_private.group_admin_grants_apply_tg (  ) RETURNS trigger AS $EOFCODE$
BEGIN
    IF (NEW.is_grant IS TRUE) THEN 
        UPDATE "dashboard_memberships_public".group_memberships 
            SET is_admin = TRUE
        WHERE actor_id = NEW.actor_id
        AND entity_id = NEW.entity_id; 
    ELSE 
        UPDATE "dashboard_memberships_public".group_memberships 
            SET is_admin = FALSE
        WHERE actor_id = NEW.actor_id
        AND entity_id = NEW.entity_id
        AND is_owner = FALSE; 
    END IF;
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

CREATE TRIGGER group_admin_grants_insert_trg 
 BEFORE INSERT ON dashboard_memberships_public.group_admin_grants 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_memberships_private. group_admin_grants_apply_tg (  );

CREATE FUNCTION dashboard_memberships_private.group_owner_grants_apply_tg (  ) RETURNS trigger AS $EOFCODE$
BEGIN
    IF (NEW.is_grant IS TRUE) THEN 
        UPDATE "dashboard_memberships_public".group_memberships 
            SET is_owner = TRUE
        WHERE actor_id = NEW.actor_id
        AND entity_id = NEW.entity_id; 
    ELSE 
        UPDATE "dashboard_memberships_public".group_memberships 
            SET is_owner = FALSE
        WHERE actor_id = NEW.actor_id
        AND entity_id = NEW.entity_id; 
        IF (
            SELECT count(*) < 1 FROM "dashboard_memberships_public".group_memberships 
            WHERE is_owner = TRUE
            AND entity_id = NEW.entity_id
        ) THEN 
            RAISE EXCEPTION 'REQUIRES_ONE_OWNER';
        END IF;
    END IF;
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

CREATE TRIGGER group_owner_grants_insert_trg 
 BEFORE INSERT ON dashboard_memberships_public.group_owner_grants 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_memberships_private. group_owner_grants_apply_tg (  );

INSERT INTO dashboard_permissions_public.group_member_permissions ( bitnum, name, description ) VALUES (1, 'admin_members', 'Manage members of the group.'), (2, 'create_invites', 'Create invites for the group.'), (3, 'admin_invites', 'Manage invites of the group.'), (4, 'invites_approved', 'Invites sent are approved for the group.'), (5, 'admin_limits', 'Manage limits within the group.'), (6, 'admin_permissions', 'Manage permissions within the group.'), (7, 'admin_levels', 'Manage levels of the group.'), (8, 'admin_objects', 'Manage objects of the group.'), (9, 'admin_privileged_data', 'Manage privileged data within the group.'), (10, 'admin_group', 'Manage group info.');

INSERT INTO dashboard_permissions_public.app_permissions ( bitnum, name, description ) VALUES (12, 'create_actions', 'Create actions within the app.'), (13, 'approve_actions', 'Approve actions within the app.'), (14, 'verify_actions', 'Verify actions within the app.'), (15, 'admin_rewards', 'Manage rewards within the app.'), (16, 'create_posts', 'Create posts within the app.'), (17, 'admin_posts', 'Manage posts within the app.'), (18, 'admin_questions', 'Manage questions within the app.');

INSERT INTO dashboard_permissions_public.membership_permissions ( bitnum, name, description ) VALUES (14, 'create_actions', 'Create actions within the organization'), (15, 'approve_actions', 'Approve actions within the organization'), (16, 'admin_actions', 'Create actions within the organization'), (17, 'verify_actions', 'Verify actions within the organization'), (18, 'admin_rewards', 'Manage rewards within the organization'), (19, 'create_posts', 'Create posts for the organization'), (20, 'admin_posts', 'Manage posts for the organization'), (21, 'admin_questions', 'Manage questions for the organization');

INSERT INTO dashboard_permissions_public.group_member_permissions ( bitnum, name, description ) VALUES (11, 'create_posts', 'Create posts within the group'), (12, 'admin_posts', 'Manage posts within the group');

INSERT INTO dashboard_limits_public.app_limit_defaults ( name, max ) VALUES ('organizations', 10), ('invites', 50), ('groups', 10), ('objects', 100);

INSERT INTO dashboard_limits_public.membership_limit_defaults ( name, max ) VALUES ('groups', 100);

INSERT INTO dashboard_status_public.app_levels ( name, description ) VALUES ('novice', 'For this achievement you need to agree to the terms of service, sign up for an account.'), ('app_user', 'For this achievement you need to verify your account and upload a profile image.');

INSERT INTO dashboard_status_public.app_level_requirements ( level, name, description ) VALUES ('novice', 'agree_to_terms', 'Agree to the terms of service.'), ('novice', 'username', 'Create username.'), ('app_user', 'verify_account', 'Verify your account.'), ('app_user', 'upload_profile_image', 'Upload a profile image.');

CREATE SCHEMA dashboard_simple_secrets;

GRANT USAGE ON SCHEMA dashboard_simple_secrets TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_simple_secrets 
 GRANT ALL ON TABLES  TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_simple_secrets 
 GRANT ALL ON SEQUENCES  TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_simple_secrets 
 GRANT ALL ON FUNCTIONS  TO administrator;

GRANT USAGE ON SCHEMA dashboard_simple_secrets TO authenticated;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_simple_secrets 
 GRANT ALL ON FUNCTIONS  TO authenticated;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_simple_secrets 
 GRANT USAGE, SELECT ON SEQUENCES  TO authenticated;

GRANT USAGE ON SCHEMA dashboard_simple_secrets TO anonymous;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_simple_secrets 
 GRANT ALL ON FUNCTIONS  TO anonymous;

CREATE TABLE dashboard_simple_secrets.user_secrets (
  
);

ALTER TABLE dashboard_simple_secrets.user_secrets DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_simple_secrets.user_secrets ADD COLUMN  id uuid;

ALTER TABLE dashboard_simple_secrets.user_secrets ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_simple_secrets.user_secrets ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_simple_secrets.user_secrets ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_simple_secrets.user_secrets ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_simple_secrets.user_secrets ADD COLUMN  name text;

ALTER TABLE dashboard_simple_secrets.user_secrets ALTER COLUMN name SET NOT NULL;

ALTER TABLE dashboard_simple_secrets.user_secrets ADD COLUMN  value text;

ALTER TABLE dashboard_simple_secrets.user_secrets ADD CONSTRAINT user_secrets_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_simple_secrets.user_secrets ADD CONSTRAINT user_secrets_owner_id_name_key UNIQUE ( owner_id, name );

ALTER TABLE dashboard_simple_secrets.user_secrets ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_simple_secrets.user_secrets TO authenticated;

GRANT UPDATE ON TABLE dashboard_simple_secrets.user_secrets TO authenticated;

GRANT DELETE ON TABLE dashboard_simple_secrets.user_secrets TO authenticated;

CREATE POLICY auth_ins ON dashboard_simple_secrets.user_secrets FOR INSERT TO authenticated WITH CHECK ( owner_id = jwt_public.current_user_id() );

CREATE POLICY auth_upd ON dashboard_simple_secrets.user_secrets FOR UPDATE TO authenticated USING ( owner_id = jwt_public.current_user_id() );

CREATE POLICY auth_del ON dashboard_simple_secrets.user_secrets FOR DELETE TO authenticated USING ( owner_id = jwt_public.current_user_id() );

CREATE FUNCTION dashboard_simple_secrets.get ( v_owner_id uuid, v_secret_name text, v_default_value text DEFAULT NULL ) RETURNS text AS $EOFCODE$
DECLARE
    val text;
BEGIN
    SELECT value FROM "dashboard_simple_secrets".user_secrets t 
        WHERE t.owner_id = get.v_owner_id
        AND t.name = get.v_secret_name
    INTO val;
    IF (NOT FOUND OR val IS NULL) THEN
        RETURN v_default_value;
    END IF;
    RETURN val;
END;
$EOFCODE$ LANGUAGE plpgsql STABLE;

GRANT EXECUTE ON FUNCTION dashboard_simple_secrets.get TO authenticated;

CREATE FUNCTION dashboard_simple_secrets.set ( v_owner_id uuid, v_secret_name text, v_value anyelement ) RETURNS void AS $EOFCODE$
    INSERT INTO "dashboard_simple_secrets".user_secrets 
        (owner_id, name, value)
    VALUES
        (set.v_owner_id, set.v_secret_name, set.v_value::text)
    ON CONFLICT (owner_id, name)
    DO UPDATE 
    SET value = EXCLUDED.value;
$EOFCODE$ LANGUAGE sql VOLATILE;

GRANT EXECUTE ON FUNCTION dashboard_simple_secrets.set TO authenticated;

CREATE FUNCTION dashboard_simple_secrets.del ( owner_id uuid, secret_name text ) RETURNS void AS $EOFCODE$
    DELETE FROM "dashboard_simple_secrets".user_secrets s 
        WHERE
        s.owner_id = del.owner_id
        AND s.name = secret_name;
$EOFCODE$ LANGUAGE sql VOLATILE;

CREATE FUNCTION dashboard_simple_secrets.del ( owner_id uuid, secret_names text[] ) RETURNS void AS $EOFCODE$
    DELETE FROM "dashboard_simple_secrets".user_secrets s 
        WHERE
        s.owner_id = del.owner_id
        AND s.name = ANY (secret_names);
$EOFCODE$ LANGUAGE sql VOLATILE;

GRANT EXECUTE ON FUNCTION dashboard_simple_secrets.del ( uuid,text ) TO authenticated;

GRANT EXECUTE ON FUNCTION dashboard_simple_secrets.del ( uuid,text[] ) TO authenticated;

CREATE SCHEMA dashboard_roles_private;

GRANT USAGE ON SCHEMA dashboard_roles_private TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_roles_private 
 GRANT ALL ON TABLES  TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_roles_private 
 GRANT ALL ON SEQUENCES  TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_roles_private 
 GRANT ALL ON FUNCTIONS  TO administrator;

GRANT USAGE ON SCHEMA dashboard_roles_private TO authenticated;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_roles_private 
 GRANT ALL ON FUNCTIONS  TO authenticated;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_roles_private 
 GRANT USAGE, SELECT ON SEQUENCES  TO authenticated;

GRANT USAGE ON SCHEMA dashboard_roles_private TO anonymous;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_roles_private 
 GRANT ALL ON FUNCTIONS  TO anonymous;

CREATE TABLE dashboard_roles_private.api_tokens (
  
);

ALTER TABLE dashboard_roles_private.api_tokens DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_roles_private.api_tokens ADD COLUMN  id uuid;

ALTER TABLE dashboard_roles_private.api_tokens ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_roles_private.api_tokens ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_roles_private.api_tokens ADD CONSTRAINT api_tokens_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_roles_private.api_tokens ADD COLUMN  user_id uuid;

ALTER TABLE dashboard_roles_private.api_tokens ALTER COLUMN user_id SET NOT NULL;

ALTER TABLE dashboard_roles_private.api_tokens ADD COLUMN  ot_token text;

ALTER TABLE dashboard_roles_private.api_tokens ADD COLUMN  origin origin;

ALTER TABLE dashboard_roles_private.api_tokens ALTER COLUMN origin SET DEFAULT jwt_public.current_origin();

ALTER TABLE dashboard_roles_private.api_tokens ADD COLUMN  ip inet;

ALTER TABLE dashboard_roles_private.api_tokens ALTER COLUMN ip SET DEFAULT jwt_public.current_ip_address();

ALTER TABLE dashboard_roles_private.api_tokens ADD COLUMN  uagent text;

ALTER TABLE dashboard_roles_private.api_tokens ALTER COLUMN uagent SET DEFAULT jwt_public.current_user_agent();

ALTER TABLE dashboard_roles_private.api_tokens ADD COLUMN  access_token text;

ALTER TABLE dashboard_roles_private.api_tokens ALTER COLUMN access_token SET NOT NULL;

ALTER TABLE dashboard_roles_private.api_tokens ALTER COLUMN access_token SET DEFAULT encode(gen_random_bytes(48), 'hex');

ALTER TABLE dashboard_roles_private.api_tokens ADD COLUMN  access_token_expires_at timestamptz;

ALTER TABLE dashboard_roles_private.api_tokens ALTER COLUMN access_token_expires_at SET NOT NULL;

ALTER TABLE dashboard_roles_private.api_tokens ALTER COLUMN access_token_expires_at SET DEFAULT now() + '30 days'::interval;

ALTER TABLE dashboard_roles_private.api_tokens ADD COLUMN  is_verified boolean;

ALTER TABLE dashboard_roles_private.api_tokens ALTER COLUMN is_verified SET NOT NULL;

ALTER TABLE dashboard_roles_private.api_tokens ALTER COLUMN is_verified SET DEFAULT FALSE;

ALTER TABLE dashboard_roles_private.api_tokens ADD COLUMN  last_totp_verified timestamptz;

ALTER TABLE dashboard_roles_private.api_tokens ADD COLUMN  totp_enabled boolean;

ALTER TABLE dashboard_roles_private.api_tokens ALTER COLUMN totp_enabled SET NOT NULL;

ALTER TABLE dashboard_roles_private.api_tokens ALTER COLUMN totp_enabled SET DEFAULT FALSE;

ALTER TABLE dashboard_roles_private.api_tokens ADD COLUMN  last_password_verified timestamptz;

ALTER TABLE dashboard_roles_private.api_tokens ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_roles_private.api_tokens ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_roles_private.api_tokens ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_roles_private.api_tokens ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_roles_private.api_tokens 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_roles_private.api_tokens ( created_at );

CREATE INDEX ON dashboard_roles_private.api_tokens ( updated_at );

ALTER TABLE dashboard_roles_private.api_tokens ADD CONSTRAINT api_tokens_access_token_key UNIQUE ( access_token );

ALTER TABLE dashboard_roles_private.api_tokens ADD CONSTRAINT api_tokens_ot_token_key UNIQUE ( ot_token );

CREATE INDEX api_tokens_user_id_idx ON dashboard_roles_private.api_tokens ( user_id );

CREATE FUNCTION dashboard_roles_private.app_memberships_verified_tg (  ) RETURNS trigger AS $EOFCODE$
DECLARE
BEGIN
    UPDATE "dashboard_roles_private".api_tokens t
        SET is_verified = NEW.is_verified 
    WHERE t.user_id = NEW.actor_id;
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE FUNCTION dashboard_roles_private.app_memberships_banned_tg (  ) RETURNS trigger AS $EOFCODE$
DECLARE
BEGIN
    DELETE FROM "dashboard_roles_private".api_tokens 
        WHERE user_id = NEW.actor_id;
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _99999_app_memberships_verified_trg 
 AFTER UPDATE ON dashboard_memberships_public.app_memberships 
 FOR EACH ROW
 WHEN ( OLD.is_verified IS DISTINCT FROM NEW.is_verified ) 
 EXECUTE PROCEDURE dashboard_roles_private. app_memberships_verified_tg (  );

CREATE TRIGGER _99999_app_memberships_banned_trg 
 AFTER UPDATE ON dashboard_memberships_public.app_memberships 
 FOR EACH ROW
 WHEN ( (old.is_disabled IS DISTINCT FROM new.is_disabled OR old.is_banned IS DISTINCT FROM new.is_banned) AND (new.is_disabled IS TRUE OR new.is_banned IS TRUE) ) 
 EXECUTE PROCEDURE dashboard_roles_private. app_memberships_banned_tg (  );

CREATE SCHEMA dashboard_encrypted;

GRANT USAGE ON SCHEMA dashboard_encrypted TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_encrypted 
 GRANT ALL ON TABLES  TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_encrypted 
 GRANT ALL ON SEQUENCES  TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_encrypted 
 GRANT ALL ON FUNCTIONS  TO administrator;

GRANT USAGE ON SCHEMA dashboard_encrypted TO authenticated;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_encrypted 
 GRANT ALL ON FUNCTIONS  TO authenticated;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_encrypted 
 GRANT USAGE, SELECT ON SEQUENCES  TO authenticated;

GRANT USAGE ON SCHEMA dashboard_encrypted TO anonymous;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_encrypted 
 GRANT ALL ON FUNCTIONS  TO anonymous;

CREATE TABLE dashboard_encrypted.user_encrypted_secrets (
  
);

ALTER TABLE dashboard_encrypted.user_encrypted_secrets DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_encrypted.user_encrypted_secrets ADD COLUMN  id uuid;

ALTER TABLE dashboard_encrypted.user_encrypted_secrets ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_encrypted.user_encrypted_secrets ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_encrypted.user_encrypted_secrets ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_encrypted.user_encrypted_secrets ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_encrypted.user_encrypted_secrets ADD COLUMN  name text;

ALTER TABLE dashboard_encrypted.user_encrypted_secrets ALTER COLUMN name SET NOT NULL;

ALTER TABLE dashboard_encrypted.user_encrypted_secrets ADD COLUMN  value bytea;

ALTER TABLE dashboard_encrypted.user_encrypted_secrets ADD COLUMN  algo text;

ALTER TABLE dashboard_encrypted.user_encrypted_secrets ADD CONSTRAINT user_encrypted_secrets_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_encrypted.user_encrypted_secrets ADD CONSTRAINT user_encrypted_secrets_owner_id_name_key UNIQUE ( owner_id, name );

ALTER TABLE dashboard_encrypted.user_encrypted_secrets ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_encrypted.user_encrypted_secrets TO authenticated;

GRANT UPDATE ON TABLE dashboard_encrypted.user_encrypted_secrets TO authenticated;

GRANT DELETE ON TABLE dashboard_encrypted.user_encrypted_secrets TO authenticated;

CREATE POLICY auth_ins ON dashboard_encrypted.user_encrypted_secrets FOR INSERT TO authenticated WITH CHECK ( owner_id = jwt_public.current_user_id() );

CREATE POLICY auth_upd ON dashboard_encrypted.user_encrypted_secrets FOR UPDATE TO authenticated USING ( owner_id = jwt_public.current_user_id() );

CREATE POLICY auth_del ON dashboard_encrypted.user_encrypted_secrets FOR DELETE TO authenticated USING ( owner_id = jwt_public.current_user_id() );

CREATE FUNCTION dashboard_encrypted.user_encrypted_secrets_hash (  ) RETURNS trigger AS $EOFCODE$
BEGIN
   
IF (NEW.algo = 'crypt') THEN
    NEW.value = crypt(NEW.value::text, gen_salt('bf'));
ELSIF (NEW.algo = 'pgp') THEN
    NEW.value = pgp_sym_encrypt(encode(NEW.value::bytea, 'hex'), NEW.owner_id::text, 'compress-algo=1, cipher-algo=aes256');
ELSE
    NEW.algo = 'none';
END IF;
RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER user_encrypted_secrets_update_tg 
 BEFORE UPDATE ON dashboard_encrypted.user_encrypted_secrets 
 FOR EACH ROW
 WHEN ( NEW.value IS DISTINCT FROM OLD.value ) 
 EXECUTE PROCEDURE dashboard_encrypted. user_encrypted_secrets_hash (  );

CREATE TRIGGER user_encrypted_secrets_insert_tg 
 BEFORE INSERT ON dashboard_encrypted.user_encrypted_secrets 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_encrypted. user_encrypted_secrets_hash (  );

CREATE FUNCTION dashboard_encrypted.get ( owner_id uuid, secret_name text, default_value text DEFAULT NULL ) RETURNS text AS $EOFCODE$
DECLARE
  v_secret "dashboard_encrypted".user_encrypted_secrets;
BEGIN
  SELECT
    *
  FROM
    "dashboard_encrypted".user_encrypted_secrets s
  WHERE
    s.name = get.secret_name
    AND s.owner_id = get.owner_id
  INTO v_secret;
  IF (NOT FOUND OR v_secret IS NULL) THEN
    RETURN get.default_value;
  END IF;
  
  IF (v_secret.algo = 'crypt') THEN
    RETURN convert_from(v_secret.value, 'SQL_ASCII');
  ELSIF (v_secret.algo = 'pgp') THEN
    RETURN convert_from(decode(pgp_sym_decrypt(v_secret.value, v_secret.owner_id::text), 'hex'), 'SQL_ASCII');
  END IF;
  RETURN convert_from(v_secret.value, 'SQL_ASCII');
END
$EOFCODE$ LANGUAGE plpgsql STABLE;

GRANT EXECUTE ON FUNCTION dashboard_encrypted.get TO authenticated;

CREATE FUNCTION dashboard_encrypted.verify ( owner_id uuid, secret_name text, value text ) RETURNS boolean AS $EOFCODE$
DECLARE
  v_secret_text text;
  v_secret "dashboard_encrypted".user_encrypted_secrets;
BEGIN
  SELECT
    *
  FROM
    "dashboard_encrypted".get (verify.owner_id, verify.secret_name)
  INTO v_secret_text;
  SELECT
    *
  FROM
    "dashboard_encrypted".user_encrypted_secrets s
  WHERE
    s.name = verify.secret_name
    AND s.owner_id = verify.owner_id INTO v_secret;
  IF (v_secret.algo = 'crypt') THEN
    RETURN v_secret_text = crypt(verify.value::bytea::text, v_secret_text);
  ELSIF (v_secret.algo = 'pgp') THEN
    RETURN verify.value = v_secret_text;
  END IF;
  RETURN verify.value = v_secret_text;
END
$EOFCODE$ LANGUAGE plpgsql STABLE;

GRANT EXECUTE ON FUNCTION dashboard_encrypted.verify TO authenticated;

CREATE FUNCTION dashboard_encrypted.set ( v_owner_id uuid, secret_name text, secret_value text, v_algo text DEFAULT 'pgp' ) RETURNS boolean AS $EOFCODE$
BEGIN
  INSERT INTO "dashboard_encrypted".user_encrypted_secrets (owner_id, name, value, algo)
    VALUES (v_owner_id, set.secret_name, set.secret_value::bytea, set.v_algo)
    ON CONFLICT (owner_id, name)
    DO
    UPDATE
    SET
      value = set.secret_value::bytea,
      algo = EXCLUDED.algo;
  RETURN TRUE;
END
$EOFCODE$ LANGUAGE plpgsql VOLATILE;

GRANT EXECUTE ON FUNCTION dashboard_encrypted.set TO authenticated;

CREATE FUNCTION dashboard_encrypted.del ( owner_id uuid, secret_name text ) RETURNS void AS $EOFCODE$
BEGIN
  DELETE FROM "dashboard_encrypted".user_encrypted_secrets s
  WHERE s.owner_id = del.owner_id
    AND s.name = del.secret_name;
END
$EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE FUNCTION dashboard_encrypted.del ( owner_id uuid, secret_names text[] ) RETURNS void AS $EOFCODE$
BEGIN
  DELETE FROM "dashboard_encrypted".user_encrypted_secrets s
  WHERE s.owner_id = del.owner_id
    AND s.name = ANY(del.secret_names);
END
$EOFCODE$ LANGUAGE plpgsql VOLATILE;

GRANT EXECUTE ON FUNCTION dashboard_encrypted.del ( uuid,text ) TO authenticated;

GRANT EXECUTE ON FUNCTION dashboard_encrypted.del ( uuid,text[] ) TO authenticated;

CREATE SCHEMA dashboard_roles_public;

GRANT USAGE ON SCHEMA dashboard_roles_public TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_roles_public 
 GRANT ALL ON TABLES  TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_roles_public 
 GRANT ALL ON SEQUENCES  TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_roles_public 
 GRANT ALL ON FUNCTIONS  TO administrator;

GRANT USAGE ON SCHEMA dashboard_roles_public TO authenticated;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_roles_public 
 GRANT ALL ON FUNCTIONS  TO authenticated;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_roles_public 
 GRANT USAGE, SELECT ON SEQUENCES  TO authenticated;

GRANT USAGE ON SCHEMA dashboard_roles_public TO anonymous;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_roles_public 
 GRANT ALL ON FUNCTIONS  TO anonymous;

CREATE FUNCTION dashboard_roles_private.authenticate ( token_str text ) RETURNS SETOF dashboard_roles_private.api_tokens AS $EOFCODE$
SELECT
    tkn.*
FROM
    "dashboard_roles_private".api_tokens AS tkn
WHERE
    tkn.access_token = authenticate.token_str
    AND EXTRACT(EPOCH FROM (tkn.access_token_expires_at-NOW())) > 0;
$EOFCODE$ LANGUAGE sql STABLE SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION dashboard_roles_private.authenticate TO anonymous;

GRANT EXECUTE ON FUNCTION dashboard_roles_private.authenticate TO authenticated;

CREATE FUNCTION dashboard_roles_private.authenticate_strict ( token_str text ) RETURNS SETOF dashboard_roles_private.api_tokens AS $EOFCODE$
SELECT
    tkn.*
FROM
    "dashboard_roles_private".api_tokens AS tkn
WHERE
    tkn.access_token = authenticate_strict.token_str
    AND EXTRACT(EPOCH FROM (tkn.access_token_expires_at-NOW())) > 0
    AND 
    (
        CASE WHEN tkn.uagent IS NULL THEN jwt_public.current_user_agent() IS NULL
        ELSE tkn.uagent = jwt_public.current_user_agent() END
    )
    AND 
    (
        CASE WHEN tkn.origin IS NULL THEN jwt_public.current_origin() IS NULL
        ELSE tkn.origin = jwt_public.current_origin() END
    );
$EOFCODE$ LANGUAGE sql STABLE SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION dashboard_roles_private.authenticate_strict TO anonymous;

GRANT EXECUTE ON FUNCTION dashboard_roles_private.authenticate_strict TO authenticated;

CREATE FUNCTION dashboard_roles_public.current_user_agent (  ) RETURNS text AS $EOFCODE$
DECLARE
  v_uagent text;
BEGIN
  IF current_setting('jwt.claims.user_agent', TRUE)
    IS NOT NULL THEN
    BEGIN
      v_uagent = current_setting('jwt.claims.user_agent', TRUE);
    EXCEPTION
      WHEN OTHERS THEN
      RAISE NOTICE 'Invalid UserAgent';
    RETURN NULL;
    END;
    RETURN v_uagent;
  ELSE
    RETURN NULL;
  END IF;
END;
$EOFCODE$ LANGUAGE plpgsql STABLE;

GRANT EXECUTE ON FUNCTION dashboard_roles_public.current_user_agent TO authenticated;

CREATE FUNCTION dashboard_roles_public.current_ip_address (  ) RETURNS inet AS $EOFCODE$
DECLARE
  v_ip_addr inet;
BEGIN
  IF current_setting('jwt.claims.ip_address', TRUE)
    IS NOT NULL THEN
    BEGIN
      v_ip_addr = current_setting('jwt.claims.ip_address', TRUE)::inet;
    EXCEPTION
      WHEN OTHERS THEN
      RAISE NOTICE 'Invalid IP';
    RETURN NULL;
    END;
    RETURN v_ip_addr;
  ELSE
    RETURN NULL;
  END IF;
END;
$EOFCODE$ LANGUAGE plpgsql STABLE;

GRANT EXECUTE ON FUNCTION dashboard_roles_public.current_ip_address TO authenticated;

CREATE FUNCTION dashboard_roles_public.get_current_user_id (  ) RETURNS uuid AS $EOFCODE$
DECLARE
  v_identifier_id uuid;
BEGIN
  IF current_setting('jwt.claims.user_id', TRUE)
    IS NOT NULL THEN
    BEGIN
      v_identifier_id = current_setting('jwt.claims.user_id', TRUE)::uuid;
    EXCEPTION
      WHEN OTHERS THEN
      RAISE NOTICE 'Invalid UUID value';
    RETURN NULL;
    END;
    RETURN v_identifier_id;
  ELSE
    RETURN NULL;
  END IF;
END;
$EOFCODE$ LANGUAGE plpgsql STABLE;

GRANT EXECUTE ON FUNCTION dashboard_roles_public.get_current_user_id TO authenticated;

CREATE FUNCTION dashboard_roles_public.get_current_user (  ) RETURNS dashboard_public.users AS $EOFCODE$
DECLARE
  v_user "dashboard_public".users;
BEGIN
  IF "dashboard_roles_public".get_current_user_id() IS NOT NULL THEN
     SELECT * FROM "dashboard_public".users WHERE id = "dashboard_roles_public".get_current_user_id() INTO v_user;
     RETURN v_user;
  ELSE
     RETURN NULL;
  END IF;
END;
$EOFCODE$ LANGUAGE plpgsql STABLE;

GRANT EXECUTE ON FUNCTION dashboard_roles_public.get_current_user TO authenticated;

CREATE POLICY auth_ins_insert_chk ON dashboard_public.users FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000010000') = '00000000000000000000000000010000')) AND type = 1 );

CREATE POLICY auth_upd ON dashboard_public.users FOR UPDATE TO authenticated USING ( id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000100000000000') = '00000000000000000000100000000000') );

CREATE POLICY auth_del ON dashboard_public.users FOR DELETE TO authenticated USING ( id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_owner IS TRUE) );

CREATE POLICY auth_upd_admin_updates ON dashboard_public.users FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000000001') = '00000000000000000000000000000001') );

CREATE POLICY auth_del_admin_deletes ON dashboard_public.users FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000000001') = '00000000000000000000000000000001') );

CREATE TABLE dashboard_public.connected_accounts (
  
);

ALTER TABLE dashboard_public.connected_accounts DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.connected_accounts ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.connected_accounts ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.connected_accounts ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.connected_accounts ADD CONSTRAINT connected_accounts_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.connected_accounts ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.connected_accounts ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.connected_accounts ALTER COLUMN owner_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_public.connected_accounts ADD CONSTRAINT connected_accounts_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

ALTER TABLE dashboard_public.connected_accounts ADD COLUMN  service text;

ALTER TABLE dashboard_public.connected_accounts ALTER COLUMN service SET NOT NULL;

COMMENT ON COLUMN dashboard_public.connected_accounts.service IS E'The service used, e.g. `twitter` or `github`.';

ALTER TABLE dashboard_public.connected_accounts ADD COLUMN  identifier text;

ALTER TABLE dashboard_public.connected_accounts ALTER COLUMN identifier SET NOT NULL;

COMMENT ON COLUMN dashboard_public.connected_accounts.identifier IS E'A unique identifier for the user within the service';

ALTER TABLE dashboard_public.connected_accounts ADD COLUMN  details jsonb;

ALTER TABLE dashboard_public.connected_accounts ALTER COLUMN details SET NOT NULL;

COMMENT ON COLUMN dashboard_public.connected_accounts.details IS E'Additional profile details extracted from this login method';

ALTER TABLE dashboard_public.connected_accounts ADD COLUMN  is_verified boolean;

ALTER TABLE dashboard_public.connected_accounts ALTER COLUMN is_verified SET NOT NULL;

ALTER TABLE dashboard_public.connected_accounts ALTER COLUMN is_verified SET DEFAULT FALSE;

ALTER TABLE dashboard_public.connected_accounts ADD CONSTRAINT connected_accounts_service_identifier_key UNIQUE ( service, identifier );

ALTER TABLE dashboard_public.connected_accounts ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.connected_accounts ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.connected_accounts ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.connected_accounts ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.connected_accounts 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.connected_accounts ( created_at );

CREATE INDEX ON dashboard_public.connected_accounts ( updated_at );

ALTER TABLE dashboard_public.connected_accounts ENABLE ROW LEVEL SECURITY;

GRANT UPDATE ( service, identifier, details, owner_id ) ON TABLE dashboard_public.connected_accounts TO authenticated;

GRANT INSERT ( service, identifier, details, owner_id ) ON TABLE dashboard_public.connected_accounts TO authenticated;

GRANT SELECT ON TABLE dashboard_public.connected_accounts TO authenticated;

GRANT DELETE ON TABLE dashboard_public.connected_accounts TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.connected_accounts FOR SELECT TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000100000000000') = '00000000000000000000100000000000') );

CREATE POLICY auth_ins ON dashboard_public.connected_accounts FOR INSERT TO authenticated WITH CHECK ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000100000000000') = '00000000000000000000100000000000') );

CREATE POLICY auth_upd ON dashboard_public.connected_accounts FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000100000000000') = '00000000000000000000100000000000') );

CREATE POLICY auth_del ON dashboard_public.connected_accounts FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000100000000000') = '00000000000000000000100000000000') );

CREATE TABLE dashboard_public.emails (
  
);

ALTER TABLE dashboard_public.emails DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.emails ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.emails ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.emails ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.emails ADD CONSTRAINT emails_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.emails ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.emails ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.emails ALTER COLUMN owner_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_public.emails ADD CONSTRAINT emails_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

ALTER TABLE dashboard_public.emails ADD COLUMN  email email;

ALTER TABLE dashboard_public.emails ALTER COLUMN email SET NOT NULL;

ALTER TABLE dashboard_public.emails ADD COLUMN  is_verified boolean;

ALTER TABLE dashboard_public.emails ALTER COLUMN is_verified SET NOT NULL;

ALTER TABLE dashboard_public.emails ALTER COLUMN is_verified SET DEFAULT FALSE;

ALTER TABLE dashboard_public.emails ADD COLUMN  is_primary boolean;

ALTER TABLE dashboard_public.emails ALTER COLUMN is_primary SET NOT NULL;

ALTER TABLE dashboard_public.emails ALTER COLUMN is_primary SET DEFAULT FALSE;

ALTER TABLE dashboard_public.emails ADD CONSTRAINT emails_email_key UNIQUE ( email );

ALTER TABLE dashboard_public.emails ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.emails ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.emails ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.emails ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.emails 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.emails ( created_at );

CREATE INDEX ON dashboard_public.emails ( updated_at );

ALTER TABLE dashboard_public.emails ENABLE ROW LEVEL SECURITY;

GRANT UPDATE ( email, owner_id, is_primary ) ON TABLE dashboard_public.emails TO authenticated;

GRANT INSERT ( email, owner_id, is_primary ) ON TABLE dashboard_public.emails TO authenticated;

GRANT SELECT ON TABLE dashboard_public.emails TO authenticated;

GRANT DELETE ON TABLE dashboard_public.emails TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.emails FOR SELECT TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000100000000000') = '00000000000000000000100000000000') );

CREATE POLICY auth_ins ON dashboard_public.emails FOR INSERT TO authenticated WITH CHECK ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000100000000000') = '00000000000000000000100000000000') );

CREATE POLICY auth_upd ON dashboard_public.emails FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000100000000000') = '00000000000000000000100000000000') );

CREATE POLICY auth_del ON dashboard_public.emails FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000100000000000') = '00000000000000000000100000000000') );

CREATE FUNCTION dashboard_private.emails_insert_tg (  ) RETURNS trigger AS $EOFCODE$
DECLARE
    v_primary_field "dashboard_public".emails;
BEGIN
    SELECT * INTO v_primary_field
        FROM "dashboard_public".emails e
        WHERE e.owner_id = NEW.owner_id
        AND is_primary IS TRUE;
    IF (NOT FOUND) THEN 
        NEW.is_primary = TRUE;
    END IF;
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER trigger_name 
 BEFORE INSERT ON dashboard_public.emails 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. emails_insert_tg (  );

CREATE UNIQUE INDEX emails_is_primary_idx ON dashboard_public.emails ( is_primary, owner_id ) WHERE is_primary IS TRUE;

CREATE TRIGGER emails_immutable_tg 
 BEFORE UPDATE ON dashboard_public.emails 
 FOR EACH ROW
 WHEN ( old.email IS DISTINCT FROM new.email AND old.email IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','email' );

CREATE TABLE dashboard_public.phone_numbers (
  
);

ALTER TABLE dashboard_public.phone_numbers DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.phone_numbers ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.phone_numbers ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.phone_numbers ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.phone_numbers ADD CONSTRAINT phone_numbers_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.phone_numbers ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.phone_numbers ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.phone_numbers ALTER COLUMN owner_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_public.phone_numbers ADD CONSTRAINT phone_numbers_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

ALTER TABLE dashboard_public.phone_numbers ADD COLUMN  cc text;

ALTER TABLE dashboard_public.phone_numbers ALTER COLUMN cc SET NOT NULL;

ALTER TABLE dashboard_public.phone_numbers ADD COLUMN  number text;

ALTER TABLE dashboard_public.phone_numbers ALTER COLUMN number SET NOT NULL;

ALTER TABLE dashboard_public.phone_numbers ADD COLUMN  is_verified boolean;

ALTER TABLE dashboard_public.phone_numbers ALTER COLUMN is_verified SET NOT NULL;

ALTER TABLE dashboard_public.phone_numbers ALTER COLUMN is_verified SET DEFAULT FALSE;

ALTER TABLE dashboard_public.phone_numbers ADD COLUMN  is_primary boolean;

ALTER TABLE dashboard_public.phone_numbers ALTER COLUMN is_primary SET NOT NULL;

ALTER TABLE dashboard_public.phone_numbers ALTER COLUMN is_primary SET DEFAULT FALSE;

ALTER TABLE dashboard_public.phone_numbers ADD CONSTRAINT phone_numbers_number_key UNIQUE ( number );

ALTER TABLE dashboard_public.phone_numbers ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.phone_numbers ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.phone_numbers ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.phone_numbers ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.phone_numbers 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.phone_numbers ( created_at );

CREATE INDEX ON dashboard_public.phone_numbers ( updated_at );

ALTER TABLE dashboard_public.phone_numbers ENABLE ROW LEVEL SECURITY;

GRANT UPDATE ( cc, number, owner_id, is_primary ) ON TABLE dashboard_public.phone_numbers TO authenticated;

GRANT INSERT ( cc, number, owner_id, is_primary ) ON TABLE dashboard_public.phone_numbers TO authenticated;

GRANT SELECT ON TABLE dashboard_public.phone_numbers TO authenticated;

GRANT DELETE ON TABLE dashboard_public.phone_numbers TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.phone_numbers FOR SELECT TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000100000000000') = '00000000000000000000100000000000') );

CREATE POLICY auth_ins ON dashboard_public.phone_numbers FOR INSERT TO authenticated WITH CHECK ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000100000000000') = '00000000000000000000100000000000') );

CREATE POLICY auth_upd ON dashboard_public.phone_numbers FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000100000000000') = '00000000000000000000100000000000') );

CREATE POLICY auth_del ON dashboard_public.phone_numbers FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000100000000000') = '00000000000000000000100000000000') );

CREATE FUNCTION dashboard_private.phone_numbers_insert_tg (  ) RETURNS trigger AS $EOFCODE$
DECLARE
    v_primary_field "dashboard_public".phone_numbers;
BEGIN
    SELECT * INTO v_primary_field
        FROM "dashboard_public".phone_numbers e
        WHERE e.owner_id = NEW.owner_id
        AND is_primary IS TRUE;
    IF (NOT FOUND) THEN 
        NEW.is_primary = TRUE;
    END IF;
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER trigger_name 
 BEFORE INSERT ON dashboard_public.phone_numbers 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. phone_numbers_insert_tg (  );

CREATE UNIQUE INDEX phone_numbers_is_primary_idx ON dashboard_public.phone_numbers ( is_primary, owner_id ) WHERE is_primary IS TRUE;

CREATE TRIGGER phone_numbers_immutable_number_tg 
 BEFORE UPDATE ON dashboard_public.phone_numbers 
 FOR EACH ROW
 WHEN ( old.number IS DISTINCT FROM new.number AND old.number IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','number' );

CREATE TRIGGER phone_numbers_immutable_cc_tg 
 BEFORE UPDATE ON dashboard_public.phone_numbers 
 FOR EACH ROW
 WHEN ( old.cc IS DISTINCT FROM new.cc AND old.cc IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','cc' );

CREATE TABLE dashboard_public.crypto_addresses (
  
);

ALTER TABLE dashboard_public.crypto_addresses DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.crypto_addresses ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.crypto_addresses ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.crypto_addresses ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.crypto_addresses ADD CONSTRAINT crypto_addresses_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.crypto_addresses ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.crypto_addresses ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.crypto_addresses ALTER COLUMN owner_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_public.crypto_addresses ADD CONSTRAINT crypto_addresses_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

ALTER TABLE dashboard_public.crypto_addresses ADD COLUMN  address text;

ALTER TABLE dashboard_public.crypto_addresses ALTER COLUMN address SET NOT NULL;

ALTER TABLE dashboard_public.crypto_addresses ADD CONSTRAINT crypto_addresses_address_chk CHECK ( address ~* '^(bc1|[13])[a-zA-HJ-NP-Z0-9]{25,39}$' );

ALTER TABLE dashboard_public.crypto_addresses ADD COLUMN  is_verified boolean;

ALTER TABLE dashboard_public.crypto_addresses ALTER COLUMN is_verified SET NOT NULL;

ALTER TABLE dashboard_public.crypto_addresses ALTER COLUMN is_verified SET DEFAULT FALSE;

ALTER TABLE dashboard_public.crypto_addresses ADD COLUMN  is_primary boolean;

ALTER TABLE dashboard_public.crypto_addresses ALTER COLUMN is_primary SET NOT NULL;

ALTER TABLE dashboard_public.crypto_addresses ALTER COLUMN is_primary SET DEFAULT FALSE;

ALTER TABLE dashboard_public.crypto_addresses ADD CONSTRAINT crypto_addresses_address_key UNIQUE ( address );

ALTER TABLE dashboard_public.crypto_addresses ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.crypto_addresses ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.crypto_addresses ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.crypto_addresses ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.crypto_addresses 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.crypto_addresses ( created_at );

CREATE INDEX ON dashboard_public.crypto_addresses ( updated_at );

ALTER TABLE dashboard_public.crypto_addresses ENABLE ROW LEVEL SECURITY;

GRANT UPDATE ( address, owner_id, is_primary ) ON TABLE dashboard_public.crypto_addresses TO authenticated;

GRANT INSERT ( address, owner_id, is_primary ) ON TABLE dashboard_public.crypto_addresses TO authenticated;

GRANT SELECT ON TABLE dashboard_public.crypto_addresses TO authenticated;

GRANT DELETE ON TABLE dashboard_public.crypto_addresses TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.crypto_addresses FOR SELECT TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000100000000000') = '00000000000000000000100000000000') );

CREATE POLICY auth_ins ON dashboard_public.crypto_addresses FOR INSERT TO authenticated WITH CHECK ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000100000000000') = '00000000000000000000100000000000') );

CREATE POLICY auth_upd ON dashboard_public.crypto_addresses FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000100000000000') = '00000000000000000000100000000000') );

CREATE POLICY auth_del ON dashboard_public.crypto_addresses FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000100000000000') = '00000000000000000000100000000000') );

CREATE FUNCTION dashboard_private.crypto_addresses_insert_tg (  ) RETURNS trigger AS $EOFCODE$
DECLARE
    v_primary_field "dashboard_public".crypto_addresses;
BEGIN
    SELECT * INTO v_primary_field
        FROM "dashboard_public".crypto_addresses e
        WHERE e.owner_id = NEW.owner_id
        AND is_primary IS TRUE;
    IF (NOT FOUND) THEN 
        NEW.is_primary = TRUE;
    END IF;
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER trigger_name 
 BEFORE INSERT ON dashboard_public.crypto_addresses 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. crypto_addresses_insert_tg (  );

CREATE UNIQUE INDEX crypto_addresses_is_primary_idx ON dashboard_public.crypto_addresses ( is_primary, owner_id ) WHERE is_primary IS TRUE;

CREATE TRIGGER crypto_addresses_immutable_tg 
 BEFORE UPDATE ON dashboard_public.crypto_addresses 
 FOR EACH ROW
 WHEN ( old.address IS DISTINCT FROM new.address AND old.address IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','address' );

CREATE SCHEMA dashboard_invites_public;

GRANT USAGE ON SCHEMA dashboard_invites_public TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_invites_public 
 GRANT ALL ON TABLES  TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_invites_public 
 GRANT ALL ON SEQUENCES  TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_invites_public 
 GRANT ALL ON FUNCTIONS  TO administrator;

GRANT USAGE ON SCHEMA dashboard_invites_public TO authenticated;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_invites_public 
 GRANT ALL ON FUNCTIONS  TO authenticated;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_invites_public 
 GRANT USAGE, SELECT ON SEQUENCES  TO authenticated;

GRANT USAGE ON SCHEMA dashboard_invites_public TO anonymous;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_invites_public 
 GRANT ALL ON FUNCTIONS  TO anonymous;

CREATE SCHEMA dashboard_invites_private;

GRANT USAGE ON SCHEMA dashboard_invites_private TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_invites_private 
 GRANT ALL ON TABLES  TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_invites_private 
 GRANT ALL ON SEQUENCES  TO administrator;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_invites_private 
 GRANT ALL ON FUNCTIONS  TO administrator;

GRANT USAGE ON SCHEMA dashboard_invites_private TO authenticated;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_invites_private 
 GRANT ALL ON FUNCTIONS  TO authenticated;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_invites_private 
 GRANT USAGE, SELECT ON SEQUENCES  TO authenticated;

GRANT USAGE ON SCHEMA dashboard_invites_private TO anonymous;

ALTER DEFAULT PRIVILEGES IN SCHEMA dashboard_invites_private 
 GRANT ALL ON FUNCTIONS  TO anonymous;

CREATE TABLE dashboard_invites_public.invites (
  
);

ALTER TABLE dashboard_invites_public.invites DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_invites_public.invites ADD COLUMN  id uuid;

ALTER TABLE dashboard_invites_public.invites ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_invites_public.invites ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_invites_public.invites ADD CONSTRAINT invites_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_invites_public.invites ADD COLUMN  email email;

ALTER TABLE dashboard_invites_public.invites ADD COLUMN  sender_id uuid;

ALTER TABLE dashboard_invites_public.invites ALTER COLUMN sender_id SET NOT NULL;

ALTER TABLE dashboard_invites_public.invites ALTER COLUMN sender_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_invites_public.invites ADD COLUMN  invite_token text;

ALTER TABLE dashboard_invites_public.invites ALTER COLUMN invite_token SET NOT NULL;

ALTER TABLE dashboard_invites_public.invites ALTER COLUMN invite_token SET DEFAULT encode(gen_random_bytes(16), 'hex');

ALTER TABLE dashboard_invites_public.invites ADD COLUMN  invite_valid boolean;

ALTER TABLE dashboard_invites_public.invites ALTER COLUMN invite_valid SET NOT NULL;

ALTER TABLE dashboard_invites_public.invites ALTER COLUMN invite_valid SET DEFAULT TRUE;

ALTER TABLE dashboard_invites_public.invites ADD COLUMN  invite_limit int;

ALTER TABLE dashboard_invites_public.invites ALTER COLUMN invite_limit SET NOT NULL;

ALTER TABLE dashboard_invites_public.invites ALTER COLUMN invite_limit SET DEFAULT (-1);

ALTER TABLE dashboard_invites_public.invites ADD COLUMN  invite_count int;

ALTER TABLE dashboard_invites_public.invites ALTER COLUMN invite_count SET NOT NULL;

ALTER TABLE dashboard_invites_public.invites ALTER COLUMN invite_count SET DEFAULT 0;

ALTER TABLE dashboard_invites_public.invites ADD COLUMN  multiple boolean;

ALTER TABLE dashboard_invites_public.invites ALTER COLUMN multiple SET NOT NULL;

ALTER TABLE dashboard_invites_public.invites ALTER COLUMN multiple SET DEFAULT FALSE;

ALTER TABLE dashboard_invites_public.invites ADD COLUMN  data json;

ALTER TABLE dashboard_invites_public.invites ADD COLUMN  expires_at timestamptz;

ALTER TABLE dashboard_invites_public.invites ALTER COLUMN expires_at SET NOT NULL;

ALTER TABLE dashboard_invites_public.invites ALTER COLUMN expires_at SET DEFAULT now() + '6 months'::interval;

ALTER TABLE dashboard_invites_public.invites ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_invites_public.invites ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_invites_public.invites ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_invites_public.invites ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_invites_public.invites 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_invites_public.invites ( created_at );

CREATE INDEX ON dashboard_invites_public.invites ( updated_at );

ALTER TABLE dashboard_invites_public.invites ADD CONSTRAINT invites_invite_token_key UNIQUE ( invite_token );

ALTER TABLE dashboard_invites_public.invites ADD CONSTRAINT invites_email_sender_id_key UNIQUE ( email, sender_id );

CREATE INDEX invites_expires_at_idx ON dashboard_invites_public.invites ( expires_at );

CREATE INDEX invites_invite_valid_idx ON dashboard_invites_public.invites ( invite_valid );

CREATE INDEX invites_sender_id_idx ON dashboard_invites_public.invites ( sender_id );

ALTER TABLE dashboard_invites_public.invites ADD CONSTRAINT invites_sender_id_fkey FOREIGN KEY ( sender_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

CREATE TABLE dashboard_invites_public.claimed_invites (
  
);

ALTER TABLE dashboard_invites_public.claimed_invites DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_invites_public.claimed_invites ADD COLUMN  id uuid;

ALTER TABLE dashboard_invites_public.claimed_invites ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_invites_public.claimed_invites ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_invites_public.claimed_invites ADD CONSTRAINT claimed_invites_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_invites_public.claimed_invites ADD COLUMN  data json;

ALTER TABLE dashboard_invites_public.claimed_invites ADD COLUMN  sender_id uuid;

ALTER TABLE dashboard_invites_public.claimed_invites ADD COLUMN  receiver_id uuid;

ALTER TABLE dashboard_invites_public.claimed_invites ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_invites_public.claimed_invites ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_invites_public.claimed_invites ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_invites_public.claimed_invites ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_invites_public.claimed_invites 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_invites_public.claimed_invites ( created_at );

CREATE INDEX ON dashboard_invites_public.claimed_invites ( updated_at );

ALTER TABLE dashboard_invites_public.claimed_invites ADD CONSTRAINT claimed_invites_sender_id_fkey FOREIGN KEY ( sender_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

ALTER TABLE dashboard_invites_public.claimed_invites ADD CONSTRAINT claimed_invites_receiver_id_fkey FOREIGN KEY ( receiver_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

CREATE INDEX claimed_invites_sender_id_idx ON dashboard_invites_public.claimed_invites ( sender_id );

CREATE INDEX claimed_invites_receiver_id_idx ON dashboard_invites_public.claimed_invites ( receiver_id );

CREATE FUNCTION dashboard_invites_public.submit_invite_code ( token text ) RETURNS boolean AS $EOFCODE$
DECLARE
  v_user "dashboard_public".users;
  v_email "dashboard_public".emails;
  v_invite "dashboard_invites_public".invites;
BEGIN
  SELECT * FROM "dashboard_public".users
  WHERE id = jwt_public.current_user_id ()
  INTO v_user;
  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'OBJECT_NOT_FOUND';
  END IF;
  
  SELECT * FROM "dashboard_invites_public".invites i
    WHERE i.invite_token = token
    AND EXTRACT(EPOCH FROM (i.expires_at - NOW())) > 0
    AND i.invite_valid = TRUE
  INTO v_invite;
  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'INVITE_NOT_FOUND';
  END IF;
  IF (v_invite.invite_limit > 0 AND v_invite.invite_count >= v_invite.invite_limit) THEN
    RAISE EXCEPTION 'INVITE_LIMIT';
  END IF;
  IF (v_invite.email IS NOT NULL) THEN 
    SELECT * FROM "dashboard_public".emails e
    WHERE e.email = v_invite.email
      AND e.owner_id = v_user.id
    INTO v_email;
    
    IF (NOT FOUND) THEN
      RAISE EXCEPTION 'INVITE_EMAIL_NOT_FOUND';
    END IF;
  END IF;
  IF (v_email.email IS NOT NULL OR v_invite.multiple IS FALSE) THEN 
    UPDATE "dashboard_invites_public".invites 
    SET invite_valid = FALSE
    WHERE id = v_invite.id;
  END IF;
  UPDATE "dashboard_invites_public".invites 
    SET invite_count = invite_count + 1
  WHERE id = v_invite.id;
  INSERT INTO "dashboard_invites_public".claimed_invites 
    (sender_id, receiver_id, data)
  VALUES (v_invite.sender_id, v_user.id, v_invite.data);
  IF (
    "dashboard_memberships_private".app_memberships_perm_check(
        'invites_approved',
        v_invite.sender_id
    ) IS TRUE
   ) THEN 
    INSERT INTO "dashboard_memberships_public".app_memberships 
      (is_approved, actor_id)
    VALUES (TRUE, v_user.id)
    ON CONFLICT (actor_id)
    DO UPDATE
      SET is_approved = EXCLUDED.is_approved;
  ELSE 
    INSERT INTO "dashboard_memberships_public".app_memberships 
      (is_approved, actor_id)
    VALUES (FALSE, v_user.id)
    ON CONFLICT (actor_id)
    DO NOTHING;
  END IF;
  RETURN TRUE;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION dashboard_invites_public.submit_invite_code TO authenticated;

CREATE FUNCTION dashboard_invites_private.invites_insert_before_tg (  ) RETURNS trigger AS $EOFCODE$
BEGIN
    IF (NEW.email IS NOT NULL) THEN 
        PERFORM
            app_jobs.add_job (
                jwt_private.current_database_id(),
                'send-email-link',
                json_build_object(
                    'invite_table', 'invites',
                    'invite_type', 1,
                    'email_type', 'invite_email',
                    'email', NEW.email,
                    'sender_id', NEW.sender_id,
                    'invite_token', NEW.invite_token
                )
            );
    END IF;
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

CREATE FUNCTION dashboard_invites_private.invites_insert_after_tg (  ) RETURNS trigger AS $EOFCODE$
DECLARE
    email_exists boolean;
BEGIN
    IF (NEW.email IS NOT NULL) THEN 
        SELECT EXISTS( SELECT 
                    1 
                FROM 
                    "dashboard_public".emails e
                WHERE 
                    e.email = NEW.email)
        INTO email_exists;
        IF (email_exists IS TRUE) THEN 
            RAISE EXCEPTION 'ACCOUNT_EXISTS';
        END IF;
    END IF;
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER invite_trigger_ensure_email_not_exists 
 BEFORE INSERT ON dashboard_invites_public.invites 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_invites_private. invites_insert_after_tg (  );

CREATE TRIGGER invite_trigger_send_email 
 AFTER INSERT ON dashboard_invites_public.invites 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_invites_private. invites_insert_before_tg (  );

ALTER TABLE dashboard_invites_public.invites ENABLE ROW LEVEL SECURITY;

GRANT INSERT ( email, expires_at, multiple, invite_limit ) ON TABLE dashboard_invites_public.invites TO authenticated;

GRANT SELECT ON TABLE dashboard_invites_public.invites TO authenticated;

GRANT UPDATE ON TABLE dashboard_invites_public.invites TO authenticated;

GRANT DELETE ON TABLE dashboard_invites_public.invites TO authenticated;

CREATE POLICY auth_ins ON dashboard_invites_public.invites FOR INSERT TO authenticated WITH CHECK ( sender_id = jwt_public.current_user_id() );

CREATE POLICY auth_ins_create_invite_check ON dashboard_invites_public.invites AS RESTRICTIVE FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000000010') = '00000000000000000000000000000010') );

CREATE POLICY auth_sel ON dashboard_invites_public.invites FOR SELECT TO authenticated USING ( sender_id = jwt_public.current_user_id() );

CREATE POLICY auth_upd ON dashboard_invites_public.invites FOR UPDATE TO authenticated USING ( sender_id = jwt_public.current_user_id() );

CREATE POLICY auth_del ON dashboard_invites_public.invites FOR DELETE TO authenticated USING ( sender_id = jwt_public.current_user_id() );

ALTER TABLE dashboard_invites_public.claimed_invites ENABLE ROW LEVEL SECURITY;

GRANT SELECT ON TABLE dashboard_invites_public.claimed_invites TO authenticated;

CREATE POLICY auth_sel_sender ON dashboard_invites_public.claimed_invites FOR SELECT TO authenticated USING ( sender_id = jwt_public.current_user_id() );

CREATE POLICY auth_sel_receiver ON dashboard_invites_public.claimed_invites FOR SELECT TO authenticated USING ( receiver_id = jwt_public.current_user_id() );

CREATE TABLE dashboard_invites_public.member_invites (
  
);

ALTER TABLE dashboard_invites_public.member_invites DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_invites_public.member_invites ADD COLUMN  id uuid;

ALTER TABLE dashboard_invites_public.member_invites ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_invites_public.member_invites ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_invites_public.member_invites ADD CONSTRAINT member_invites_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_invites_public.member_invites ADD COLUMN  email email;

ALTER TABLE dashboard_invites_public.member_invites ADD COLUMN  sender_id uuid;

ALTER TABLE dashboard_invites_public.member_invites ALTER COLUMN sender_id SET NOT NULL;

ALTER TABLE dashboard_invites_public.member_invites ALTER COLUMN sender_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_invites_public.member_invites ADD COLUMN  receiver_id uuid;

ALTER TABLE dashboard_invites_public.member_invites ADD COLUMN  invite_token text;

ALTER TABLE dashboard_invites_public.member_invites ALTER COLUMN invite_token SET NOT NULL;

ALTER TABLE dashboard_invites_public.member_invites ALTER COLUMN invite_token SET DEFAULT encode(gen_random_bytes(16), 'hex');

ALTER TABLE dashboard_invites_public.member_invites ADD COLUMN  invite_valid boolean;

ALTER TABLE dashboard_invites_public.member_invites ALTER COLUMN invite_valid SET NOT NULL;

ALTER TABLE dashboard_invites_public.member_invites ALTER COLUMN invite_valid SET DEFAULT TRUE;

ALTER TABLE dashboard_invites_public.member_invites ADD COLUMN  invite_limit int;

ALTER TABLE dashboard_invites_public.member_invites ALTER COLUMN invite_limit SET NOT NULL;

ALTER TABLE dashboard_invites_public.member_invites ALTER COLUMN invite_limit SET DEFAULT (-1);

ALTER TABLE dashboard_invites_public.member_invites ADD COLUMN  invite_count int;

ALTER TABLE dashboard_invites_public.member_invites ALTER COLUMN invite_count SET NOT NULL;

ALTER TABLE dashboard_invites_public.member_invites ALTER COLUMN invite_count SET DEFAULT 0;

ALTER TABLE dashboard_invites_public.member_invites ADD COLUMN  multiple boolean;

ALTER TABLE dashboard_invites_public.member_invites ALTER COLUMN multiple SET NOT NULL;

ALTER TABLE dashboard_invites_public.member_invites ALTER COLUMN multiple SET DEFAULT FALSE;

ALTER TABLE dashboard_invites_public.member_invites ADD COLUMN  data json;

ALTER TABLE dashboard_invites_public.member_invites ADD COLUMN  expires_at timestamptz;

ALTER TABLE dashboard_invites_public.member_invites ALTER COLUMN expires_at SET NOT NULL;

ALTER TABLE dashboard_invites_public.member_invites ALTER COLUMN expires_at SET DEFAULT now() + '6 months'::interval;

ALTER TABLE dashboard_invites_public.member_invites ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_invites_public.member_invites ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_invites_public.member_invites ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_invites_public.member_invites ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_invites_public.member_invites 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_invites_public.member_invites ( created_at );

CREATE INDEX ON dashboard_invites_public.member_invites ( updated_at );

ALTER TABLE dashboard_invites_public.member_invites ADD CONSTRAINT member_invites_invite_token_key UNIQUE ( invite_token );

ALTER TABLE dashboard_invites_public.member_invites ADD COLUMN  entity_id uuid;

ALTER TABLE dashboard_invites_public.member_invites ALTER COLUMN entity_id SET NOT NULL;

ALTER TABLE dashboard_invites_public.member_invites ADD CONSTRAINT member_invites_entity_id_fkey FOREIGN KEY ( entity_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

ALTER TABLE dashboard_invites_public.member_invites ADD CONSTRAINT member_invites_email_sender_id_entity_id_key UNIQUE ( email, sender_id, entity_id );

CREATE INDEX member_invites_expires_at_idx ON dashboard_invites_public.member_invites ( expires_at );

CREATE INDEX member_invites_invite_valid_idx ON dashboard_invites_public.member_invites ( invite_valid );

CREATE INDEX member_invites_sender_id_idx ON dashboard_invites_public.member_invites ( sender_id );

ALTER TABLE dashboard_invites_public.member_invites ADD CONSTRAINT member_invites_sender_id_fkey FOREIGN KEY ( sender_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

ALTER TABLE dashboard_invites_public.member_invites ADD CONSTRAINT member_invites_receiver_id_fkey FOREIGN KEY ( receiver_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

CREATE TABLE dashboard_invites_public.member_claimed_invites (
  
);

ALTER TABLE dashboard_invites_public.member_claimed_invites DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_invites_public.member_claimed_invites ADD COLUMN  id uuid;

ALTER TABLE dashboard_invites_public.member_claimed_invites ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_invites_public.member_claimed_invites ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_invites_public.member_claimed_invites ADD CONSTRAINT member_claimed_invites_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_invites_public.member_claimed_invites ADD COLUMN  data json;

ALTER TABLE dashboard_invites_public.member_claimed_invites ADD COLUMN  sender_id uuid;

ALTER TABLE dashboard_invites_public.member_claimed_invites ADD COLUMN  receiver_id uuid;

ALTER TABLE dashboard_invites_public.member_claimed_invites ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_invites_public.member_claimed_invites ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_invites_public.member_claimed_invites ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_invites_public.member_claimed_invites ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_invites_public.member_claimed_invites 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_invites_public.member_claimed_invites ( created_at );

CREATE INDEX ON dashboard_invites_public.member_claimed_invites ( updated_at );

ALTER TABLE dashboard_invites_public.member_claimed_invites ADD CONSTRAINT member_claimed_invites_sender_id_fkey FOREIGN KEY ( sender_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

ALTER TABLE dashboard_invites_public.member_claimed_invites ADD CONSTRAINT member_claimed_invites_receiver_id_fkey FOREIGN KEY ( receiver_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

CREATE INDEX member_claimed_invites_sender_id_idx ON dashboard_invites_public.member_claimed_invites ( sender_id );

CREATE INDEX member_claimed_invites_receiver_id_idx ON dashboard_invites_public.member_claimed_invites ( receiver_id );

ALTER TABLE dashboard_invites_public.member_claimed_invites ADD COLUMN  entity_id uuid;

ALTER TABLE dashboard_invites_public.member_claimed_invites ALTER COLUMN entity_id SET NOT NULL;

ALTER TABLE dashboard_invites_public.member_claimed_invites ADD CONSTRAINT member_claimed_invites_entity_id_fkey FOREIGN KEY ( entity_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

CREATE FUNCTION dashboard_invites_public.submit_member_invite_code ( token text ) RETURNS boolean AS $EOFCODE$
DECLARE
  v_user "dashboard_public".users;
  v_email "dashboard_public".emails;
  v_invite "dashboard_invites_public".member_invites;
BEGIN
  SELECT * FROM "dashboard_public".users
  WHERE id = jwt_public.current_user_id ()
  INTO v_user;
  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'OBJECT_NOT_FOUND';
  END IF;
  
  SELECT * FROM "dashboard_invites_public".member_invites i
    WHERE i.invite_token = token
    AND EXTRACT(EPOCH FROM (i.expires_at - NOW())) > 0
    AND i.invite_valid = TRUE
  INTO v_invite;
  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'INVITE_NOT_FOUND';
  END IF;
  IF (v_invite.invite_limit > 0 AND v_invite.invite_count >= v_invite.invite_limit) THEN
    RAISE EXCEPTION 'INVITE_LIMIT';
  END IF;
  IF (v_invite.email IS NOT NULL) THEN 
    SELECT * FROM "dashboard_public".emails e
    WHERE e.email = v_invite.email
      AND e.owner_id = v_user.id
    INTO v_email;
    
    IF (NOT FOUND) THEN
      RAISE EXCEPTION 'INVITE_EMAIL_NOT_FOUND';
    END IF;
  END IF;
  IF (v_invite.receiver_id IS NOT NULL) THEN 
    IF (v_invite.receiver_id <> v_user.id) THEN
      RAISE EXCEPTION 'INVITE_EMAIL_NOT_FOUND';
    END IF;
  END IF;
  IF (v_email.email IS NOT NULL OR v_invite.multiple IS FALSE) THEN 
    UPDATE "dashboard_invites_public".member_invites 
    SET invite_valid = FALSE
    WHERE id = v_invite.id;
  END IF;
  UPDATE "dashboard_invites_public".member_invites 
    SET invite_count = invite_count + 1
  WHERE id = v_invite.id;
  INSERT INTO "dashboard_invites_public".member_claimed_invites 
    (sender_id, receiver_id, data, entity_id)
  VALUES (v_invite.sender_id, v_user.id, v_invite.data, v_invite.entity_id);
  IF (
    "dashboard_memberships_private".memberships_perm_check(
        'invites_approved',
        v_invite.entity_id,
        v_invite.sender_id
    ) IS TRUE
   ) THEN 
    INSERT INTO "dashboard_memberships_public".memberships 
      (is_approved, entity_id, actor_id)
    VALUES (TRUE, v_invite.entity_id, v_user.id)
    ON CONFLICT (entity_id, actor_id)
    DO UPDATE
      SET is_approved = EXCLUDED.is_approved;
  ELSE
    INSERT INTO "dashboard_memberships_public".memberships 
      (is_approved, entity_id, actor_id)
    VALUES (FALSE, v_invite.entity_id, v_user.id)
    ON CONFLICT (entity_id, actor_id)
    DO NOTHING;
  END IF;
  RETURN TRUE;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION dashboard_invites_public.submit_member_invite_code TO authenticated;

CREATE FUNCTION dashboard_invites_private.member_invites_insert_before_tg (  ) RETURNS trigger AS $EOFCODE$
BEGIN
    IF (NEW.email IS NOT NULL) THEN 
        PERFORM
            app_jobs.add_job (
                jwt_private.current_database_id(),
                'send-email-link',
                json_build_object(
                    'invite_table', 'member_invites',
                    'invite_type', 2,
                    'email_type', 'invite_email',
                    'email', NEW.email,
                    'sender_id', NEW.sender_id,
                    'invite_token', NEW.invite_token
                )
            );
    END IF;
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

CREATE FUNCTION dashboard_invites_private.member_invites_insert_after_tg (  ) RETURNS trigger AS $EOFCODE$
DECLARE
    owner_id boolean;
    membership_exists boolean;
BEGIN
    IF (NEW.email IS NOT NULL) THEN 
        SELECT 
          e.owner_id
            FROM 
                "dashboard_public".emails e
                WHERE 
                    e.email = NEW.email
        INTO owner_id;
        IF (FOUND) THEN 
            NEW.receiver_id = owner_id;
            SELECT EXISTS( SELECT 
                        1 
                    FROM 
                        "dashboard_memberships_public".memberships m
                    WHERE 
                        m.actor_id = NEW.receiver_id
                        AND m.entity_id = NEW.entity_id
                    )
            INTO membership_exists;
            IF (membership_exists IS TRUE) THEN 
                RAISE EXCEPTION 'ACCOUNT_EXISTS';
            END IF;
        END IF;
    END IF;
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER invite_trigger_ensure_email_not_exists 
 BEFORE INSERT ON dashboard_invites_public.member_invites 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_invites_private. member_invites_insert_after_tg (  );

CREATE TRIGGER invite_trigger_send_email 
 AFTER INSERT ON dashboard_invites_public.member_invites 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_invites_private. member_invites_insert_before_tg (  );

ALTER TABLE dashboard_invites_public.member_invites ENABLE ROW LEVEL SECURITY;

GRANT INSERT ( email, expires_at, multiple, invite_limit, entity_id, receiver_id ) ON TABLE dashboard_invites_public.member_invites TO authenticated;

GRANT SELECT ON TABLE dashboard_invites_public.member_invites TO authenticated;

GRANT UPDATE ON TABLE dashboard_invites_public.member_invites TO authenticated;

GRANT DELETE ON TABLE dashboard_invites_public.member_invites TO authenticated;

CREATE POLICY auth_ins ON dashboard_invites_public.member_invites FOR INSERT TO authenticated WITH CHECK ( sender_id = jwt_public.current_user_id() );

CREATE POLICY auth_ins_create_invite_check ON dashboard_invites_public.member_invites AS RESTRICTIVE FOR INSERT TO authenticated WITH CHECK ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000000010') = '00000000000000000000000000000010') );

CREATE POLICY auth_sel ON dashboard_invites_public.member_invites FOR SELECT TO authenticated USING ( sender_id = jwt_public.current_user_id() );

CREATE POLICY auth_upd ON dashboard_invites_public.member_invites FOR UPDATE TO authenticated USING ( sender_id = jwt_public.current_user_id() );

CREATE POLICY auth_del ON dashboard_invites_public.member_invites FOR DELETE TO authenticated USING ( sender_id = jwt_public.current_user_id() );

ALTER TABLE dashboard_invites_public.member_claimed_invites ENABLE ROW LEVEL SECURITY;

GRANT SELECT ON TABLE dashboard_invites_public.member_claimed_invites TO authenticated;

CREATE POLICY auth_sel_sender ON dashboard_invites_public.member_claimed_invites FOR SELECT TO authenticated USING ( sender_id = jwt_public.current_user_id() );

CREATE POLICY auth_sel_receiver ON dashboard_invites_public.member_claimed_invites FOR SELECT TO authenticated USING ( receiver_id = jwt_public.current_user_id() );

CREATE POLICY auth_sel_members ON dashboard_invites_public.member_invites FOR SELECT TO authenticated USING ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000000100') = '00000000000000000000000000000100') );

CREATE POLICY auth_del_members ON dashboard_invites_public.member_invites FOR DELETE TO authenticated USING ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE) );

CREATE POLICY auth_sel_members ON dashboard_invites_public.member_claimed_invites FOR SELECT TO authenticated USING ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000000100') = '00000000000000000000000000000100') );

CREATE TABLE dashboard_invites_public.group_invites (
  
);

ALTER TABLE dashboard_invites_public.group_invites DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_invites_public.group_invites ADD COLUMN  id uuid;

ALTER TABLE dashboard_invites_public.group_invites ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_invites_public.group_invites ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_invites_public.group_invites ADD CONSTRAINT group_invites_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_invites_public.group_invites ADD COLUMN  email email;

ALTER TABLE dashboard_invites_public.group_invites ADD COLUMN  sender_id uuid;

ALTER TABLE dashboard_invites_public.group_invites ALTER COLUMN sender_id SET NOT NULL;

ALTER TABLE dashboard_invites_public.group_invites ALTER COLUMN sender_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_invites_public.group_invites ADD COLUMN  receiver_id uuid;

ALTER TABLE dashboard_invites_public.group_invites ADD COLUMN  invite_token text;

ALTER TABLE dashboard_invites_public.group_invites ALTER COLUMN invite_token SET NOT NULL;

ALTER TABLE dashboard_invites_public.group_invites ALTER COLUMN invite_token SET DEFAULT encode(gen_random_bytes(16), 'hex');

ALTER TABLE dashboard_invites_public.group_invites ADD COLUMN  invite_valid boolean;

ALTER TABLE dashboard_invites_public.group_invites ALTER COLUMN invite_valid SET NOT NULL;

ALTER TABLE dashboard_invites_public.group_invites ALTER COLUMN invite_valid SET DEFAULT TRUE;

ALTER TABLE dashboard_invites_public.group_invites ADD COLUMN  invite_limit int;

ALTER TABLE dashboard_invites_public.group_invites ALTER COLUMN invite_limit SET NOT NULL;

ALTER TABLE dashboard_invites_public.group_invites ALTER COLUMN invite_limit SET DEFAULT (-1);

ALTER TABLE dashboard_invites_public.group_invites ADD COLUMN  invite_count int;

ALTER TABLE dashboard_invites_public.group_invites ALTER COLUMN invite_count SET NOT NULL;

ALTER TABLE dashboard_invites_public.group_invites ALTER COLUMN invite_count SET DEFAULT 0;

ALTER TABLE dashboard_invites_public.group_invites ADD COLUMN  multiple boolean;

ALTER TABLE dashboard_invites_public.group_invites ALTER COLUMN multiple SET NOT NULL;

ALTER TABLE dashboard_invites_public.group_invites ALTER COLUMN multiple SET DEFAULT FALSE;

ALTER TABLE dashboard_invites_public.group_invites ADD COLUMN  data json;

ALTER TABLE dashboard_invites_public.group_invites ADD COLUMN  expires_at timestamptz;

ALTER TABLE dashboard_invites_public.group_invites ALTER COLUMN expires_at SET NOT NULL;

ALTER TABLE dashboard_invites_public.group_invites ALTER COLUMN expires_at SET DEFAULT now() + '6 months'::interval;

ALTER TABLE dashboard_invites_public.group_invites ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_invites_public.group_invites ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_invites_public.group_invites ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_invites_public.group_invites ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_invites_public.group_invites 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_invites_public.group_invites ( created_at );

CREATE INDEX ON dashboard_invites_public.group_invites ( updated_at );

ALTER TABLE dashboard_invites_public.group_invites ADD CONSTRAINT group_invites_invite_token_key UNIQUE ( invite_token );

ALTER TABLE dashboard_invites_public.group_invites ADD COLUMN  entity_id uuid;

ALTER TABLE dashboard_invites_public.group_invites ALTER COLUMN entity_id SET NOT NULL;

ALTER TABLE dashboard_invites_public.group_invites ADD CONSTRAINT group_invites_entity_id_fkey FOREIGN KEY ( entity_id ) REFERENCES dashboard_public.groups ( id ) ON DELETE CASCADE;

ALTER TABLE dashboard_invites_public.group_invites ADD CONSTRAINT group_invites_email_sender_id_entity_id_key UNIQUE ( email, sender_id, entity_id );

CREATE INDEX group_invites_expires_at_idx ON dashboard_invites_public.group_invites ( expires_at );

CREATE INDEX group_invites_invite_valid_idx ON dashboard_invites_public.group_invites ( invite_valid );

CREATE INDEX group_invites_sender_id_idx ON dashboard_invites_public.group_invites ( sender_id );

ALTER TABLE dashboard_invites_public.group_invites ADD CONSTRAINT group_invites_sender_id_fkey FOREIGN KEY ( sender_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

ALTER TABLE dashboard_invites_public.group_invites ADD CONSTRAINT group_invites_receiver_id_fkey FOREIGN KEY ( receiver_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

CREATE TABLE dashboard_invites_public.group_claimed_invites (
  
);

ALTER TABLE dashboard_invites_public.group_claimed_invites DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_invites_public.group_claimed_invites ADD COLUMN  id uuid;

ALTER TABLE dashboard_invites_public.group_claimed_invites ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_invites_public.group_claimed_invites ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_invites_public.group_claimed_invites ADD CONSTRAINT group_claimed_invites_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_invites_public.group_claimed_invites ADD COLUMN  data json;

ALTER TABLE dashboard_invites_public.group_claimed_invites ADD COLUMN  sender_id uuid;

ALTER TABLE dashboard_invites_public.group_claimed_invites ADD COLUMN  receiver_id uuid;

ALTER TABLE dashboard_invites_public.group_claimed_invites ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_invites_public.group_claimed_invites ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_invites_public.group_claimed_invites ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_invites_public.group_claimed_invites ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_invites_public.group_claimed_invites 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_invites_public.group_claimed_invites ( created_at );

CREATE INDEX ON dashboard_invites_public.group_claimed_invites ( updated_at );

ALTER TABLE dashboard_invites_public.group_claimed_invites ADD CONSTRAINT group_claimed_invites_sender_id_fkey FOREIGN KEY ( sender_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

ALTER TABLE dashboard_invites_public.group_claimed_invites ADD CONSTRAINT group_claimed_invites_receiver_id_fkey FOREIGN KEY ( receiver_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

CREATE INDEX group_claimed_invites_sender_id_idx ON dashboard_invites_public.group_claimed_invites ( sender_id );

CREATE INDEX group_claimed_invites_receiver_id_idx ON dashboard_invites_public.group_claimed_invites ( receiver_id );

ALTER TABLE dashboard_invites_public.group_claimed_invites ADD COLUMN  entity_id uuid;

ALTER TABLE dashboard_invites_public.group_claimed_invites ALTER COLUMN entity_id SET NOT NULL;

ALTER TABLE dashboard_invites_public.group_claimed_invites ADD CONSTRAINT group_claimed_invites_entity_id_fkey FOREIGN KEY ( entity_id ) REFERENCES dashboard_public.groups ( id ) ON DELETE CASCADE;

CREATE FUNCTION dashboard_invites_public.submit_group_invite_code ( token text ) RETURNS boolean AS $EOFCODE$
DECLARE
  v_user "dashboard_public".users;
  v_email "dashboard_public".emails;
  v_invite "dashboard_invites_public".group_invites;
BEGIN
  SELECT * FROM "dashboard_public".users
  WHERE id = jwt_public.current_user_id ()
  INTO v_user;
  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'OBJECT_NOT_FOUND';
  END IF;
  
  SELECT * FROM "dashboard_invites_public".group_invites i
    WHERE i.invite_token = token
    AND EXTRACT(EPOCH FROM (i.expires_at - NOW())) > 0
    AND i.invite_valid = TRUE
  INTO v_invite;
  IF (NOT FOUND) THEN
    RAISE EXCEPTION 'INVITE_NOT_FOUND';
  END IF;
  IF (v_invite.invite_limit > 0 AND v_invite.invite_count >= v_invite.invite_limit) THEN
    RAISE EXCEPTION 'INVITE_LIMIT';
  END IF;
  IF (v_invite.email IS NOT NULL) THEN 
    SELECT * FROM "dashboard_public".emails e
    WHERE e.email = v_invite.email
      AND e.owner_id = v_user.id
    INTO v_email;
    
    IF (NOT FOUND) THEN
      RAISE EXCEPTION 'INVITE_EMAIL_NOT_FOUND';
    END IF;
  END IF;
  IF (v_invite.receiver_id IS NOT NULL) THEN 
    IF (v_invite.receiver_id <> v_user.id) THEN
      RAISE EXCEPTION 'INVITE_EMAIL_NOT_FOUND';
    END IF;
  END IF;
  IF (v_email.email IS NOT NULL OR v_invite.multiple IS FALSE) THEN 
    UPDATE "dashboard_invites_public".group_invites 
    SET invite_valid = FALSE
    WHERE id = v_invite.id;
  END IF;
  UPDATE "dashboard_invites_public".group_invites 
    SET invite_count = invite_count + 1
  WHERE id = v_invite.id;
  INSERT INTO "dashboard_invites_public".group_claimed_invites 
    (sender_id, receiver_id, data, entity_id)
  VALUES (v_invite.sender_id, v_user.id, v_invite.data, v_invite.entity_id);
  IF (
    "dashboard_memberships_private".group_memberships_perm_check(
        'invites_approved',
        v_invite.entity_id,
        v_invite.sender_id
    ) IS TRUE
   ) THEN 
    INSERT INTO "dashboard_memberships_public".group_memberships 
      (is_approved, entity_id, actor_id)
    VALUES (TRUE, v_invite.entity_id, v_user.id)
    ON CONFLICT (entity_id, actor_id)
    DO UPDATE
      SET is_approved = EXCLUDED.is_approved;
  ELSE
    INSERT INTO "dashboard_memberships_public".group_memberships 
      (is_approved, entity_id, actor_id)
    VALUES (FALSE, v_invite.entity_id, v_user.id)
    ON CONFLICT (entity_id, actor_id)
    DO NOTHING;
  END IF;
  RETURN TRUE;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION dashboard_invites_public.submit_group_invite_code TO authenticated;

CREATE FUNCTION dashboard_invites_private.group_invites_insert_before_tg (  ) RETURNS trigger AS $EOFCODE$
BEGIN
    IF (NEW.email IS NOT NULL) THEN 
        PERFORM
            app_jobs.add_job (
                jwt_private.current_database_id(),
                'send-email-link',
                json_build_object(
                    'invite_table', 'group_invites',
                    'invite_type', 3,
                    'email_type', 'invite_email',
                    'email', NEW.email,
                    'sender_id', NEW.sender_id,
                    'invite_token', NEW.invite_token
                )
            );
    END IF;
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

CREATE FUNCTION dashboard_invites_private.group_invites_insert_after_tg (  ) RETURNS trigger AS $EOFCODE$
DECLARE
    owner_id boolean;
    membership_exists boolean;
BEGIN
    IF (NEW.email IS NOT NULL) THEN 
        SELECT 
          e.owner_id
            FROM 
                "dashboard_public".emails e
                WHERE 
                    e.email = NEW.email
        INTO owner_id;
        IF (FOUND) THEN 
            NEW.receiver_id = owner_id;
            SELECT EXISTS( SELECT 
                        1 
                    FROM 
                        "dashboard_memberships_public".group_memberships m
                    WHERE 
                        m.actor_id = NEW.receiver_id
                        AND m.entity_id = NEW.entity_id
                    )
            INTO membership_exists;
            IF (membership_exists IS TRUE) THEN 
                RAISE EXCEPTION 'ACCOUNT_EXISTS';
            END IF;
        END IF;
    END IF;
    RETURN NEW;
END;
$EOFCODE$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER invite_trigger_ensure_email_not_exists 
 BEFORE INSERT ON dashboard_invites_public.group_invites 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_invites_private. group_invites_insert_after_tg (  );

CREATE TRIGGER invite_trigger_send_email 
 AFTER INSERT ON dashboard_invites_public.group_invites 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_invites_private. group_invites_insert_before_tg (  );

ALTER TABLE dashboard_invites_public.group_invites ENABLE ROW LEVEL SECURITY;

GRANT INSERT ( email, expires_at, multiple, invite_limit, entity_id, receiver_id ) ON TABLE dashboard_invites_public.group_invites TO authenticated;

GRANT SELECT ON TABLE dashboard_invites_public.group_invites TO authenticated;

GRANT UPDATE ON TABLE dashboard_invites_public.group_invites TO authenticated;

GRANT DELETE ON TABLE dashboard_invites_public.group_invites TO authenticated;

CREATE POLICY auth_ins ON dashboard_invites_public.group_invites FOR INSERT TO authenticated WITH CHECK ( sender_id = jwt_public.current_user_id() );

CREATE POLICY auth_ins_create_invite_check ON dashboard_invites_public.group_invites AS RESTRICTIVE FOR INSERT TO authenticated WITH CHECK ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000000010') = '00000000000000000000000000000010') );

CREATE POLICY auth_sel ON dashboard_invites_public.group_invites FOR SELECT TO authenticated USING ( sender_id = jwt_public.current_user_id() );

CREATE POLICY auth_upd ON dashboard_invites_public.group_invites FOR UPDATE TO authenticated USING ( sender_id = jwt_public.current_user_id() );

CREATE POLICY auth_del ON dashboard_invites_public.group_invites FOR DELETE TO authenticated USING ( sender_id = jwt_public.current_user_id() );

ALTER TABLE dashboard_invites_public.group_claimed_invites ENABLE ROW LEVEL SECURITY;

GRANT SELECT ON TABLE dashboard_invites_public.group_claimed_invites TO authenticated;

CREATE POLICY auth_sel_sender ON dashboard_invites_public.group_claimed_invites FOR SELECT TO authenticated USING ( sender_id = jwt_public.current_user_id() );

CREATE POLICY auth_sel_receiver ON dashboard_invites_public.group_claimed_invites FOR SELECT TO authenticated USING ( receiver_id = jwt_public.current_user_id() );

CREATE POLICY auth_sel_members ON dashboard_invites_public.group_invites FOR SELECT TO authenticated USING ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000000100') = '00000000000000000000000000000100') );

CREATE POLICY auth_del_members ON dashboard_invites_public.group_invites FOR DELETE TO authenticated USING ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE) );

CREATE POLICY auth_sel_members ON dashboard_invites_public.group_claimed_invites FOR SELECT TO authenticated USING ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000000100') = '00000000000000000000000000000100') );

ALTER TABLE dashboard_permissions_public.app_permissions ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_permissions_public.app_permissions TO authenticated;

GRANT SELECT ON TABLE dashboard_permissions_public.app_permissions TO authenticated;

GRANT UPDATE ON TABLE dashboard_permissions_public.app_permissions TO authenticated;

GRANT DELETE ON TABLE dashboard_permissions_public.app_permissions TO authenticated;

CREATE POLICY auth_sel ON dashboard_permissions_public.app_permissions FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_permissions_public.app_permissions FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000010000000') = '00000000000000000000000010000000') );

CREATE POLICY auth_upd ON dashboard_permissions_public.app_permissions FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000010000000') = '00000000000000000000000010000000') );

CREATE POLICY auth_del ON dashboard_permissions_public.app_permissions FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000010000000') = '00000000000000000000000010000000') );

ALTER TABLE dashboard_permissions_public.app_permission_defaults ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_permissions_public.app_permission_defaults TO authenticated;

GRANT SELECT ON TABLE dashboard_permissions_public.app_permission_defaults TO authenticated;

GRANT UPDATE ON TABLE dashboard_permissions_public.app_permission_defaults TO authenticated;

GRANT DELETE ON TABLE dashboard_permissions_public.app_permission_defaults TO authenticated;

CREATE POLICY auth_sel ON dashboard_permissions_public.app_permission_defaults FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_permissions_public.app_permission_defaults FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000010000000') = '00000000000000000000000010000000') );

CREATE POLICY auth_upd ON dashboard_permissions_public.app_permission_defaults FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000010000000') = '00000000000000000000000010000000') );

CREATE POLICY auth_del ON dashboard_permissions_public.app_permission_defaults FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000010000000') = '00000000000000000000000010000000') );

ALTER TABLE dashboard_limits_public.app_limits ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_limits_public.app_limits TO authenticated;

GRANT SELECT ON TABLE dashboard_limits_public.app_limits TO authenticated;

GRANT UPDATE ON TABLE dashboard_limits_public.app_limits TO authenticated;

GRANT DELETE ON TABLE dashboard_limits_public.app_limits TO authenticated;

CREATE POLICY auth_ins ON dashboard_limits_public.app_limits FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000001000000') = '00000000000000000000000001000000') );

CREATE POLICY auth_sel ON dashboard_limits_public.app_limits FOR SELECT TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000001000000') = '00000000000000000000000001000000') );

CREATE POLICY auth_upd ON dashboard_limits_public.app_limits FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000001000000') = '00000000000000000000000001000000') );

CREATE POLICY auth_del ON dashboard_limits_public.app_limits FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000001000000') = '00000000000000000000000001000000') );

CREATE POLICY auth_sel_own ON dashboard_limits_public.app_limits FOR SELECT TO authenticated USING ( actor_id = jwt_public.current_user_id() );

ALTER TABLE dashboard_limits_public.app_limit_defaults ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_limits_public.app_limit_defaults TO authenticated;

GRANT SELECT ON TABLE dashboard_limits_public.app_limit_defaults TO authenticated;

GRANT UPDATE ON TABLE dashboard_limits_public.app_limit_defaults TO authenticated;

GRANT DELETE ON TABLE dashboard_limits_public.app_limit_defaults TO authenticated;

CREATE POLICY auth_ins ON dashboard_limits_public.app_limit_defaults FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000001000000') = '00000000000000000000000001000000') );

CREATE POLICY auth_sel ON dashboard_limits_public.app_limit_defaults FOR SELECT TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000001000000') = '00000000000000000000000001000000') );

CREATE POLICY auth_upd ON dashboard_limits_public.app_limit_defaults FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000001000000') = '00000000000000000000000001000000') );

CREATE POLICY auth_del ON dashboard_limits_public.app_limit_defaults FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000001000000') = '00000000000000000000000001000000') );

ALTER TABLE dashboard_memberships_public.app_memberships ENABLE ROW LEVEL SECURITY;

GRANT SELECT ON TABLE dashboard_memberships_public.app_memberships TO authenticated;

GRANT UPDATE ( is_banned, is_approved, is_verified, is_disabled, granted ) ON TABLE dashboard_memberships_public.app_memberships TO authenticated;

CREATE POLICY auth_sel ON dashboard_memberships_public.app_memberships FOR SELECT TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000000001') = '00000000000000000000000000000001') );

CREATE POLICY auth_upd ON dashboard_memberships_public.app_memberships FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000000001') = '00000000000000000000000000000001') );

CREATE POLICY auth_del ON dashboard_memberships_public.app_memberships FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000000001') = '00000000000000000000000000000001') );

CREATE POLICY auth_sel_own ON dashboard_memberships_public.app_memberships FOR SELECT TO authenticated USING ( actor_id = jwt_public.current_user_id() );

ALTER TABLE dashboard_memberships_public.app_membership_defaults ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_memberships_public.app_membership_defaults TO authenticated;

GRANT SELECT ON TABLE dashboard_memberships_public.app_membership_defaults TO authenticated;

GRANT UPDATE ON TABLE dashboard_memberships_public.app_membership_defaults TO authenticated;

GRANT DELETE ON TABLE dashboard_memberships_public.app_membership_defaults TO authenticated;

CREATE POLICY auth_ins ON dashboard_memberships_public.app_membership_defaults FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000000001') = '00000000000000000000000000000001') );

CREATE POLICY auth_sel ON dashboard_memberships_public.app_membership_defaults FOR SELECT TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000000001') = '00000000000000000000000000000001') );

CREATE POLICY auth_upd ON dashboard_memberships_public.app_membership_defaults FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000000001') = '00000000000000000000000000000001') );

CREATE POLICY auth_del ON dashboard_memberships_public.app_membership_defaults FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000000001') = '00000000000000000000000000000001') );

ALTER TABLE dashboard_memberships_public.app_grants ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_memberships_public.app_grants TO authenticated;

GRANT SELECT ON TABLE dashboard_memberships_public.app_grants TO authenticated;

CREATE POLICY auth_ins ON dashboard_memberships_public.app_grants FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000000001') = '00000000000000000000000000000001') );

CREATE POLICY auth_sel ON dashboard_memberships_public.app_grants FOR SELECT TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000000001') = '00000000000000000000000000000001') );

ALTER TABLE dashboard_memberships_public.app_admin_grants ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_memberships_public.app_admin_grants TO authenticated;

GRANT SELECT ON TABLE dashboard_memberships_public.app_admin_grants TO authenticated;

CREATE POLICY auth_ins ON dashboard_memberships_public.app_admin_grants FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE) );

CREATE POLICY auth_sel ON dashboard_memberships_public.app_admin_grants FOR SELECT TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE) );

ALTER TABLE dashboard_memberships_public.app_owner_grants ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_memberships_public.app_owner_grants TO authenticated;

GRANT SELECT ON TABLE dashboard_memberships_public.app_owner_grants TO authenticated;

CREATE POLICY auth_ins ON dashboard_memberships_public.app_owner_grants FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_owner IS TRUE) );

CREATE POLICY auth_sel ON dashboard_memberships_public.app_owner_grants FOR SELECT TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_owner IS TRUE) );

ALTER TABLE dashboard_status_public.app_steps ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_status_public.app_steps TO authenticated;

GRANT SELECT ON TABLE dashboard_status_public.app_steps TO authenticated;

GRANT UPDATE ON TABLE dashboard_status_public.app_steps TO authenticated;

GRANT DELETE ON TABLE dashboard_status_public.app_steps TO authenticated;

CREATE POLICY auth_sel ON dashboard_status_public.app_steps FOR SELECT TO authenticated USING ( actor_id = jwt_public.current_user_id() );

ALTER TABLE dashboard_status_public.app_achievements ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_status_public.app_achievements TO authenticated;

GRANT SELECT ON TABLE dashboard_status_public.app_achievements TO authenticated;

GRANT UPDATE ON TABLE dashboard_status_public.app_achievements TO authenticated;

GRANT DELETE ON TABLE dashboard_status_public.app_achievements TO authenticated;

CREATE POLICY auth_sel ON dashboard_status_public.app_achievements FOR SELECT TO authenticated USING ( TRUE );

ALTER TABLE dashboard_status_public.app_levels ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_status_public.app_levels TO authenticated;

GRANT SELECT ON TABLE dashboard_status_public.app_levels TO authenticated;

GRANT UPDATE ON TABLE dashboard_status_public.app_levels TO authenticated;

GRANT DELETE ON TABLE dashboard_status_public.app_levels TO authenticated;

CREATE POLICY auth_sel ON dashboard_status_public.app_levels FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_status_public.app_levels FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000100000000') = '00000000000000000000000100000000') );

CREATE POLICY auth_upd ON dashboard_status_public.app_levels FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000100000000') = '00000000000000000000000100000000') );

CREATE POLICY auth_del ON dashboard_status_public.app_levels FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000100000000') = '00000000000000000000000100000000') );

ALTER TABLE dashboard_status_public.app_level_requirements ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_status_public.app_level_requirements TO authenticated;

GRANT SELECT ON TABLE dashboard_status_public.app_level_requirements TO authenticated;

GRANT UPDATE ON TABLE dashboard_status_public.app_level_requirements TO authenticated;

GRANT DELETE ON TABLE dashboard_status_public.app_level_requirements TO authenticated;

CREATE POLICY auth_sel ON dashboard_status_public.app_level_requirements FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_status_public.app_level_requirements FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000100000000') = '00000000000000000000000100000000') );

CREATE POLICY auth_upd ON dashboard_status_public.app_level_requirements FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000100000000') = '00000000000000000000000100000000') );

CREATE POLICY auth_del ON dashboard_status_public.app_level_requirements FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000100000000') = '00000000000000000000000100000000') );

ALTER TABLE dashboard_permissions_public.membership_permissions ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_permissions_public.membership_permissions TO authenticated;

GRANT SELECT ON TABLE dashboard_permissions_public.membership_permissions TO authenticated;

GRANT UPDATE ON TABLE dashboard_permissions_public.membership_permissions TO authenticated;

GRANT DELETE ON TABLE dashboard_permissions_public.membership_permissions TO authenticated;

CREATE POLICY auth_sel ON dashboard_permissions_public.membership_permissions FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_permissions_public.membership_permissions FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000010000000') = '00000000000000000000000010000000') );

CREATE POLICY auth_upd ON dashboard_permissions_public.membership_permissions FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000010000000') = '00000000000000000000000010000000') );

CREATE POLICY auth_del ON dashboard_permissions_public.membership_permissions FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000010000000') = '00000000000000000000000010000000') );

ALTER TABLE dashboard_permissions_public.membership_permission_defaults ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_permissions_public.membership_permission_defaults TO authenticated;

GRANT SELECT ON TABLE dashboard_permissions_public.membership_permission_defaults TO authenticated;

GRANT UPDATE ON TABLE dashboard_permissions_public.membership_permission_defaults TO authenticated;

GRANT DELETE ON TABLE dashboard_permissions_public.membership_permission_defaults TO authenticated;

CREATE POLICY auth_ins ON dashboard_permissions_public.membership_permission_defaults FOR INSERT TO authenticated WITH CHECK ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000010000000') = '00000000000000000000000010000000') );

CREATE POLICY auth_sel ON dashboard_permissions_public.membership_permission_defaults FOR SELECT TO authenticated USING ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000010000000') = '00000000000000000000000010000000') );

CREATE POLICY auth_upd ON dashboard_permissions_public.membership_permission_defaults FOR UPDATE TO authenticated USING ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000010000000') = '00000000000000000000000010000000') );

CREATE POLICY auth_del ON dashboard_permissions_public.membership_permission_defaults FOR DELETE TO authenticated USING ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000010000000') = '00000000000000000000000010000000') );

ALTER TABLE dashboard_limits_public.membership_limits ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_limits_public.membership_limits TO authenticated;

GRANT SELECT ON TABLE dashboard_limits_public.membership_limits TO authenticated;

GRANT UPDATE ON TABLE dashboard_limits_public.membership_limits TO authenticated;

GRANT DELETE ON TABLE dashboard_limits_public.membership_limits TO authenticated;

CREATE POLICY auth_ins ON dashboard_limits_public.membership_limits FOR INSERT TO authenticated WITH CHECK ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000000001') = '00000000000000000000000000000001') );

CREATE POLICY auth_sel ON dashboard_limits_public.membership_limits FOR SELECT TO authenticated USING ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000000001') = '00000000000000000000000000000001') );

CREATE POLICY auth_upd ON dashboard_limits_public.membership_limits FOR UPDATE TO authenticated USING ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000000001') = '00000000000000000000000000000001') );

CREATE POLICY auth_del ON dashboard_limits_public.membership_limits FOR DELETE TO authenticated USING ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000000001') = '00000000000000000000000000000001') );

CREATE POLICY auth_sel_own ON dashboard_limits_public.membership_limits FOR SELECT TO authenticated USING ( actor_id = jwt_public.current_user_id() );

ALTER TABLE dashboard_limits_public.membership_limit_defaults ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_limits_public.membership_limit_defaults TO authenticated;

GRANT SELECT ON TABLE dashboard_limits_public.membership_limit_defaults TO authenticated;

GRANT UPDATE ON TABLE dashboard_limits_public.membership_limit_defaults TO authenticated;

GRANT DELETE ON TABLE dashboard_limits_public.membership_limit_defaults TO authenticated;

CREATE POLICY auth_ins ON dashboard_limits_public.membership_limit_defaults FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000001000000') = '00000000000000000000000001000000') );

CREATE POLICY auth_sel ON dashboard_limits_public.membership_limit_defaults FOR SELECT TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000001000000') = '00000000000000000000000001000000') );

CREATE POLICY auth_upd ON dashboard_limits_public.membership_limit_defaults FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000001000000') = '00000000000000000000000001000000') );

CREATE POLICY auth_del ON dashboard_limits_public.membership_limit_defaults FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000001000000') = '00000000000000000000000001000000') );

ALTER TABLE dashboard_memberships_public.members ENABLE ROW LEVEL SECURITY;

GRANT SELECT ON TABLE dashboard_memberships_public.members TO authenticated;

CREATE POLICY auth_sel ON dashboard_memberships_public.members FOR SELECT TO authenticated USING ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id()) );

ALTER TABLE dashboard_memberships_public.memberships ENABLE ROW LEVEL SECURITY;

GRANT SELECT ON TABLE dashboard_memberships_public.memberships TO authenticated;

GRANT DELETE ON TABLE dashboard_memberships_public.memberships TO authenticated;

GRANT INSERT ( actor_id, entity_id ) ON TABLE dashboard_memberships_public.memberships TO authenticated;

GRANT UPDATE ( is_banned, is_approved, is_disabled, granted ) ON TABLE dashboard_memberships_public.memberships TO authenticated;

CREATE POLICY auth_ins ON dashboard_memberships_public.memberships FOR INSERT TO authenticated WITH CHECK ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000000001') = '00000000000000000000000000000001') );

CREATE POLICY auth_sel ON dashboard_memberships_public.memberships FOR SELECT TO authenticated USING ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000000001') = '00000000000000000000000000000001') );

CREATE POLICY auth_upd ON dashboard_memberships_public.memberships FOR UPDATE TO authenticated USING ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000000001') = '00000000000000000000000000000001') );

CREATE POLICY auth_del ON dashboard_memberships_public.memberships FOR DELETE TO authenticated USING ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000000001') = '00000000000000000000000000000001') );

CREATE POLICY auth_ins_own ON dashboard_memberships_public.memberships FOR INSERT TO authenticated WITH CHECK ( actor_id = jwt_public.current_user_id() );

CREATE POLICY auth_sel_own ON dashboard_memberships_public.memberships FOR SELECT TO authenticated USING ( actor_id = jwt_public.current_user_id() );

CREATE POLICY auth_del_delete_own ON dashboard_memberships_public.memberships FOR DELETE TO authenticated USING ( actor_id = jwt_public.current_user_id() AND is_banned IS FALSE );

ALTER TABLE dashboard_memberships_public.membership_defaults ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_memberships_public.membership_defaults TO authenticated;

GRANT SELECT ON TABLE dashboard_memberships_public.membership_defaults TO authenticated;

GRANT UPDATE ON TABLE dashboard_memberships_public.membership_defaults TO authenticated;

GRANT DELETE ON TABLE dashboard_memberships_public.membership_defaults TO authenticated;

CREATE POLICY auth_ins ON dashboard_memberships_public.membership_defaults FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000000001') = '00000000000000000000000000000001') );

CREATE POLICY auth_sel ON dashboard_memberships_public.membership_defaults FOR SELECT TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000000001') = '00000000000000000000000000000001') );

CREATE POLICY auth_upd ON dashboard_memberships_public.membership_defaults FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000000001') = '00000000000000000000000000000001') );

CREATE POLICY auth_del ON dashboard_memberships_public.membership_defaults FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000000001') = '00000000000000000000000000000001') );

ALTER TABLE dashboard_memberships_public.grants ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_memberships_public.grants TO authenticated;

GRANT SELECT ON TABLE dashboard_memberships_public.grants TO authenticated;

CREATE POLICY auth_ins ON dashboard_memberships_public.grants FOR INSERT TO authenticated WITH CHECK ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000000001') = '00000000000000000000000000000001') );

CREATE POLICY auth_sel ON dashboard_memberships_public.grants FOR SELECT TO authenticated USING ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000000001') = '00000000000000000000000000000001') );

ALTER TABLE dashboard_memberships_public.admin_grants ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_memberships_public.admin_grants TO authenticated;

GRANT SELECT ON TABLE dashboard_memberships_public.admin_grants TO authenticated;

CREATE POLICY auth_ins ON dashboard_memberships_public.admin_grants FOR INSERT TO authenticated WITH CHECK ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE) );

CREATE POLICY auth_sel ON dashboard_memberships_public.admin_grants FOR SELECT TO authenticated USING ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE) );

ALTER TABLE dashboard_memberships_public.owner_grants ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_memberships_public.owner_grants TO authenticated;

GRANT SELECT ON TABLE dashboard_memberships_public.owner_grants TO authenticated;

CREATE POLICY auth_ins ON dashboard_memberships_public.owner_grants FOR INSERT TO authenticated WITH CHECK ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_owner IS TRUE) );

CREATE POLICY auth_sel ON dashboard_memberships_public.owner_grants FOR SELECT TO authenticated USING ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_owner IS TRUE) );

ALTER TABLE dashboard_public.groups ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.groups TO authenticated;

GRANT SELECT ON TABLE dashboard_public.groups TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.groups TO authenticated;

GRANT DELETE ON TABLE dashboard_public.groups TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.groups FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_public.groups FOR INSERT TO authenticated WITH CHECK ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000100000') = '00000000000000000000000000100000') );

CREATE POLICY auth_upd ON dashboard_public.groups FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_del ON dashboard_public.groups FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_owner IS TRUE) );

ALTER TABLE dashboard_permissions_public.group_member_permissions ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_permissions_public.group_member_permissions TO authenticated;

GRANT SELECT ON TABLE dashboard_permissions_public.group_member_permissions TO authenticated;

GRANT UPDATE ON TABLE dashboard_permissions_public.group_member_permissions TO authenticated;

GRANT DELETE ON TABLE dashboard_permissions_public.group_member_permissions TO authenticated;

CREATE POLICY auth_sel ON dashboard_permissions_public.group_member_permissions FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_permissions_public.group_member_permissions FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000010000000') = '00000000000000000000000010000000') );

CREATE POLICY auth_upd ON dashboard_permissions_public.group_member_permissions FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000010000000') = '00000000000000000000000010000000') );

CREATE POLICY auth_del ON dashboard_permissions_public.group_member_permissions FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000010000000') = '00000000000000000000000010000000') );

ALTER TABLE dashboard_permissions_public.group_member_permission_defaults ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_permissions_public.group_member_permission_defaults TO authenticated;

GRANT SELECT ON TABLE dashboard_permissions_public.group_member_permission_defaults TO authenticated;

GRANT UPDATE ON TABLE dashboard_permissions_public.group_member_permission_defaults TO authenticated;

GRANT DELETE ON TABLE dashboard_permissions_public.group_member_permission_defaults TO authenticated;

CREATE POLICY auth_ins ON dashboard_permissions_public.group_member_permission_defaults FOR INSERT TO authenticated WITH CHECK ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000100000') = '00000000000000000000000000100000') );

CREATE POLICY auth_sel ON dashboard_permissions_public.group_member_permission_defaults FOR SELECT TO authenticated USING ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000100000') = '00000000000000000000000000100000') );

CREATE POLICY auth_upd ON dashboard_permissions_public.group_member_permission_defaults FOR UPDATE TO authenticated USING ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000100000') = '00000000000000000000000000100000') );

CREATE POLICY auth_del ON dashboard_permissions_public.group_member_permission_defaults FOR DELETE TO authenticated USING ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000100000') = '00000000000000000000000000100000') );

ALTER TABLE dashboard_limits_public.group_member_limits ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_limits_public.group_member_limits TO authenticated;

GRANT SELECT ON TABLE dashboard_limits_public.group_member_limits TO authenticated;

GRANT UPDATE ON TABLE dashboard_limits_public.group_member_limits TO authenticated;

GRANT DELETE ON TABLE dashboard_limits_public.group_member_limits TO authenticated;

CREATE POLICY auth_ins ON dashboard_limits_public.group_member_limits FOR INSERT TO authenticated WITH CHECK ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000010000') = '00000000000000000000000000010000') );

CREATE POLICY auth_sel ON dashboard_limits_public.group_member_limits FOR SELECT TO authenticated USING ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000010000') = '00000000000000000000000000010000') );

CREATE POLICY auth_upd ON dashboard_limits_public.group_member_limits FOR UPDATE TO authenticated USING ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000010000') = '00000000000000000000000000010000') );

CREATE POLICY auth_del ON dashboard_limits_public.group_member_limits FOR DELETE TO authenticated USING ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000010000') = '00000000000000000000000000010000') );

CREATE POLICY auth_sel_own ON dashboard_limits_public.group_member_limits FOR SELECT TO authenticated USING ( actor_id = jwt_public.current_user_id() );

ALTER TABLE dashboard_limits_public.group_member_limit_defaults ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_limits_public.group_member_limit_defaults TO authenticated;

GRANT SELECT ON TABLE dashboard_limits_public.group_member_limit_defaults TO authenticated;

GRANT UPDATE ON TABLE dashboard_limits_public.group_member_limit_defaults TO authenticated;

GRANT DELETE ON TABLE dashboard_limits_public.group_member_limit_defaults TO authenticated;

CREATE POLICY auth_ins ON dashboard_limits_public.group_member_limit_defaults FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000001000000') = '00000000000000000000000001000000') );

CREATE POLICY auth_sel ON dashboard_limits_public.group_member_limit_defaults FOR SELECT TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000001000000') = '00000000000000000000000001000000') );

CREATE POLICY auth_upd ON dashboard_limits_public.group_member_limit_defaults FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000001000000') = '00000000000000000000000001000000') );

CREATE POLICY auth_del ON dashboard_limits_public.group_member_limit_defaults FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000001000000') = '00000000000000000000000001000000') );

ALTER TABLE dashboard_memberships_public.group_members ENABLE ROW LEVEL SECURITY;

GRANT SELECT ON TABLE dashboard_memberships_public.group_members TO authenticated;

CREATE POLICY auth_sel ON dashboard_memberships_public.group_members FOR SELECT TO authenticated USING ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id()) );

ALTER TABLE dashboard_memberships_public.group_memberships ENABLE ROW LEVEL SECURITY;

GRANT SELECT ON TABLE dashboard_memberships_public.group_memberships TO authenticated;

GRANT DELETE ON TABLE dashboard_memberships_public.group_memberships TO authenticated;

GRANT INSERT ( actor_id, entity_id ) ON TABLE dashboard_memberships_public.group_memberships TO authenticated;

GRANT UPDATE ( is_banned, is_approved, is_disabled, granted ) ON TABLE dashboard_memberships_public.group_memberships TO authenticated;

CREATE POLICY auth_ins ON dashboard_memberships_public.group_memberships FOR INSERT TO authenticated WITH CHECK ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000000001') = '00000000000000000000000000000001') );

CREATE POLICY auth_sel ON dashboard_memberships_public.group_memberships FOR SELECT TO authenticated USING ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000000001') = '00000000000000000000000000000001') );

CREATE POLICY auth_upd ON dashboard_memberships_public.group_memberships FOR UPDATE TO authenticated USING ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000000001') = '00000000000000000000000000000001') );

CREATE POLICY auth_del ON dashboard_memberships_public.group_memberships FOR DELETE TO authenticated USING ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000000001') = '00000000000000000000000000000001') );

CREATE POLICY auth_ins_own ON dashboard_memberships_public.group_memberships FOR INSERT TO authenticated WITH CHECK ( actor_id = jwt_public.current_user_id() );

CREATE POLICY auth_sel_own ON dashboard_memberships_public.group_memberships FOR SELECT TO authenticated USING ( actor_id = jwt_public.current_user_id() );

CREATE POLICY auth_del_delete_own ON dashboard_memberships_public.group_memberships FOR DELETE TO authenticated USING ( actor_id = jwt_public.current_user_id() AND is_banned IS FALSE );

ALTER TABLE dashboard_memberships_public.group_membership_defaults ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_memberships_public.group_membership_defaults TO authenticated;

GRANT SELECT ON TABLE dashboard_memberships_public.group_membership_defaults TO authenticated;

GRANT UPDATE ON TABLE dashboard_memberships_public.group_membership_defaults TO authenticated;

GRANT DELETE ON TABLE dashboard_memberships_public.group_membership_defaults TO authenticated;

CREATE POLICY auth_ins ON dashboard_memberships_public.group_membership_defaults FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_sel ON dashboard_memberships_public.group_membership_defaults FOR SELECT TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_upd ON dashboard_memberships_public.group_membership_defaults FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_del ON dashboard_memberships_public.group_membership_defaults FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

ALTER TABLE dashboard_memberships_public.group_grants ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_memberships_public.group_grants TO authenticated;

GRANT SELECT ON TABLE dashboard_memberships_public.group_grants TO authenticated;

CREATE POLICY auth_ins ON dashboard_memberships_public.group_grants FOR INSERT TO authenticated WITH CHECK ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000000001') = '00000000000000000000000000000001') );

CREATE POLICY auth_sel ON dashboard_memberships_public.group_grants FOR SELECT TO authenticated USING ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000000001') = '00000000000000000000000000000001') );

ALTER TABLE dashboard_memberships_public.group_admin_grants ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_memberships_public.group_admin_grants TO authenticated;

GRANT SELECT ON TABLE dashboard_memberships_public.group_admin_grants TO authenticated;

CREATE POLICY auth_ins ON dashboard_memberships_public.group_admin_grants FOR INSERT TO authenticated WITH CHECK ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE) );

CREATE POLICY auth_sel ON dashboard_memberships_public.group_admin_grants FOR SELECT TO authenticated USING ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE) );

ALTER TABLE dashboard_memberships_public.group_owner_grants ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_memberships_public.group_owner_grants TO authenticated;

GRANT SELECT ON TABLE dashboard_memberships_public.group_owner_grants TO authenticated;

CREATE POLICY auth_ins ON dashboard_memberships_public.group_owner_grants FOR INSERT TO authenticated WITH CHECK ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_owner IS TRUE) );

CREATE POLICY auth_sel ON dashboard_memberships_public.group_owner_grants FOR SELECT TO authenticated USING ( entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_owner IS TRUE) );

CREATE TABLE dashboard_roles_public.audit_logs (
  
);

ALTER TABLE dashboard_roles_public.audit_logs DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_roles_public.audit_logs ADD COLUMN  id uuid;

ALTER TABLE dashboard_roles_public.audit_logs ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_roles_public.audit_logs ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_roles_public.audit_logs ADD CONSTRAINT audit_logs_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_roles_public.audit_logs ADD COLUMN  event citext;

ALTER TABLE dashboard_roles_public.audit_logs ALTER COLUMN event SET NOT NULL;

ALTER TABLE dashboard_roles_public.audit_logs ADD COLUMN  actor_id uuid;

ALTER TABLE dashboard_roles_public.audit_logs ALTER COLUMN actor_id SET NOT NULL;

ALTER TABLE dashboard_roles_public.audit_logs ALTER COLUMN actor_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_roles_public.audit_logs ADD COLUMN  origin origin;

ALTER TABLE dashboard_roles_public.audit_logs ALTER COLUMN origin SET DEFAULT jwt_public.current_origin();

ALTER TABLE dashboard_roles_public.audit_logs ADD COLUMN  user_agent text;

ALTER TABLE dashboard_roles_public.audit_logs ALTER COLUMN user_agent SET DEFAULT jwt_public.current_user_agent();

ALTER TABLE dashboard_roles_public.audit_logs ADD COLUMN  ip_address inet;

ALTER TABLE dashboard_roles_public.audit_logs ALTER COLUMN ip_address SET DEFAULT jwt_public.current_ip_address();

CREATE INDEX audit_logs_event_idx ON dashboard_roles_public.audit_logs ( event );

ALTER TABLE dashboard_roles_public.audit_logs ADD CONSTRAINT audit_logs_actor_id_fkey FOREIGN KEY ( actor_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

ALTER TABLE dashboard_roles_public.audit_logs ADD COLUMN  success bool;

ALTER TABLE dashboard_roles_public.audit_logs ALTER COLUMN success SET NOT NULL;

ALTER TABLE dashboard_roles_public.audit_logs ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_roles_public.audit_logs ALTER COLUMN created_at SET NOT NULL;

ALTER TABLE dashboard_roles_public.audit_logs ALTER COLUMN created_at SET DEFAULT CURRENT_TIMESTAMP;

ALTER TABLE dashboard_roles_public.audit_logs ENABLE ROW LEVEL SECURITY;

GRANT SELECT ON TABLE dashboard_roles_public.audit_logs TO authenticated;

CREATE POLICY auth_sel ON dashboard_roles_public.audit_logs FOR SELECT TO authenticated USING ( actor_id = jwt_public.current_user_id() );

CREATE FUNCTION dashboard_roles_public.check_password ( password text ) RETURNS void AS $EOFCODE$
BEGIN
  IF (password IS NULL) THEN 
    RAISE EXCEPTION 'PASSWORD_LEN';
  END IF;
  password = trim(password);
  IF (character_length(password) <= 7 OR character_length(password) >= 64) THEN 
    RAISE EXCEPTION 'PASSWORD_LEN';
  END IF;
  IF (password::citext = ANY (ARRAY[
'123456',
'password',
'12345678',
'qwerty',
'123456789',
'12345',
'1234',
'111111',
'1234567',
'dragon',
'123123',
'baseball',
'abc123',
'football',
'monkey',
'letmein',
'696969',
'shadow',
'master',
'666666',
'qwertyuiop',
'123321',
'mustang',
'1234567890',
'michael',
'654321',
'pussy',
'superman',
'1qaz2wsx',
'7777777',
'fuckyou',
'121212',
'000000',
'qazwsx',
'123qwe',
'killer',
'trustno1',
'jordan',
'jennifer',
'zxcvbnm',
'asdfgh',
'hunter',
'buster',
'soccer',
'harley',
'batman',
'andrew',
'tigger',
'sunshine',
'iloveyou',
'fuckme',
'2000',
'charlie',
'robert',
'thomas',
'hockey',
'ranger',
'daniel',
'starwars',
'klaster',
'112233',
'george',
'asshole',
'computer',
'michelle',
'jessica',
'pepper',
'1111',
'zxcvbn',
'555555',
'11111111',
'131313',
'freedom',
'777777',
'pass',
'fuck',
'maggie',
'159753',
'aaaaaa',
'ginger',
'princess',
'joshua',
'cheese',
'amanda',
'summer',
'love',
'ashley',
'6969',
'nicole',
'chelsea',
'biteme',
'matthew',
'access',
'yankees',
'987654321',
'dallas',
'austin',
'thunder',
'taylor',
'matrix',
'corvette',
'hello',
'martin',
'heather',
'secret',
'YourNan',
'merlin',
'diamond',
'1234qwer',
'gfhjkm',
'hammer',
'silver',
'222222',
'88888888',
'anthony',
'justin',
'test',
'bailey',
'q1w2e3r4t5',
'patrick',
'internet',
'scooter',
'orange',
'11111',
'golfer',
'cookie',
'richard',
'samantha',
'bigdog',
'guitar',
'jackson',
'whatever',
'mickey',
'chicken',
'sparky',
'snoopy',
'maverick',
'phoenix',
'camaro',
'sexy',
'peanut',
'morgan',
'welcome',
'falcon',
'cowboy',
'ferrari',
'samsung',
'andrea',
'smokey',
'steelers',
'joseph',
'mercedes',
'dakota',
'arsenal',
'eagles',
'melissa',
'boomer',
'booboo',
'spider',
'nascar',
'monster',
'tigers',
'yellow',
'xxxxxx',
'123123123',
'gateway',
'marina',
'diablo',
'bulldog',
'qwer1234',
'compaq',
'purple',
'hardcore',
'banana',
'junior',
'hannah',
'123654',
'porsche',
'lakers',
'iceman',
'money',
'cowboys',
'987654',
'london',
'tennis',
'999999',
'ncc1701',
'coffee',
'scooby',
'0000',
'miller',
'boston',
'q1w2e3r4',
'fuckoff',
'brandon',
'yamaha',
'chester',
'mother',
'forever',
'johnny',
'edward',
'333333',
'oliver',
'redsox',
'player',
'nikita',
'knight',
'fender',
'barney',
'midnight',
'please',
'brandy',
'chicago',
'badboy',
'iwantu',
'slayer',
'rangers',
'charles',
'angel',
'flower',
'bigdaddy',
'rabbit',
'wizard',
'bigdick',
'jasper',
'enter',
'rachel',
'chris',
'steven',
'winner',
'adidas',
'victoria',
'natasha',
'1q2w3e4r',
'jasmine',
'winter',
'prince',
'panties',
'marine',
'ghbdtn',
'fishing',
'cocacola',
'casper',
'james',
'232323',
'raiders',
'888888',
'marlboro',
'gandalf',
'asdfasdf',
'crystal',
'87654321',
'12344321',
'sexsex',
'golden',
'blowme',
'bigtits',
'8675309',
'panther',
'lauren',
'angela',
'bitch',
'spanky',
'thx1138',
'angels',
'madison',
'winston',
'shannon',
'mike',
'toyota',
'blowjob',
'jordan23',
'canada',
'sophie',
'Password',
'apples',
'dick',
'tiger',
'razz',
'123abc',
'pokemon',
'qazxsw',
'55555',
'qwaszx',
'muffin',
'johnson',
'murphy',
'cooper',
'jonathan',
'liverpoo',
'david',
'danielle',
'159357',
'jackie',
'1990',
'123456a',
'789456',
'turtle',
'horny',
'abcd1234',
'scorpion',
'qazwsxedc',
'101010',
'butter',
'carlos',
'password1',
'dennis',
'slipknot',
'qwerty123',
'booger',
'asdf',
'1991',
'black',
'startrek',
'12341234',
'cameron',
'newyork',
'rainbow',
'nathan',
'john',
'1992',
'rocket',
'viking',
'redskins',
'butthead',
'asdfghjkl',
'1212',
'sierra',
'peaches',
'gemini',
'doctor',
'wilson',
'sandra',
'helpme',
'qwertyui',
'victor',
'florida',
'dolphin',
'pookie',
'captain',
'tucker',
'blue',
'liverpool',
'theman',
'bandit',
'dolphins',
'maddog',
'packers',
'jaguar',
'lovers',
'nicholas',
'united',
'tiffany',
'maxwell',
'zzzzzz',
'nirvana',
'jeremy',
'suckit',
'stupid',
'porn',
'monica',
'elephant',
'giants',
'jackass',
'hotdog',
'rosebud',
'success',
'debbie',
'mountain',
'444444',
'xxxxxxxx',
'warrior',
'1q2w3e4r5t',
'q1w2e3',
'123456q',
'albert',
'metallic',
'lucky',
'azerty',
'7777',
'shithead',
'alex',
'bond007',
'alexis',
'1111111',
'samson',
'5150',
'willie',
'scorpio',
'bonnie',
'gators',
'benjamin',
'voodoo',
'driver',
'dexter',
'2112',
'jason',
'calvin',
'freddy',
'212121',
'creative',
'12345a',
'sydney',
'rush2112',
'1989',
'asdfghjk',
'red123',
'bubba',
'4815162342',
'passw0rd',
'trouble',
'gunner',
'happy',
'fucking',
'gordon',
'legend',
'jessie',
'stella',
'qwert',
'eminem',
'arthur',
'apple',
'nissan',
'bullshit',
'bear',
'america',
'1qazxsw2',
'nothing',
'parker',
'4444',
'rebecca',
'qweqwe',
'garfield',
'01012011',
'beavis',
'69696969',
'jack',
'asdasd',
'december',
'2222',
'102030',
'252525',
'11223344',
'magic',
'apollo',
'skippy',
'315475',
'girls',
'kitten',
'golf',
'copper',
'braves',
'shelby',
'godzilla',
'beaver',
'fred',
'tomcat',
'august',
'buddy',
'airborne',
'1993',
'1988',
'lifehack',
'qqqqqq',
'brooklyn',
'animal',
'platinum',
'phantom',
'online',
'xavier',
'darkness',
'blink182',
'power',
'fish',
'green',
'789456123',
'voyager',
'police',
'travis',
'12qwaszx',
'heaven',
'snowball',
'lover',
'abcdef',
'00000',
'pakistan',
'007007',
'walter',
'playboy',
'blazer',
'cricket',
'sniper',
'hooters',
'donkey',
'willow',
'loveme',
'saturn',
'therock',
'redwings',
'bigboy',
'pumpkin',
'trinity',
'williams',
'tits',
'nintendo',
'digital',
'destiny',
'topgun',
'runner',
'marvin',
'guinness',
'chance',
'bubbles',
'testing',
'fire',
'november',
'minecraft',
'asdf1234',
'lasvegas',
'sergey',
'broncos',
'cartman',
'private',
'celtic',
'birdie',
'little',
'cassie',
'babygirl',
'donald',
'beatles',
'1313',
'dickhead',
'family',
'12121212',
'school',
'louise',
'gabriel',
'eclipse',
'fluffy',
'147258369',
'lol123',
'explorer',
'beer',
'nelson',
'flyers',
'spencer',
'scott',
'lovely',
'gibson',
'doggie',
'cherry',
'andrey',
'snickers',
'buffalo',
'pantera',
'metallica',
'member',
'carter',
'qwertyu',
'peter',
'alexande',
'steve',
'bronco',
'paradise',
'goober',
'5555',
'samuel',
'montana',
'mexico',
'dreams',
'michigan',
'cock',
'carolina',
'yankee',
'friends',
'magnum',
'surfer',
'poopoo',
'maximus',
'genius',
'cool',
'vampire',
'lacrosse',
'asd123',
'aaaa',
'christin',
'kimberly',
'speedy',
'sharon',
'carmen',
'111222',
'kristina',
'sammy',
'racing',
'ou812',
'sabrina',
'horses',
'0987654321',
'qwerty1',
'pimpin',
'baby',
'stalker',
'enigma',
'147147',
'star',
'poohbear',
'boobies',
'147258',
'simple',
'bollocks',
'12345q',
'marcus',
'brian',
'1987',
'qweasdzxc',
'drowssap',
'hahaha',
'caroline',
'barbara',
'dave',
'viper',
'drummer',
'action',
'einstein',
'bitches',
'genesis',
'hello1',
'scotty',
'friend',
'forest',
'010203',
'hotrod',
'google',
'vanessa',
'spitfire',
'badger',
'maryjane',
'friday',
'alaska',
'1232323q',
'tester',
'jester',
'jake',
'champion',
'billy',
'147852',
'rock',
'hawaii',
'badass',
'chevy',
'420420',
'walker',
'stephen',
'eagle1',
'bill',
'1986',
'october',
'gregory',
'svetlana',
'pamela',
'1984',
'music',
'shorty',
'westside',
'stanley',
'diesel',
'courtney',
'242424',
'kevin',
'porno',
'hitman',
'boobs',
'mark',
'12345qwert',
'reddog',
'frank',
'qwe123',
'popcorn',
'patricia',
'aaaaaaaa',
'1969',
'teresa',
'mozart',
'buddha',
'anderson',
'paul',
'melanie',
'abcdefg',
'security',
'lucky1',
'lizard',
'denise',
'3333',
'a12345',
'123789',
'ruslan',
'stargate',
'simpsons',
'scarface',
'eagle',
'123456789a',
'thumper',
'olivia',
'naruto',
'1234554321',
'general',
'cherokee',
'a123456',
'vincent',
'Usuckballz1',
'spooky',
'qweasd',
'cumshot',
'free',
'frankie',
'douglas',
'death',
'1980',
'loveyou',
'kitty',
'kelly',
'veronica',
'suzuki',
'semperfi',
'penguin',
'mercury',
'liberty',
'spirit',
'scotland',
'natalie',
'marley',
'vikings',
'system',
'sucker',
'king',
'allison',
'marshall',
'1979',
'098765',
'qwerty12',
'hummer',
'adrian',
'1985',
'vfhbyf',
'sandman',
'rocky',
'leslie',
'antonio',
'98765432',
'4321',
'softball',
'passion',
'mnbvcxz',
'bastard',
'passport',
'horney',
'rascal',
'howard',
'franklin',
'bigred',
'assman',
'alexander',
'homer',
'redrum',
'jupiter',
'claudia',
'55555555',
'141414',
'zaq12wsx',
'shit',
'patches',
'nigger',
'cunt',
'raider',
'infinity',
'andre',
'54321',
'galore',
'college',
'russia',
'kawasaki',
'bishop',
'77777777',
'vladimir',
'money1',
'freeuser',
'wildcats',
'francis',
'disney',
'budlight',
'brittany',
'1994',
'00000000',
'sweet',
'oksana',
'honda',
'domino',
'bulldogs',
'brutus',
'swordfis',
'norman',
'monday',
'jimmy',
'ironman',
'ford',
'fantasy',
'9999',
'7654321',
'PASSWORD',
'hentai',
'duncan',
'cougar',
'1977',
'jeffrey',
'house',
'dancer',
'brooke'
  ]::citext[])) THEN 
    RAISE EXCEPTION 'PASSWORD_INSECURE';
  END IF;
END;
$EOFCODE$ LANGUAGE plpgsql;

GRANT EXECUTE ON FUNCTION dashboard_roles_public.check_password TO PUBLIC;

CREATE FUNCTION dashboard_roles_public.login ( email text, password text, remember_me boolean DEFAULT FALSE ) RETURNS dashboard_roles_private.api_tokens AS $EOFCODE$
DECLARE
  v_token "dashboard_roles_private".api_tokens;
  v_email "dashboard_public".emails;
  v_sign_in_attempt_window_duration interval = interval '6 hours';
  v_sign_in_max_attempts int = 10;
  v_user_is_verified boolean default false;
  v_user_is_disabled boolean default false;
  v_user_is_banned boolean default false;
  first_failed_password_attempt timestamptz;
  password_attempts int;
BEGIN
  SELECT
    user_emails_alias.*
  FROM
    "dashboard_public".emails AS user_emails_alias
  WHERE
    user_emails_alias.email = login.email::email INTO v_email;
  
  IF (NOT FOUND) THEN
    RETURN NULL;
  END IF;
  first_failed_password_attempt = "dashboard_simple_secrets".get(v_email.owner_id, 'first_failed_password_attempt');
  password_attempts = "dashboard_simple_secrets".get(v_email.owner_id, 'password_attempts');
  IF (
    first_failed_password_attempt IS NOT NULL
      AND
    first_failed_password_attempt > NOW() - v_sign_in_attempt_window_duration
      AND
    password_attempts >= v_sign_in_max_attempts
  ) THEN
    RAISE EXCEPTION 'ACCOUNT_LOCKED_EXCEED_ATTEMPTS';
  END IF;
  SELECT  
      is_verified,
      is_disabled,
      is_banned
    FROM "dashboard_memberships_public".app_memberships
    WHERE actor_id = v_email.owner_id
  INTO 
    v_user_is_verified,
    v_user_is_disabled,
    v_user_is_banned;
  IF (v_user_is_disabled IS TRUE OR v_user_is_banned IS TRUE) THEN 
      RAISE EXCEPTION 'ACCOUNT_DISABLED';
  END IF;
  IF ( "dashboard_encrypted".verify(v_email.owner_id, 'password_hash', PASSWORD) ) THEN
    PERFORM "dashboard_simple_secrets".del(v_email.owner_id,
    ARRAY[
      'password_attempts', 'first_failed_password_attempt'
    ]);
    INSERT INTO "dashboard_roles_public".audit_logs 
      (actor_id, event, success)
    VALUES (
      v_email.owner_id,
      'login',
      TRUE
    );
 
    IF (remember_me IS TRUE) THEN 
      INSERT INTO "dashboard_roles_private".api_tokens (
        user_id,
        is_verified,
        last_password_verified,
        access_token_expires_at
      )
      VALUES (
        v_email.owner_id,
        v_user_is_verified,
        current_timestamp,
        ( NOW() + '1 year'::interval )
      )
      RETURNING
        * INTO v_token;
    ELSE 
      INSERT INTO "dashboard_roles_private".api_tokens (
        user_id,
        is_verified,
        last_password_verified
      )
      VALUES (
        v_email.owner_id,
        v_user_is_verified,
        current_timestamp
      )
      RETURNING
        * INTO v_token;
    END IF;
    RETURN v_token;
  ELSE
   INSERT INTO "dashboard_roles_public".audit_logs 
      (actor_id, event, success)
    VALUES (
      v_email.owner_id,
      'login',
      FALSE
    );
    IF (password_attempts IS NULL) THEN
      password_attempts = 0;
    END IF;
    IF (
      first_failed_password_attempt IS NULL
        OR
      first_failed_password_attempt < NOW() - v_sign_in_attempt_window_duration
    ) THEN
      password_attempts = 1;
      first_failed_password_attempt = NOW();
    ELSE 
      password_attempts = password_attempts + 1;
    END IF;
    PERFORM "dashboard_simple_secrets".set(v_email.owner_id, 'password_attempts', password_attempts);
    PERFORM "dashboard_simple_secrets".set(v_email.owner_id, 'first_failed_password_attempt', first_failed_password_attempt);
    RETURN NULL;
  END IF;
END;
$EOFCODE$ LANGUAGE plpgsql STRICT SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION dashboard_roles_public.login TO anonymous;

CREATE FUNCTION dashboard_roles_public.one_time_token ( email text, password text, origin origin, remember_me boolean DEFAULT FALSE ) RETURNS text AS $EOFCODE$
DECLARE
  v_token "dashboard_roles_private".api_tokens;
  v_origin origin;
BEGIN
  SELECT * FROM "dashboard_roles_public".login(
    email, password, remember_me
  ) INTO v_token;
  IF (NOT FOUND) THEN 
    RETURN NULL;
  END IF;
  UPDATE "dashboard_roles_private".api_tokens t
    SET 
      ot_token = encode( gen_random_bytes( 32 ), 'hex' ),
      origin = one_time_token.origin
  WHERE t.id = v_token.id
  RETURNING * INTO v_token;
  RETURN lower(replace(	base32.encode(v_token.ot_token), '=',''));
END;
$EOFCODE$ LANGUAGE plpgsql STRICT SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION dashboard_roles_public.one_time_token TO anonymous;

CREATE FUNCTION dashboard_roles_public.login_one_time_token ( token text ) RETURNS dashboard_roles_private.api_tokens AS $EOFCODE$
DECLARE
  v_token "dashboard_roles_private".api_tokens;
BEGIN
    SELECT * FROM "dashboard_roles_private".api_tokens tkn
    WHERE tkn.ot_token = login_one_time_token.token
          AND EXTRACT(EPOCH FROM (tkn.access_token_expires_at-NOW())) > 0
          AND 
            (
                CASE WHEN tkn.uagent IS NULL THEN jwt_public.current_user_agent() IS NULL
                ELSE tkn.uagent = jwt_public.current_user_agent() END
            )
          AND 
            (
                CASE WHEN tkn.origin IS NULL THEN jwt_public.current_origin() IS NULL
                ELSE tkn.origin = jwt_public.current_origin() END
            )
    INTO v_token;
    IF (NOT FOUND) THEN 
        RETURN NULL;
    END IF;
    UPDATE "dashboard_roles_private".api_tokens t
    SET 
      ot_token = NULL
    WHERE t.id = v_token.id
    RETURNING * INTO v_token;
    RETURN v_token;
END;
$EOFCODE$ LANGUAGE plpgsql STRICT SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION dashboard_roles_public.login_one_time_token TO anonymous;

CREATE FUNCTION dashboard_roles_public.extend_token_expires ( amount interval DEFAULT '30 minutes'::interval ) RETURNS dashboard_roles_private.api_tokens AS $EOFCODE$
DECLARE
  v_token_id uuid = jwt_private.current_token_id();
  v_token "dashboard_roles_private".api_tokens;
BEGIN
    IF (v_token_id IS NULL) THEN 
      RETURN NULL;
    END IF;
    SELECT * FROM "dashboard_roles_private".api_tokens tkn
    WHERE tkn.id = v_token_id
      AND EXTRACT(EPOCH FROM (tkn.access_token_expires_at-NOW())) > 0
      AND 
        (
            CASE WHEN tkn.uagent IS NULL THEN jwt_public.current_user_agent() IS NULL
            ELSE tkn.uagent = jwt_public.current_user_agent() END
        )
      AND 
        (
            CASE WHEN tkn.origin IS NULL THEN jwt_public.current_origin() IS NULL
            ELSE tkn.origin = jwt_public.current_origin() END
        )
    INTO v_token;
    IF (NOT FOUND) THEN 
      RETURN NULL;
    END IF;
    UPDATE "dashboard_roles_private".api_tokens t
    SET 
      access_token_expires_at = access_token_expires_at + amount
      WHERE t.id = v_token.id
    RETURNING * INTO v_token;
    RETURN v_token;
END;
$EOFCODE$ LANGUAGE plpgsql STRICT SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION dashboard_roles_public.extend_token_expires TO authenticated;

CREATE FUNCTION dashboard_roles_public.register ( email text, password text, remember_me boolean DEFAULT FALSE ) RETURNS dashboard_roles_private.api_tokens AS $EOFCODE$
DECLARE
  v_user "dashboard_public".users;
  v_email "dashboard_public".emails;
  v_token "dashboard_roles_private".api_tokens;
BEGIN
  PERFORM "dashboard_roles_public".check_password(
    password
  );
  password = trim(password);
  SELECT * FROM "dashboard_public".emails t
    WHERE trim(register.email)::email = t.email
  INTO v_email;
  IF (NOT FOUND) THEN
    INSERT INTO "dashboard_public".users
      DEFAULT VALUES
    RETURNING
      * INTO v_user;
    INSERT INTO "dashboard_public".emails (owner_id, email)
      VALUES (v_user.id, trim(register.email))
    RETURNING
      * INTO v_email;
    IF (remember_me IS TRUE) THEN 
      INSERT INTO "dashboard_roles_private".api_tokens (
        user_id,
        access_token_expires_at
      )
      VALUES (
        v_user.id,
        ( NOW() + '1 year'::interval )
      )
      RETURNING
        * INTO v_token;
    ELSE 
      INSERT INTO "dashboard_roles_private".api_tokens (
        user_id
      )
      VALUES (
        v_user.id
      )
      RETURNING
        * INTO v_token;
    END IF;
    PERFORM "dashboard_encrypted".set
      (v_user.id, 'password_hash', trim(password), 'crypt');
    RETURN v_token;
  END IF;
  RAISE EXCEPTION 'ACCOUNT_EXISTS';
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION dashboard_roles_public.register TO anonymous;

CREATE FUNCTION dashboard_roles_public.logout (  ) RETURNS void AS $EOFCODE$
DECLARE
  v_token_id uuid = jwt_private.current_token_id();
BEGIN
  IF (v_token_id IS NOT NULL) THEN 
    DELETE FROM "dashboard_roles_private".api_tokens t
      WHERE t.id = v_token_id;
  END IF;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION dashboard_roles_public.logout TO authenticated;

CREATE FUNCTION dashboard_roles_public.set_password ( current_password text, new_password text ) RETURNS boolean AS $EOFCODE$
DECLARE
  v_user "dashboard_public".users;
  v_user_secret "dashboard_simple_secrets".user_secrets;
  password_exists boolean;
BEGIN
  PERFORM "dashboard_roles_public".check_password(
    new_password
  );
  new_password = trim(new_password);
  SELECT
    u.* INTO v_user
  FROM
    "dashboard_public".users AS u
  WHERE
    id = jwt_public.current_user_id ();
  IF (NOT FOUND) THEN
    RETURN FALSE;
  END IF;
  SELECT EXISTS (
    SELECT 1
      FROM "dashboard_encrypted".user_encrypted_secrets
      WHERE owner_id=v_user.id
        AND name='password_hash'
  )
  INTO password_exists;
  IF (password_exists IS TRUE) THEN 
    IF ("dashboard_encrypted".verify(
        v_user.id,
        'password_hash',
        current_password
    ) IS FALSE) THEN 
      RAISE EXCEPTION 'INCORRECT_PASSWORD';
    END IF;
  END IF;
  INSERT INTO "dashboard_roles_public".audit_logs 
    (actor_id, event, success)
  VALUES (
    v_user.id,
    'set_password',
    TRUE
  );
  PERFORM "dashboard_encrypted".set
    (v_user.id, 'password_hash', new_password, 'crypt');
      
  RETURN TRUE;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION dashboard_roles_public.set_password TO authenticated;

CREATE FUNCTION dashboard_roles_public.reset_password ( role_id uuid, reset_token text, new_password text ) RETURNS boolean AS $EOFCODE$
DECLARE
    v_user "dashboard_public".users;
    
    v_reset_max_interval interval = interval '3 days';
    v_reset_max_attempts int = 10;
    reset_password_attempts int;
    first_failed_reset_password_attempt timestamptz;
    v_user_is_disabled boolean default false;
    v_user_is_banned boolean default false;
BEGIN
    IF (role_id IS NULL OR reset_token IS NULL OR new_password IS NULL) THEN
        RAISE EXCEPTION 'NULL_VALUES_DISALLOWED';
    END IF;
    SELECT
        u.* INTO v_user
    FROM
        "dashboard_public".users as u
    WHERE
        id = role_id;
    IF (NOT FOUND) THEN
      RETURN NULL;
    END IF;
    SELECT  
        is_disabled,
        is_banned
        FROM "dashboard_memberships_public".app_memberships
        WHERE actor_id = role_id
    INTO 
        v_user_is_disabled,
        v_user_is_banned;
    IF (v_user_is_disabled IS TRUE OR v_user_is_banned IS TRUE) THEN 
        RAISE EXCEPTION 'ACCOUNT_DISABLED';
    END IF;
    reset_password_attempts = "dashboard_simple_secrets".get(v_user.id, 'reset_password_attempts', '0');
    first_failed_reset_password_attempt = "dashboard_simple_secrets".get(v_user.id, 'first_failed_reset_password_attempt');
    IF (first_failed_reset_password_attempt IS NOT NULL
      AND NOW() < first_failed_reset_password_attempt + v_reset_max_interval
      AND reset_password_attempts >= v_reset_max_attempts) THEN
        RAISE
        EXCEPTION 'PASSWORD_RESET_LOCKED_EXCEED_ATTEMPTS';
    END IF;
    IF ("dashboard_encrypted".verify(v_user.id, 'reset_password_token', reset_token)) THEN
        PERFORM "dashboard_encrypted".set
            (v_user.id, 'password_hash', new_password, 'crypt');
        PERFORM "dashboard_simple_secrets".del(
            v_user.id,
            ARRAY[
                'password_attempts',
                'first_failed_password_attempt',
                'reset_password_token_generated',
                'reset_password_attempts',
                'first_failed_reset_password_attempt'                
            ]
        );
        PERFORM "dashboard_encrypted".del(
            v_user.id,
            'reset_password_token'
        );
        INSERT INTO "dashboard_roles_public".audit_logs 
            (actor_id, event, success)
        VALUES (
            v_user.id,
            'reset_password',
            TRUE
        );
        RETURN TRUE;
    ELSE
        INSERT INTO "dashboard_roles_public".audit_logs 
            (actor_id, event, success)
        VALUES (
            v_user.id,
            'reset_password',
            FALSE
        );
        IF (
            first_failed_reset_password_attempt IS NULL OR
            first_failed_reset_password_attempt + v_reset_max_interval < NOW() 
        ) THEN
            reset_password_attempts = 1;
            first_failed_reset_password_attempt = NOW();
        ELSE 
            reset_password_attempts = reset_password_attempts + 1;
        END IF;
        PERFORM "dashboard_simple_secrets".set(v_user.id, 'reset_password_attempts', reset_password_attempts);
        PERFORM "dashboard_simple_secrets".set(v_user.id, 'first_failed_reset_password_attempt', first_failed_reset_password_attempt);
    END IF;
    RETURN FALSE;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION dashboard_roles_public.reset_password TO anonymous;

REVOKE EXECUTE ON FUNCTION dashboard_roles_public.reset_password FROM authenticated;

CREATE FUNCTION dashboard_roles_public.verify_password ( password text ) RETURNS dashboard_roles_private.api_tokens AS $EOFCODE$
DECLARE
  v_token "dashboard_roles_private".api_tokens;
  v_sign_in_attempt_window_duration interval = interval '6 hours';
  v_sign_in_max_attempts int = 10;
  first_failed_password_attempt timestamptz;
  password_attempts int;
  vuser_id uuid;
BEGIN
  vuser_id = jwt_public.current_user_id();
  first_failed_password_attempt = "dashboard_simple_secrets".get(vuser_id, 'first_failed_password_attempt');
  password_attempts = "dashboard_simple_secrets".get(vuser_id, 'password_attempts');
  IF (
    first_failed_password_attempt IS NOT NULL
      AND
    first_failed_password_attempt > NOW() - v_sign_in_attempt_window_duration
      AND
    password_attempts >= v_sign_in_max_attempts
  ) THEN
    RAISE EXCEPTION 'ACCOUNT_LOCKED_EXCEED_ATTEMPTS';
  END IF;
  IF ( "dashboard_encrypted".verify(vuser_id, 'password_hash', PASSWORD) ) THEN
    PERFORM "dashboard_simple_secrets".del(vuser_id,
    ARRAY[
      'password_attempts', 'first_failed_password_attempt'
    ]);
    INSERT INTO "dashboard_roles_public".audit_logs 
      (actor_id, event, success)
    VALUES (
      vuser_id,
      'verify_password',
      TRUE
    );
 
    UPDATE "dashboard_roles_private".api_tokens tkn 
        SET last_password_verified = current_timestamp,
            access_token_expires_at = access_token_expires_at + '30 minutes'::interval
    WHERE tkn.id = jwt_private.current_token_id()
      AND 
        (
            CASE WHEN tkn.uagent IS NULL THEN jwt_public.current_user_agent() IS NULL
            ELSE tkn.uagent = jwt_public.current_user_agent() END
        )
      AND 
        (
            CASE WHEN tkn.origin IS NULL THEN jwt_public.current_origin() IS NULL
            ELSE tkn.origin = jwt_public.current_origin() END
        )
    RETURNING * INTO v_token;
    RETURN v_token;
  ELSE
   INSERT INTO "dashboard_roles_public".audit_logs 
      (actor_id, event, success)
    VALUES (
      vuser_id,
      'verify_password',
      FALSE
    );
    IF (password_attempts IS NULL) THEN
      password_attempts = 0;
    END IF;
    IF (
      first_failed_password_attempt IS NULL
        OR
      first_failed_password_attempt < NOW() - v_sign_in_attempt_window_duration
    ) THEN
      password_attempts = 1;
      first_failed_password_attempt = NOW();
    ELSE 
      password_attempts = password_attempts + 1;
    END IF;
    PERFORM "dashboard_simple_secrets".set(vuser_id, 'password_attempts', password_attempts);
    PERFORM "dashboard_simple_secrets".set(vuser_id, 'first_failed_password_attempt', first_failed_password_attempt);
    RETURN NULL;
  END IF;
END;
$EOFCODE$ LANGUAGE plpgsql STRICT SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION dashboard_roles_public.verify_password TO authenticated;

REVOKE EXECUTE ON FUNCTION dashboard_roles_public.verify_password FROM anonymous;

CREATE FUNCTION dashboard_roles_public.verify_totp ( totp_value text ) RETURNS dashboard_roles_private.api_tokens AS $EOFCODE$
DECLARE
  v_token "dashboard_roles_private".api_tokens;
  v_sign_in_attempt_window_duration interval = interval '6 hours';
  v_sign_in_max_attempts int = 10;
  first_failed_totp_attempt timestamptz;
  totp_attempts int;
  totp_secret text;
  vuser_id uuid;
BEGIN
  vuser_id = jwt_public.current_user_id();
  first_failed_totp_attempt = "dashboard_simple_secrets".get(vuser_id, 'first_failed_totp_attempt');
  totp_attempts = "dashboard_simple_secrets".get(vuser_id, 'totp_attempts');
  
  totp_secret = "dashboard_simple_secrets".get(vuser_id, 'totp_secret');
  IF (totp_secret IS NULL) THEN 
    RAISE EXCEPTION 'TOTP_NOT_ENABLED';
  END IF;
  IF (
    first_failed_totp_attempt IS NOT NULL
      AND
    first_failed_totp_attempt > NOW() - v_sign_in_attempt_window_duration
      AND
    totp_attempts >= v_sign_in_max_attempts
  ) THEN
    RAISE EXCEPTION 'ACCOUNT_LOCKED_EXCEED_ATTEMPTS';
  END IF;
  IF ( totp.verify(totp_secret, totp_value, 30, 6) IS TRUE ) THEN
    PERFORM "dashboard_simple_secrets".del(vuser_id,
    ARRAY[
      'totp_attempts', 'first_failed_totp_attempt'
    ]);
    INSERT INTO "dashboard_roles_public".audit_logs 
      (actor_id, event, success)
    VALUES (
      vuser_id,
      'verify_totp',
      TRUE
    );
 
    UPDATE "dashboard_roles_private".api_tokens tkn 
        SET last_totp_verified = current_timestamp,
            access_token_expires_at = access_token_expires_at + '30 minutes'::interval
    WHERE tkn.id = jwt_private.current_token_id()
      AND 
        (
            CASE WHEN tkn.uagent IS NULL THEN jwt_public.current_user_agent() IS NULL
            ELSE tkn.uagent = jwt_public.current_user_agent() END
        )
      AND 
        (
            CASE WHEN tkn.origin IS NULL THEN jwt_public.current_origin() IS NULL
            ELSE tkn.origin = jwt_public.current_origin() END
        )
    RETURNING * INTO v_token;
    RETURN v_token;
  ELSE
   INSERT INTO "dashboard_roles_public".audit_logs 
      (actor_id, event, success)
    VALUES (
      vuser_id,
      'verify_totp',
      FALSE
    );
    IF (totp_attempts IS NULL) THEN
      totp_attempts = 0;
    END IF;
    IF (
      first_failed_totp_attempt IS NULL
        OR
      first_failed_totp_attempt < NOW() - v_sign_in_attempt_window_duration
    ) THEN
      totp_attempts = 1;
      first_failed_totp_attempt = NOW();
    ELSE 
      totp_attempts = totp_attempts + 1;
    END IF;
    PERFORM "dashboard_simple_secrets".set(vuser_id, 'totp_attempts', totp_attempts);
    PERFORM "dashboard_simple_secrets".set(vuser_id, 'first_failed_totp_attempt', first_failed_totp_attempt);
    RETURN NULL;
  END IF;
END;
$EOFCODE$ LANGUAGE plpgsql STRICT SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION dashboard_roles_public.verify_totp TO authenticated;

REVOKE EXECUTE ON FUNCTION dashboard_roles_public.verify_totp FROM anonymous;

CREATE FUNCTION dashboard_roles_public.forgot_password ( email email ) RETURNS void AS $EOFCODE$
DECLARE
    v_email "dashboard_public".emails;
    v_user_id uuid;
    v_token text;
    v_min_duration_between_emails interval = interval '3 minutes';
    
    v_max_duration interval = interval '3 days';
    v_user_is_disabled boolean default false;
    v_user_is_banned boolean default false;
    password_reset_email_sent_at timestamptz;
BEGIN
    SELECT * FROM "dashboard_public".emails e
        WHERE e.email = forgot_password.email::email
    INTO v_email;
    IF (NOT FOUND) THEN
        RETURN;
    END IF;
    v_user_id = v_email.owner_id;
    SELECT  
        is_disabled,
        is_banned
        FROM "dashboard_memberships_public".app_memberships
        WHERE actor_id = v_email.owner_id
    INTO 
        v_user_is_disabled,
        v_user_is_banned;
    IF (
        v_user_is_banned IS TRUE OR v_user_is_disabled IS TRUE
        ) THEN
        RETURN;
    END IF;
    password_reset_email_sent_at = "dashboard_simple_secrets".get(v_user_id, 'password_reset_email_sent_at');
    IF (
        password_reset_email_sent_at IS NOT NULL AND
        NOW() < password_reset_email_sent_at + v_min_duration_between_emails
    ) THEN 
        RETURN;
    END IF;
    INSERT INTO "dashboard_roles_public".audit_logs 
      (actor_id, event, success)
    VALUES (
      v_email.owner_id,
      'forgot_password',
      TRUE
    );
    v_token = encode(gen_random_bytes(7), 'hex');
    PERFORM "dashboard_encrypted".set
        (v_user_id, 'reset_password_token', v_token, 'crypt');
    PERFORM "dashboard_simple_secrets".set(v_user_id, 'password_reset_email_sent_at', (NOW())::text);
    PERFORM
        app_jobs.add_job (
            jwt_private.current_database_id(),
            'send-email-link',
            json_build_object(
                'email_type', 'forgot_password',
                'user_id', v_user_id,
                'email', v_email.email::text,
                'reset_token', v_token
            ));
    RETURN;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION dashboard_roles_public.forgot_password TO anonymous;

CREATE FUNCTION dashboard_roles_public.send_verification_email ( email email ) RETURNS boolean AS $EOFCODE$
DECLARE
  v_email "dashboard_public".emails;
  v_user_id uuid;
  v_verification_token text;
  v_verification_min_duration_between_emails interval = interval '3 minutes';
  v_verification_min_duration_between_new_tokens interval = interval '10 minutes';
  verification_token_name text;
  verification_email_sent_at timestamptz;
BEGIN
  SELECT * FROM "dashboard_public".emails e
    WHERE e.email = send_verification_email.email
  INTO v_email;
  IF (NOT FOUND) THEN 
    RETURN FALSE;
  END IF;
  verification_token_name = v_email.email::text || '_verification_token';
  IF ( v_email.is_verified IS TRUE ) THEN
    PERFORM "dashboard_simple_secrets".del(v_email.owner_id, ARRAY[
        'verification_email_sent_at',
        'verification_email_attempts',
        'first_failed_verification_email_attempt'
    ]);
    PERFORM "dashboard_encrypted".del(v_email.owner_id, ARRAY[
        verification_token_name
    ]);
    RETURN FALSE;
  END IF;
  v_user_id = v_email.owner_id;
  verification_email_sent_at = "dashboard_simple_secrets".get(v_user_id, 'verification_email_sent_at');
    IF (
      verification_email_sent_at IS NOT NULL AND
      NOW() < verification_email_sent_at + v_verification_min_duration_between_emails
    ) THEN 
        RETURN NULL;
    END IF;
  
  IF (
    verification_email_sent_at IS NOT NULL AND
    NOW() < verification_email_sent_at + v_verification_min_duration_between_new_tokens 
  ) THEN 
    v_verification_token = "dashboard_encrypted".get
        (v_user_id, verification_token_name, encode(gen_random_bytes(10), 'hex'));
  ELSE
    v_verification_token = encode(gen_random_bytes(10), 'hex');
  END IF;
  verification_email_sent_at = NOW();
  
  PERFORM "dashboard_simple_secrets".set
    (v_user_id, 'verification_email_sent_at', verification_email_sent_at);
  PERFORM "dashboard_encrypted".set
    (v_user_id, verification_token_name, v_verification_token, 'pgp');
  PERFORM
      app_jobs.add_job (
        jwt_private.current_database_id(),
        'send-email-link',
        json_build_object(
          'email_type', 'email_verification',
          'email_id', v_email.id,
          'email', email,
          'verification_token', v_verification_token
        )
      );
  RETURN TRUE;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION dashboard_roles_public.send_verification_email TO authenticated, anonymous;

CREATE FUNCTION dashboard_roles_public.verify_email ( email_id uuid, token text ) RETURNS boolean AS $EOFCODE$
DECLARE
  v_email "dashboard_public".emails;
  v_user_id uuid;
  
  v_verification_expires_interval interval = interval '3 days';
  verification_token_name text;
  verification_email_attempts int;
  verification_email_sent_at timestamptz;
  first_failed_verification_email_attempt timestamptz;
BEGIN
  
  SELECT * FROM "dashboard_public".emails e
     WHERE e.id = verify_email.email_id
  INTO v_email;
  IF (v_email.is_verified IS TRUE) THEN 
    RETURN TRUE;
  END IF;
  IF ( NOT FOUND ) THEN
    RETURN FALSE;
  END IF;
  v_user_id = v_email.owner_id;
  verification_email_sent_at = "dashboard_simple_secrets".get(v_user_id, 'verification_email_sent_at');
  IF (verification_email_sent_at IS NOT NULL AND 
    verification_email_sent_at + v_verification_expires_interval < NOW() 
  ) THEN 
    
    PERFORM "dashboard_simple_secrets".del(v_user_id, ARRAY[
        'verification_email_sent_at',
        'verification_email_attempts',
        'first_failed_verification_email_attempt'
    ]);
    PERFORM "dashboard_encrypted".del(v_user_id, verification_token_name);
    RETURN FALSE;
  END IF;
  verification_token_name = v_email.email::text || '_verification_token';
  IF ("dashboard_encrypted".verify (v_user_id, verification_token_name, verify_email.token) ) THEN
    UPDATE "dashboard_public".emails e
        SET is_verified = TRUE
    WHERE e.id = verify_email.email_id;
    UPDATE "dashboard_memberships_public".app_memberships 
      SET is_verified = TRUE 
    WHERE actor_id = v_user_id;
    PERFORM "dashboard_simple_secrets".del(v_user_id, ARRAY[
        'verification_email_sent_at',
        'verification_email_attempts',
        'first_failed_verification_email_attempt'
    ]);
    PERFORM "dashboard_encrypted".del(v_user_id, verification_token_name);
    RETURN TRUE;
  ELSE
    IF (
        first_failed_verification_email_attempt IS NULL OR
        first_failed_verification_email_attempt + v_verification_expires_interval < NOW()
    ) THEN
        verification_email_attempts = 1;
        first_failed_verification_email_attempt = NOW();
    ELSE 
        verification_email_attempts = verification_email_attempts + 1;
    END IF;
    PERFORM "dashboard_simple_secrets".set(v_user_id, 'verification_email_attempts', verification_email_attempts);
    PERFORM "dashboard_simple_secrets".set(v_user_id, 'first_failed_verification_email_attempt', first_failed_verification_email_attempt);
    RETURN FALSE;
  END IF;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION dashboard_roles_public.verify_email TO anonymous, authenticated;

CREATE FUNCTION dashboard_roles_public.send_account_deletion_email (  ) RETURNS boolean AS $EOFCODE$
DECLARE
    v_email "dashboard_public".emails;
    v_deletion_token text;
    v_min_duration_between_emails interval = interval '3 minutes';
    v_user_id uuid = jwt_public.current_user_id();
    
    v_max_duration interval = interval '3 days';
    account_deletion_email_sent_at timestamptz;
BEGIN
    IF (v_user_id IS NULL) THEN 
        RETURN FALSE;
    END IF;
    SELECT * FROM "dashboard_public".emails e
        WHERE e.owner_id = v_user_id
        ORDER BY is_primary DESC, is_verified DESC
        LIMIT 1
        INTO v_email;
    IF (NOT FOUND) THEN
        RETURN FALSE;
    END IF;
    v_user_id = v_email.owner_id;
    account_deletion_email_sent_at = "dashboard_simple_secrets".get(v_user_id, 'account_deletion_email_sent_at');
    IF (
        account_deletion_email_sent_at IS NOT NULL AND
        NOW() < account_deletion_email_sent_at + v_min_duration_between_emails
    ) THEN 
        RETURN FALSE;
    END IF;
    v_deletion_token = encode(gen_random_bytes(7), 'hex');
    PERFORM "dashboard_encrypted".set
        (v_user_id, 'account_deletion_token', v_deletion_token, 'crypt');
    PERFORM "dashboard_simple_secrets".set(v_user_id, 'account_deletion_email_sent_at', (NOW())::text);
    PERFORM
        app_jobs.add_job (
            jwt_private.current_database_id(),
            'send-account-deletion-link',
            json_build_object(
                'email_type', 'account_deletion',
                'user_id', v_user_id,
                'email', v_email.email::text,
                'account_deletion_token', v_deletion_token
            ));
    RETURN TRUE;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION dashboard_roles_public.send_account_deletion_email TO authenticated;

CREATE FUNCTION dashboard_roles_public.confirm_delete_account ( user_id uuid, token text ) RETURNS boolean AS $EOFCODE$
DECLARE
  v_expires_interval interval = interval '3 days';
  account_deletion_email_attempts int;
  account_deletion_email_sent_at timestamptz;
  first_failed_account_deletion_email_attempt timestamptz;
BEGIN
  account_deletion_email_sent_at = "dashboard_simple_secrets".get(confirm_delete_account.user_id, 'account_deletion_email_sent_at');
  IF (account_deletion_email_sent_at IS NOT NULL AND 
    account_deletion_email_sent_at + v_expires_interval < NOW() 
  ) THEN 
    
    PERFORM "dashboard_simple_secrets".del(confirm_delete_account.user_id, ARRAY[
        'account_deletion_email_sent_at',
        'account_deletion_email_attempts',
        'first_failed_account_deletion_email_attempt'
    ]);
    PERFORM "dashboard_encrypted".del(confirm_delete_account.user_id, 'account_deletion_token');
    RETURN FALSE;
  END IF;
  IF ("dashboard_encrypted".verify (confirm_delete_account.user_id, 'account_deletion_token', confirm_delete_account.token) ) THEN
    PERFORM "dashboard_simple_secrets".del(confirm_delete_account.user_id, ARRAY[
        'account_deletion_email_sent_at',
        'account_deletion_email_attempts',
        'first_failed_account_deletion_email_attempt'
    ]);
    PERFORM "dashboard_encrypted".del(confirm_delete_account.user_id, 'account_deletion_token');
    DELETE FROM "dashboard_public".users WHERE id = confirm_delete_account.user_id;
    RETURN TRUE;
  ELSE
    IF (
        first_failed_account_deletion_email_attempt IS NULL OR
        first_failed_account_deletion_email_attempt + v_expires_interval < NOW()
    ) THEN
        account_deletion_email_attempts = 1;
        first_failed_account_deletion_email_attempt = NOW();
    ELSE 
        account_deletion_email_attempts = account_deletion_email_attempts + 1;
    END IF;
    PERFORM "dashboard_simple_secrets".set(confirm_delete_account.user_id, 'account_deletion_email_attempts', account_deletion_email_attempts);
    PERFORM "dashboard_simple_secrets".set(confirm_delete_account.user_id, 'first_failed_account_deletion_email_attempt', first_failed_account_deletion_email_attempt);
    RETURN FALSE;
  END IF;
END;
$EOFCODE$ LANGUAGE plpgsql VOLATILE SECURITY DEFINER;

GRANT EXECUTE ON FUNCTION dashboard_roles_public.confirm_delete_account TO anonymous, authenticated;

CREATE TABLE dashboard_roles_public.auth_accounts (
  
);

ALTER TABLE dashboard_roles_public.auth_accounts DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_roles_public.auth_accounts ADD COLUMN  id uuid;

ALTER TABLE dashboard_roles_public.auth_accounts ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_roles_public.auth_accounts ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_roles_public.auth_accounts ADD CONSTRAINT auth_accounts_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_roles_public.auth_accounts ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_roles_public.auth_accounts ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_roles_public.auth_accounts ALTER COLUMN owner_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_roles_public.auth_accounts ADD CONSTRAINT auth_accounts_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

ALTER TABLE dashboard_roles_public.auth_accounts ADD COLUMN  service text;

ALTER TABLE dashboard_roles_public.auth_accounts ALTER COLUMN service SET NOT NULL;

COMMENT ON COLUMN dashboard_roles_public.auth_accounts.service IS E'The service used, e.g. `twitter` or `github`.';

ALTER TABLE dashboard_roles_public.auth_accounts ADD COLUMN  identifier text;

ALTER TABLE dashboard_roles_public.auth_accounts ALTER COLUMN identifier SET NOT NULL;

COMMENT ON COLUMN dashboard_roles_public.auth_accounts.identifier IS E'A unique identifier for the user within the service';

ALTER TABLE dashboard_roles_public.auth_accounts ADD COLUMN  details jsonb;

ALTER TABLE dashboard_roles_public.auth_accounts ALTER COLUMN details SET NOT NULL;

COMMENT ON COLUMN dashboard_roles_public.auth_accounts.details IS E'Additional profile details extracted from this login method';

ALTER TABLE dashboard_roles_public.auth_accounts ADD COLUMN  is_verified boolean;

ALTER TABLE dashboard_roles_public.auth_accounts ALTER COLUMN is_verified SET NOT NULL;

ALTER TABLE dashboard_roles_public.auth_accounts ALTER COLUMN is_verified SET DEFAULT FALSE;

ALTER TABLE dashboard_roles_public.auth_accounts ADD CONSTRAINT auth_accounts_service_identifier_key UNIQUE ( service, identifier );

ALTER TABLE dashboard_roles_public.auth_accounts ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_roles_public.auth_accounts ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_roles_public.auth_accounts ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_roles_public.auth_accounts ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_roles_public.auth_accounts 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_roles_public.auth_accounts ( created_at );

CREATE INDEX ON dashboard_roles_public.auth_accounts ( updated_at );

ALTER TABLE dashboard_roles_public.auth_accounts ENABLE ROW LEVEL SECURITY;

GRANT UPDATE ( service, identifier, details, owner_id ) ON TABLE dashboard_roles_public.auth_accounts TO authenticated;

GRANT INSERT ( service, identifier, details, owner_id ) ON TABLE dashboard_roles_public.auth_accounts TO authenticated;

GRANT SELECT ON TABLE dashboard_roles_public.auth_accounts TO authenticated;

GRANT DELETE ON TABLE dashboard_roles_public.auth_accounts TO authenticated;

CREATE POLICY auth_sel ON dashboard_roles_public.auth_accounts FOR SELECT TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000100000000000') = '00000000000000000000100000000000') );

CREATE POLICY auth_ins ON dashboard_roles_public.auth_accounts FOR INSERT TO authenticated WITH CHECK ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000100000000000') = '00000000000000000000100000000000') );

CREATE POLICY auth_upd ON dashboard_roles_public.auth_accounts FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000100000000000') = '00000000000000000000100000000000') );

CREATE POLICY auth_del ON dashboard_roles_public.auth_accounts FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000100000000000') = '00000000000000000000100000000000') );

CREATE TABLE dashboard_public.user_profiles (
  
);

ALTER TABLE dashboard_public.user_profiles DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.user_profiles ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.user_profiles ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.user_profiles ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.user_profiles ADD CONSTRAINT user_profiles_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.user_profiles ADD COLUMN  user_id uuid;

ALTER TABLE dashboard_public.user_profiles ALTER COLUMN user_id SET NOT NULL;

ALTER TABLE dashboard_public.user_profiles ALTER COLUMN user_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_public.user_profiles ADD COLUMN  header_image image;

ALTER TABLE dashboard_public.user_profiles ADD COLUMN  bio text;

COMMENT ON COLUMN dashboard_public.user_profiles.bio IS E'user bio';

ALTER TABLE dashboard_public.user_profiles ADD COLUMN  reputation numeric;

ALTER TABLE dashboard_public.user_profiles ALTER COLUMN reputation SET DEFAULT 0;

COMMENT ON COLUMN dashboard_public.user_profiles.reputation IS E'user reputation';

ALTER TABLE dashboard_public.user_profiles ADD COLUMN  tags citext[];

COMMENT ON COLUMN dashboard_public.user_profiles.tags IS E'user tags';

ALTER TABLE dashboard_public.user_profiles ADD COLUMN  desired citext[];

COMMENT ON COLUMN dashboard_public.user_profiles.desired IS E'user wanted tags';

ALTER TABLE dashboard_public.user_profiles ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.user_profiles ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_profiles 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.user_profiles ( created_by );

CREATE INDEX ON dashboard_public.user_profiles ( updated_by );

ALTER TABLE dashboard_public.user_profiles ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.user_profiles ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.user_profiles ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.user_profiles ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_profiles 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.user_profiles ( created_at );

CREATE INDEX ON dashboard_public.user_profiles ( updated_at );

ALTER TABLE dashboard_public.user_profiles ADD CONSTRAINT user_profiles_user_id_fkey FOREIGN KEY ( user_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_profiles_user_id_fkey ON dashboard_public.user_profiles IS E'@omit manyToMany';

CREATE INDEX user_profiles_user_id_idx ON dashboard_public.user_profiles ( user_id );

ALTER TABLE dashboard_public.user_profiles ADD CONSTRAINT user_profiles_user_id_key UNIQUE ( user_id );

COMMENT ON CONSTRAINT user_profiles_user_id_key ON dashboard_public.user_profiles IS E'@omit';

ALTER TABLE dashboard_public.user_profiles ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.user_profiles TO authenticated;

GRANT SELECT ON TABLE dashboard_public.user_profiles TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.user_profiles TO authenticated;

GRANT DELETE ON TABLE dashboard_public.user_profiles TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.user_profiles FOR INSERT TO authenticated WITH CHECK ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_upd ON dashboard_public.user_profiles FOR UPDATE TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_del ON dashboard_public.user_profiles FOR DELETE TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_sel ON dashboard_public.user_profiles FOR SELECT TO authenticated USING ( TRUE );

CREATE TABLE dashboard_public.user_settings (
  
);

ALTER TABLE dashboard_public.user_settings DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.user_settings ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.user_settings ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.user_settings ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.user_settings ADD CONSTRAINT user_settings_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.user_settings ADD COLUMN  user_id uuid;

ALTER TABLE dashboard_public.user_settings ALTER COLUMN user_id SET NOT NULL;

ALTER TABLE dashboard_public.user_settings ALTER COLUMN user_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_public.user_settings ADD COLUMN  first_name text;

ALTER TABLE dashboard_public.user_settings ADD CONSTRAINT user_settings_first_name_chk CHECK ( character_length(first_name) <= 64 );

COMMENT ON COLUMN dashboard_public.user_settings.first_name IS E'user first name';

ALTER TABLE dashboard_public.user_settings ADD COLUMN  last_name text;

ALTER TABLE dashboard_public.user_settings ADD CONSTRAINT user_settings_last_name_chk CHECK ( character_length(last_name) <= 64 );

COMMENT ON COLUMN dashboard_public.user_settings.last_name IS E'user surname';

ALTER TABLE dashboard_public.user_settings ADD COLUMN  search_radius numeric;

COMMENT ON COLUMN dashboard_public.user_settings.search_radius IS E'search radius';

ALTER TABLE dashboard_public.user_settings ADD COLUMN  zip int;

COMMENT ON COLUMN dashboard_public.user_settings.zip IS E'user zip code';

ALTER TABLE dashboard_public.user_settings ADD COLUMN  location geometry(point, 4326);

COMMENT ON COLUMN dashboard_public.user_settings.location IS E'user location stored as a GeoJSON object as 4326 lon/lat';

ALTER TABLE dashboard_public.user_settings ADD COLUMN  bounds geometry(geometrycollection, 4326);

COMMENT ON COLUMN dashboard_public.user_settings.bounds IS E'all of the users locations combined using ST_Collect for search optimization';

ALTER TABLE dashboard_public.user_settings ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.user_settings ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_settings 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.user_settings ( created_by );

CREATE INDEX ON dashboard_public.user_settings ( updated_by );

ALTER TABLE dashboard_public.user_settings ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.user_settings ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.user_settings ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.user_settings ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_settings 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.user_settings ( created_at );

CREATE INDEX ON dashboard_public.user_settings ( updated_at );

ALTER TABLE dashboard_public.user_settings ADD CONSTRAINT user_settings_user_id_fkey FOREIGN KEY ( user_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_settings_user_id_fkey ON dashboard_public.user_settings IS E'@omit manyToMany';

CREATE INDEX user_settings_user_id_idx ON dashboard_public.user_settings ( user_id );

ALTER TABLE dashboard_public.user_settings ADD CONSTRAINT user_settings_user_id_key UNIQUE ( user_id );

COMMENT ON CONSTRAINT user_settings_user_id_key ON dashboard_public.user_settings IS E'@omit';

CREATE INDEX user_settings_location_idx ON dashboard_public.user_settings USING GIST ( location );

CREATE INDEX user_settings_bounds_idx ON dashboard_public.user_settings USING GIST ( bounds );

ALTER TABLE dashboard_public.user_settings ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.user_settings TO authenticated;

GRANT SELECT ON TABLE dashboard_public.user_settings TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.user_settings TO authenticated;

GRANT DELETE ON TABLE dashboard_public.user_settings TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.user_settings FOR INSERT TO authenticated WITH CHECK ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_sel ON dashboard_public.user_settings FOR SELECT TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_upd ON dashboard_public.user_settings FOR UPDATE TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_del ON dashboard_public.user_settings FOR DELETE TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE TABLE dashboard_public.user_characteristics (
  
);

ALTER TABLE dashboard_public.user_characteristics DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.user_characteristics ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.user_characteristics ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.user_characteristics ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.user_characteristics ADD CONSTRAINT user_characteristics_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.user_characteristics ADD COLUMN  user_id uuid;

ALTER TABLE dashboard_public.user_characteristics ALTER COLUMN user_id SET NOT NULL;

ALTER TABLE dashboard_public.user_characteristics ALTER COLUMN user_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_public.user_characteristics ADD COLUMN  income numeric;

ALTER TABLE dashboard_public.user_characteristics ADD COLUMN  gender char(1);

ALTER TABLE dashboard_public.user_characteristics ADD COLUMN  race text;

ALTER TABLE dashboard_public.user_characteristics ADD COLUMN  age int;

ALTER TABLE dashboard_public.user_characteristics ADD COLUMN  dob date;

ALTER TABLE dashboard_public.user_characteristics ADD COLUMN  education text;

ALTER TABLE dashboard_public.user_characteristics ADD COLUMN  home_ownership smallint;

ALTER TABLE dashboard_public.user_characteristics ADD CONSTRAINT user_characteristics_home_ownership_chk CHECK ( home_ownership >= 1 AND home_ownership <= 5 );

ALTER TABLE dashboard_public.user_characteristics ADD COLUMN  tree_hugger_level smallint;

ALTER TABLE dashboard_public.user_characteristics ADD CONSTRAINT user_characteristics_tree_hugger_level_chk CHECK ( tree_hugger_level >= 1 AND tree_hugger_level <= 5 );

ALTER TABLE dashboard_public.user_characteristics ADD COLUMN  diy_level smallint;

ALTER TABLE dashboard_public.user_characteristics ADD CONSTRAINT user_characteristics_diy_level_chk CHECK ( diy_level >= 1 AND diy_level <= 5 );

ALTER TABLE dashboard_public.user_characteristics ADD COLUMN  gardener_level smallint;

ALTER TABLE dashboard_public.user_characteristics ADD CONSTRAINT user_characteristics_gardener_level_chk CHECK ( gardener_level >= 1 AND gardener_level <= 5 );

ALTER TABLE dashboard_public.user_characteristics ADD COLUMN  free_time smallint;

ALTER TABLE dashboard_public.user_characteristics ADD CONSTRAINT user_characteristics_free_time_chk CHECK ( free_time >= 1 AND free_time <= 5 );

ALTER TABLE dashboard_public.user_characteristics ADD COLUMN  research_to_doer smallint;

ALTER TABLE dashboard_public.user_characteristics ADD CONSTRAINT user_characteristics_research_to_doer_chk CHECK ( research_to_doer >= 1 AND research_to_doer <= 5 );

ALTER TABLE dashboard_public.user_characteristics ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.user_characteristics ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_characteristics 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.user_characteristics ( created_by );

CREATE INDEX ON dashboard_public.user_characteristics ( updated_by );

ALTER TABLE dashboard_public.user_characteristics ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.user_characteristics ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.user_characteristics ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.user_characteristics ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_characteristics 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.user_characteristics ( created_at );

CREATE INDEX ON dashboard_public.user_characteristics ( updated_at );

ALTER TABLE dashboard_public.user_characteristics ADD CONSTRAINT user_characteristics_user_id_fkey FOREIGN KEY ( user_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_characteristics_user_id_fkey ON dashboard_public.user_characteristics IS E'@omit manyToMany';

CREATE INDEX user_characteristics_user_id_idx ON dashboard_public.user_characteristics ( user_id );

ALTER TABLE dashboard_public.user_characteristics ADD CONSTRAINT user_characteristics_user_id_key UNIQUE ( user_id );

COMMENT ON CONSTRAINT user_characteristics_user_id_key ON dashboard_public.user_characteristics IS E'@omit';

ALTER TABLE dashboard_public.user_characteristics ENABLE ROW LEVEL SECURITY;

CREATE POLICY auth_sel ON dashboard_public.user_characteristics FOR SELECT TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_ins ON dashboard_public.user_characteristics FOR INSERT TO authenticated WITH CHECK ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_upd ON dashboard_public.user_characteristics FOR UPDATE TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_del ON dashboard_public.user_characteristics FOR DELETE TO authenticated USING ( user_id = jwt_public.current_user_id() );

GRANT SELECT ON TABLE dashboard_public.user_characteristics TO authenticated;

GRANT INSERT ON TABLE dashboard_public.user_characteristics TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.user_characteristics TO authenticated;

GRANT DELETE ON TABLE dashboard_public.user_characteristics TO authenticated;

CREATE TABLE dashboard_public.user_contacts (
  
);

ALTER TABLE dashboard_public.user_contacts DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.user_contacts ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.user_contacts ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.user_contacts ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.user_contacts ADD CONSTRAINT user_contacts_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.user_contacts ADD COLUMN  user_id uuid;

ALTER TABLE dashboard_public.user_contacts ALTER COLUMN user_id SET NOT NULL;

ALTER TABLE dashboard_public.user_contacts ALTER COLUMN user_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_public.user_contacts ADD COLUMN  vcf jsonb;

COMMENT ON COLUMN dashboard_public.user_contacts.vcf IS E'the VCF file for storing contact information for a person or business';

ALTER TABLE dashboard_public.user_contacts ADD COLUMN  full_name text;

ALTER TABLE dashboard_public.user_contacts ADD CONSTRAINT user_contacts_full_name_chk CHECK ( character_length(full_name) <= 120 );

COMMENT ON COLUMN dashboard_public.user_contacts.full_name IS E'full name of the person or business';

ALTER TABLE dashboard_public.user_contacts ADD COLUMN  emails email[];

ALTER TABLE dashboard_public.user_contacts ADD COLUMN  device text;

COMMENT ON COLUMN dashboard_public.user_contacts.device IS E'originating device type or id';

ALTER TABLE dashboard_public.user_contacts ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.user_contacts ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_contacts 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.user_contacts ( created_by );

CREATE INDEX ON dashboard_public.user_contacts ( updated_by );

ALTER TABLE dashboard_public.user_contacts ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.user_contacts ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.user_contacts ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.user_contacts ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_contacts 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.user_contacts ( created_at );

CREATE INDEX ON dashboard_public.user_contacts ( updated_at );

ALTER TABLE dashboard_public.user_contacts ADD CONSTRAINT user_contacts_user_id_fkey FOREIGN KEY ( user_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_contacts_user_id_fkey ON dashboard_public.user_contacts IS NULL;

CREATE INDEX user_contacts_user_id_idx ON dashboard_public.user_contacts ( user_id );

ALTER TABLE dashboard_public.user_contacts ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.user_contacts TO authenticated;

GRANT SELECT ON TABLE dashboard_public.user_contacts TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.user_contacts TO authenticated;

GRANT DELETE ON TABLE dashboard_public.user_contacts TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.user_contacts FOR INSERT TO authenticated WITH CHECK ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_sel ON dashboard_public.user_contacts FOR SELECT TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_upd ON dashboard_public.user_contacts FOR UPDATE TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_del ON dashboard_public.user_contacts FOR DELETE TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE TABLE dashboard_public.user_connections (
  
);

ALTER TABLE dashboard_public.user_connections DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.user_connections ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.user_connections ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.user_connections ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.user_connections ADD CONSTRAINT user_connections_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.user_connections ADD COLUMN  accepted bool;

ALTER TABLE dashboard_public.user_connections ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.user_connections ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_connections 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.user_connections ( created_by );

CREATE INDEX ON dashboard_public.user_connections ( updated_by );

ALTER TABLE dashboard_public.user_connections ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.user_connections ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.user_connections ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.user_connections ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_connections 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.user_connections ( created_at );

CREATE INDEX ON dashboard_public.user_connections ( updated_at );

ALTER TABLE dashboard_public.user_connections ADD COLUMN  requester_id uuid;

ALTER TABLE dashboard_public.user_connections ALTER COLUMN requester_id SET NOT NULL;

ALTER TABLE dashboard_public.user_connections ADD CONSTRAINT user_connections_requester_id_fkey FOREIGN KEY ( requester_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_connections_requester_id_fkey ON dashboard_public.user_connections IS E'@omit manyToMany';

CREATE INDEX user_connections_requester_id_idx ON dashboard_public.user_connections ( requester_id );

ALTER TABLE dashboard_public.user_connections ADD COLUMN  responder_id uuid;

ALTER TABLE dashboard_public.user_connections ALTER COLUMN responder_id SET NOT NULL;

ALTER TABLE dashboard_public.user_connections ADD CONSTRAINT user_connections_responder_id_fkey FOREIGN KEY ( responder_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_connections_responder_id_fkey ON dashboard_public.user_connections IS E'@omit manyToMany';

CREATE INDEX user_connections_responder_id_idx ON dashboard_public.user_connections ( responder_id );

ALTER TABLE dashboard_public.user_connections ADD CONSTRAINT user_connections_requester_id_responder_id_key UNIQUE ( requester_id, responder_id );

COMMENT ON CONSTRAINT user_connections_requester_id_responder_id_key ON dashboard_public.user_connections IS E'@omit';

ALTER TABLE dashboard_public.user_connections ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.user_connections TO authenticated;

GRANT SELECT ON TABLE dashboard_public.user_connections TO authenticated;

GRANT DELETE ON TABLE dashboard_public.user_connections TO authenticated;

GRANT UPDATE ( accepted ) ON TABLE dashboard_public.user_connections TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.user_connections FOR SELECT TO authenticated USING ( responder_id = jwt_public.current_user_id() OR requester_id = jwt_public.current_user_id() );

CREATE POLICY auth_del ON dashboard_public.user_connections FOR DELETE TO authenticated USING ( responder_id = jwt_public.current_user_id() OR requester_id = jwt_public.current_user_id() );

CREATE POLICY auth_upd ON dashboard_public.user_connections FOR UPDATE TO authenticated USING ( responder_id = jwt_public.current_user_id() );

CREATE POLICY auth_ins ON dashboard_public.user_connections FOR INSERT TO authenticated WITH CHECK ( requester_id = jwt_public.current_user_id() );

CREATE TABLE dashboard_public.location_types (
  
);

ALTER TABLE dashboard_public.location_types DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.location_types ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.location_types ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.location_types ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.location_types ADD CONSTRAINT location_types_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.location_types ADD COLUMN  name text;

COMMENT ON COLUMN dashboard_public.location_types.name IS E'e.g. neighborhood, postalcode, locality, venue, etc';

ALTER TABLE dashboard_public.location_types ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.location_types ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.location_types 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.location_types ( created_by );

CREATE INDEX ON dashboard_public.location_types ( updated_by );

ALTER TABLE dashboard_public.location_types ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.location_types ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.location_types ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.location_types ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.location_types 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.location_types ( created_at );

CREATE INDEX ON dashboard_public.location_types ( updated_at );

CREATE TABLE dashboard_public.locations (
  
);

ALTER TABLE dashboard_public.locations DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.locations ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.locations ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.locations ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.locations ADD CONSTRAINT locations_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.locations ADD COLUMN  name text;

ALTER TABLE dashboard_public.locations ADD COLUMN  location geometry(point, 4326);

ALTER TABLE dashboard_public.locations ADD COLUMN  bbox geometry(polygon, 4326);

ALTER TABLE dashboard_public.locations ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.locations ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.locations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.locations ( created_by );

CREATE INDEX ON dashboard_public.locations ( updated_by );

ALTER TABLE dashboard_public.locations ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.locations ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.locations ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.locations ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.locations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.locations ( created_at );

CREATE INDEX ON dashboard_public.locations ( updated_at );

ALTER TABLE dashboard_public.locations ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.locations ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.locations ADD CONSTRAINT locations_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT locations_owner_id_fkey ON dashboard_public.locations IS E'@omit manyToMany';

CREATE INDEX locations_owner_id_idx ON dashboard_public.locations ( owner_id );

ALTER TABLE dashboard_public.locations ADD COLUMN  location_type uuid;

ALTER TABLE dashboard_public.locations ALTER COLUMN location_type SET NOT NULL;

ALTER TABLE dashboard_public.locations ADD CONSTRAINT locations_location_type_fkey FOREIGN KEY ( location_type ) REFERENCES dashboard_public.location_types ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT locations_location_type_fkey ON dashboard_public.locations IS E'@omit manyToMany';

CREATE INDEX locations_location_type_idx ON dashboard_public.locations ( location_type );

CREATE INDEX locations_location_idx ON dashboard_public.locations USING GIST ( location );

CREATE INDEX locations_bbox_idx ON dashboard_public.locations USING GIST ( bbox );

ALTER TABLE dashboard_public.locations ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.locations TO authenticated;

GRANT SELECT ON TABLE dashboard_public.locations TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.locations TO authenticated;

GRANT DELETE ON TABLE dashboard_public.locations TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.locations FOR INSERT TO authenticated WITH CHECK ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_upd ON dashboard_public.locations FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_del ON dashboard_public.locations FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_ins_admin ON dashboard_public.locations FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_upd_admin ON dashboard_public.locations FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_del_admin ON dashboard_public.locations FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_sel ON dashboard_public.locations FOR SELECT TO authenticated USING ( TRUE );

CREATE TABLE dashboard_public.user_locations (
  
);

ALTER TABLE dashboard_public.user_locations DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.user_locations ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.user_locations ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.user_locations ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.user_locations ADD CONSTRAINT user_locations_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.user_locations ADD COLUMN  user_id uuid;

ALTER TABLE dashboard_public.user_locations ALTER COLUMN user_id SET NOT NULL;

ALTER TABLE dashboard_public.user_locations ALTER COLUMN user_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_public.user_locations ADD COLUMN  name text;

ALTER TABLE dashboard_public.user_locations ADD COLUMN  kind text;

COMMENT ON COLUMN dashboard_public.user_locations.kind IS E'e.g., home, work, exercise, other';

ALTER TABLE dashboard_public.user_locations ADD COLUMN  description text;

ALTER TABLE dashboard_public.user_locations ADD COLUMN  location geometry(point, 4326);

ALTER TABLE dashboard_public.user_locations ADD COLUMN  bbox geometry(polygon, 4326);

ALTER TABLE dashboard_public.user_locations ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.user_locations ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_locations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.user_locations ( created_by );

CREATE INDEX ON dashboard_public.user_locations ( updated_by );

ALTER TABLE dashboard_public.user_locations ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.user_locations ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.user_locations ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.user_locations ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_locations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.user_locations ( created_at );

CREATE INDEX ON dashboard_public.user_locations ( updated_at );

CREATE INDEX user_locations_location_idx ON dashboard_public.user_locations USING GIST ( location );

CREATE INDEX user_locations_bbox_idx ON dashboard_public.user_locations USING GIST ( bbox );

ALTER TABLE dashboard_public.user_locations ADD CONSTRAINT user_locations_user_id_fkey FOREIGN KEY ( user_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_locations_user_id_fkey ON dashboard_public.user_locations IS E'@omit manyToMany';

CREATE INDEX user_locations_user_id_idx ON dashboard_public.user_locations ( user_id );

ALTER TABLE dashboard_public.user_locations ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.user_locations TO authenticated;

GRANT SELECT ON TABLE dashboard_public.user_locations TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.user_locations TO authenticated;

GRANT DELETE ON TABLE dashboard_public.user_locations TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.user_locations FOR INSERT TO authenticated WITH CHECK ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_sel ON dashboard_public.user_locations FOR SELECT TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_upd ON dashboard_public.user_locations FOR UPDATE TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_del ON dashboard_public.user_locations FOR DELETE TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE TABLE dashboard_public.news_articles (
  
);

ALTER TABLE dashboard_public.news_articles DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.news_articles ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.news_articles ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.news_articles ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.news_articles ADD CONSTRAINT news_articles_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.news_articles ADD COLUMN  name text;

ALTER TABLE dashboard_public.news_articles ADD COLUMN  description text;

ALTER TABLE dashboard_public.news_articles ADD COLUMN  link url;

ALTER TABLE dashboard_public.news_articles ADD COLUMN  published_at timestamptz;

ALTER TABLE dashboard_public.news_articles ADD COLUMN  photo image;

ALTER TABLE dashboard_public.news_articles ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.news_articles ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.news_articles 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.news_articles ( created_by );

CREATE INDEX ON dashboard_public.news_articles ( updated_by );

ALTER TABLE dashboard_public.news_articles ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.news_articles ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.news_articles ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.news_articles ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.news_articles 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.news_articles ( created_at );

CREATE INDEX ON dashboard_public.news_articles ( updated_at );

ALTER TABLE dashboard_public.news_articles ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.news_articles TO authenticated;

GRANT SELECT ON TABLE dashboard_public.news_articles TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.news_articles TO authenticated;

GRANT DELETE ON TABLE dashboard_public.news_articles TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.news_articles FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_public.news_articles FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE) );

CREATE POLICY auth_upd ON dashboard_public.news_articles FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE) );

CREATE POLICY auth_del ON dashboard_public.news_articles FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE) );

CREATE TABLE dashboard_public.quantities (
  
);

ALTER TABLE dashboard_public.quantities DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.quantities ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.quantities ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.quantities ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.quantities ADD CONSTRAINT quantities_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.quantities ADD COLUMN  name citext;

ALTER TABLE dashboard_public.quantities ADD COLUMN  label text;

ALTER TABLE dashboard_public.quantities ADD COLUMN  unit text;

ALTER TABLE dashboard_public.quantities ADD COLUMN  unit_desc text;

ALTER TABLE dashboard_public.quantities ADD COLUMN  description text;

ALTER TABLE dashboard_public.quantities ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.quantities ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.quantities 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.quantities ( created_by );

CREATE INDEX ON dashboard_public.quantities ( updated_by );

ALTER TABLE dashboard_public.quantities ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.quantities ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.quantities ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.quantities ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.quantities 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.quantities ( created_at );

CREATE INDEX ON dashboard_public.quantities ( updated_at );

ALTER TABLE dashboard_public.quantities ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.quantities TO authenticated;

GRANT SELECT ON TABLE dashboard_public.quantities TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.quantities TO authenticated;

GRANT DELETE ON TABLE dashboard_public.quantities TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.quantities FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_public.quantities FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE) );

CREATE POLICY auth_upd ON dashboard_public.quantities FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE) );

CREATE POLICY auth_del ON dashboard_public.quantities FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE) );

CREATE TABLE dashboard_public.units (
  
);

ALTER TABLE dashboard_public.units DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.units ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.units ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.units ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.units ADD CONSTRAINT units_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.units ADD COLUMN  name text;

ALTER TABLE dashboard_public.units ADD COLUMN  value text;

ALTER TABLE dashboard_public.units ADD COLUMN  amount text;

ALTER TABLE dashboard_public.units ADD COLUMN  description text;

ALTER TABLE dashboard_public.units ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.units ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.units 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.units ( created_by );

CREATE INDEX ON dashboard_public.units ( updated_by );

ALTER TABLE dashboard_public.units ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.units ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.units ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.units ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.units 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.units ( created_at );

CREATE INDEX ON dashboard_public.units ( updated_at );

ALTER TABLE dashboard_public.units ADD COLUMN  quantity_id uuid;

ALTER TABLE dashboard_public.units ALTER COLUMN quantity_id SET NOT NULL;

ALTER TABLE dashboard_public.units ADD CONSTRAINT units_quantity_id_fkey FOREIGN KEY ( quantity_id ) REFERENCES dashboard_public.quantities ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT units_quantity_id_fkey ON dashboard_public.units IS E'@omit manyToMany';

CREATE INDEX units_quantity_id_idx ON dashboard_public.units ( quantity_id );

ALTER TABLE dashboard_public.units ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.units TO authenticated;

GRANT SELECT ON TABLE dashboard_public.units TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.units TO authenticated;

GRANT DELETE ON TABLE dashboard_public.units TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.units FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_public.units FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE) );

CREATE POLICY auth_upd ON dashboard_public.units FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE) );

CREATE POLICY auth_del ON dashboard_public.units FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE) );

CREATE TABLE dashboard_public.object_types (
  
);

ALTER TABLE dashboard_public.object_types DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.object_types ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.object_types ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.object_types ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.object_types ADD CONSTRAINT object_types_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.object_types ADD COLUMN  name citext;

ALTER TABLE dashboard_public.object_types ADD COLUMN  description text;

ALTER TABLE dashboard_public.object_types ADD COLUMN  photo image;

ALTER TABLE dashboard_public.object_types ADD COLUMN  icon image;

ALTER TABLE dashboard_public.object_types ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.object_types ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.object_types 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.object_types ( created_by );

CREATE INDEX ON dashboard_public.object_types ( updated_by );

ALTER TABLE dashboard_public.object_types ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.object_types ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.object_types ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.object_types ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.object_types 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.object_types ( created_at );

CREATE INDEX ON dashboard_public.object_types ( updated_at );

ALTER TABLE dashboard_public.object_types ADD COLUMN  quantity_id uuid;

ALTER TABLE dashboard_public.object_types ADD CONSTRAINT object_types_quantity_id_fkey FOREIGN KEY ( quantity_id ) REFERENCES dashboard_public.quantities ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT object_types_quantity_id_fkey ON dashboard_public.object_types IS E'@omit manyToMany';

CREATE INDEX object_types_quantity_id_idx ON dashboard_public.object_types ( quantity_id );

ALTER TABLE dashboard_public.object_types ADD CONSTRAINT object_types_name_key UNIQUE ( name );

COMMENT ON CONSTRAINT object_types_name_key ON dashboard_public.object_types IS NULL;

ALTER TABLE dashboard_public.object_types ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.object_types TO authenticated;

GRANT SELECT ON TABLE dashboard_public.object_types TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.object_types TO authenticated;

GRANT DELETE ON TABLE dashboard_public.object_types TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.object_types FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_public.object_types FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_upd ON dashboard_public.object_types FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_del ON dashboard_public.object_types FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE TABLE dashboard_public.objects (
  
);

ALTER TABLE dashboard_public.objects DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.objects ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.objects ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.objects ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.objects ADD CONSTRAINT objects_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.objects ADD COLUMN  name text;

ALTER TABLE dashboard_public.objects ADD COLUMN  description text;

ALTER TABLE dashboard_public.objects ADD COLUMN  photo image;

ALTER TABLE dashboard_public.objects ADD COLUMN  media upload;

ALTER TABLE dashboard_public.objects ADD COLUMN  location geometry(point, 4326);

ALTER TABLE dashboard_public.objects ADD COLUMN  bbox geometry(polygon, 4326);

ALTER TABLE dashboard_public.objects ADD COLUMN  data jsonb;

ALTER TABLE dashboard_public.objects ADD COLUMN  is_private bool;

ALTER TABLE dashboard_public.objects ALTER COLUMN is_private SET NOT NULL;

ALTER TABLE dashboard_public.objects ALTER COLUMN is_private SET DEFAULT FALSE;

ALTER TABLE dashboard_public.objects ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.objects ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.objects ALTER COLUMN owner_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_public.objects ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.objects ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.objects 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.objects ( created_by );

CREATE INDEX ON dashboard_public.objects ( updated_by );

ALTER TABLE dashboard_public.objects ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.objects ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.objects ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.objects ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.objects 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.objects ( created_at );

CREATE INDEX ON dashboard_public.objects ( updated_at );

ALTER TABLE dashboard_public.objects ADD CONSTRAINT objects_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT objects_owner_id_fkey ON dashboard_public.objects IS E'@omit manyToMany';

CREATE INDEX objects_owner_id_idx ON dashboard_public.objects ( owner_id );

ALTER TABLE dashboard_public.objects ADD COLUMN  type_id uuid;

ALTER TABLE dashboard_public.objects ALTER COLUMN type_id SET NOT NULL;

ALTER TABLE dashboard_public.objects ADD CONSTRAINT objects_type_id_fkey FOREIGN KEY ( type_id ) REFERENCES dashboard_public.object_types ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT objects_type_id_fkey ON dashboard_public.objects IS E'@omit manyToMany';

CREATE INDEX objects_type_id_idx ON dashboard_public.objects ( type_id );

CREATE INDEX objects_location_idx ON dashboard_public.objects USING GIST ( location );

CREATE INDEX objects_is_private_idx ON dashboard_public.objects ( is_private );

CREATE INDEX objects_bbox_idx ON dashboard_public.objects USING GIST ( bbox );

ALTER TABLE dashboard_public.objects ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.objects TO authenticated;

GRANT SELECT ON TABLE dashboard_public.objects TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.objects TO authenticated;

GRANT DELETE ON TABLE dashboard_public.objects TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.objects FOR INSERT TO authenticated WITH CHECK ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_sel ON dashboard_public.objects FOR SELECT TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_upd ON dashboard_public.objects FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_del ON dashboard_public.objects FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_upd_admin ON dashboard_public.objects FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_del_admin ON dashboard_public.objects FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_sel_public ON dashboard_public.objects FOR SELECT TO authenticated USING ( is_private IS NOT TRUE );

CREATE TABLE dashboard_public.object_type_attributes (
  
);

ALTER TABLE dashboard_public.object_type_attributes DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.object_type_attributes ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.object_type_attributes ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.object_type_attributes ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.object_type_attributes ADD CONSTRAINT object_type_attributes_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.object_type_attributes ADD COLUMN  name text;

ALTER TABLE dashboard_public.object_type_attributes ADD COLUMN  label text;

ALTER TABLE dashboard_public.object_type_attributes ADD COLUMN  type text;

ALTER TABLE dashboard_public.object_type_attributes ADD COLUMN  description text;

ALTER TABLE dashboard_public.object_type_attributes ADD COLUMN  min int;

ALTER TABLE dashboard_public.object_type_attributes ADD COLUMN  max int;

ALTER TABLE dashboard_public.object_type_attributes ADD COLUMN  pattern text;

ALTER TABLE dashboard_public.object_type_attributes ADD COLUMN  is_required boolean;

ALTER TABLE dashboard_public.object_type_attributes ALTER COLUMN is_required SET DEFAULT FALSE;

ALTER TABLE dashboard_public.object_type_attributes ADD COLUMN  attr_order int;

ALTER TABLE dashboard_public.object_type_attributes ALTER COLUMN attr_order SET DEFAULT 0;

ALTER TABLE dashboard_public.object_type_attributes ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.object_type_attributes ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.object_type_attributes 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.object_type_attributes ( created_by );

CREATE INDEX ON dashboard_public.object_type_attributes ( updated_by );

ALTER TABLE dashboard_public.object_type_attributes ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.object_type_attributes ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.object_type_attributes ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.object_type_attributes ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.object_type_attributes 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.object_type_attributes ( created_at );

CREATE INDEX ON dashboard_public.object_type_attributes ( updated_at );

ALTER TABLE dashboard_public.object_type_attributes ADD COLUMN  object_type_id uuid;

ALTER TABLE dashboard_public.object_type_attributes ALTER COLUMN object_type_id SET NOT NULL;

ALTER TABLE dashboard_public.object_type_attributes ADD CONSTRAINT object_type_attributes_object_type_id_fkey FOREIGN KEY ( object_type_id ) REFERENCES dashboard_public.object_types ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT object_type_attributes_object_type_id_fkey ON dashboard_public.object_type_attributes IS E'@omit manyToMany';

CREATE INDEX object_type_attributes_object_type_id_idx ON dashboard_public.object_type_attributes ( object_type_id );

ALTER TABLE dashboard_public.object_type_attributes ADD COLUMN  quantity_id uuid;

ALTER TABLE dashboard_public.object_type_attributes ADD CONSTRAINT object_type_attributes_quantity_id_fkey FOREIGN KEY ( quantity_id ) REFERENCES dashboard_public.quantities ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT object_type_attributes_quantity_id_fkey ON dashboard_public.object_type_attributes IS E'@omit manyToMany';

CREATE INDEX object_type_attributes_quantity_id_idx ON dashboard_public.object_type_attributes ( quantity_id );

ALTER TABLE dashboard_public.object_type_attributes ADD COLUMN  unit_id uuid;

ALTER TABLE dashboard_public.object_type_attributes ADD CONSTRAINT object_type_attributes_unit_id_fkey FOREIGN KEY ( unit_id ) REFERENCES dashboard_public.units ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT object_type_attributes_unit_id_fkey ON dashboard_public.object_type_attributes IS E'@omit manyToMany';

CREATE INDEX object_type_attributes_unit_id_idx ON dashboard_public.object_type_attributes ( unit_id );

CREATE TRIGGER object_type_attributes_object_type_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.object_type_attributes 
 FOR EACH ROW
 WHEN ( old.object_type_id IS DISTINCT FROM new.object_type_id AND old.object_type_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','object_type_id' );

ALTER TABLE dashboard_public.object_type_attributes ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.object_type_attributes TO authenticated;

GRANT SELECT ON TABLE dashboard_public.object_type_attributes TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.object_type_attributes TO authenticated;

GRANT DELETE ON TABLE dashboard_public.object_type_attributes TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.object_type_attributes FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_public.object_type_attributes FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_upd ON dashboard_public.object_type_attributes FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_del ON dashboard_public.object_type_attributes FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE TABLE dashboard_public.object_type_values (
  
);

ALTER TABLE dashboard_public.object_type_values DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.object_type_values ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.object_type_values ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.object_type_values ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.object_type_values ADD CONSTRAINT object_type_values_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.object_type_values ADD COLUMN  name text;

ALTER TABLE dashboard_public.object_type_values ADD COLUMN  description text;

ALTER TABLE dashboard_public.object_type_values ADD COLUMN  photo image;

ALTER TABLE dashboard_public.object_type_values ADD COLUMN  icon image;

ALTER TABLE dashboard_public.object_type_values ADD COLUMN  type text;

ALTER TABLE dashboard_public.object_type_values ALTER COLUMN type SET DEFAULT 'text';

ALTER TABLE dashboard_public.object_type_values ADD COLUMN  location geometry(point, 4326);

ALTER TABLE dashboard_public.object_type_values ADD COLUMN  text text;

ALTER TABLE dashboard_public.object_type_values ADD COLUMN  numeric numeric;

ALTER TABLE dashboard_public.object_type_values ADD COLUMN  image image;

ALTER TABLE dashboard_public.object_type_values ADD COLUMN  data jsonb;

ALTER TABLE dashboard_public.object_type_values ADD COLUMN  value_order int;

ALTER TABLE dashboard_public.object_type_values ALTER COLUMN value_order SET DEFAULT 0;

ALTER TABLE dashboard_public.object_type_values ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.object_type_values ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.object_type_values 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.object_type_values ( created_by );

CREATE INDEX ON dashboard_public.object_type_values ( updated_by );

ALTER TABLE dashboard_public.object_type_values ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.object_type_values ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.object_type_values ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.object_type_values ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.object_type_values 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.object_type_values ( created_at );

CREATE INDEX ON dashboard_public.object_type_values ( updated_at );

ALTER TABLE dashboard_public.object_type_values ADD COLUMN  attr_id uuid;

ALTER TABLE dashboard_public.object_type_values ALTER COLUMN attr_id SET NOT NULL;

ALTER TABLE dashboard_public.object_type_values ADD CONSTRAINT object_type_values_attr_id_fkey FOREIGN KEY ( attr_id ) REFERENCES dashboard_public.object_type_attributes ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT object_type_values_attr_id_fkey ON dashboard_public.object_type_values IS E'@omit manyToMany';

CREATE INDEX object_type_values_attr_id_idx ON dashboard_public.object_type_values ( attr_id );

CREATE TRIGGER object_type_values_attr_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.object_type_values 
 FOR EACH ROW
 WHEN ( old.attr_id IS DISTINCT FROM new.attr_id AND old.attr_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','attr_id' );

ALTER TABLE dashboard_public.object_type_values ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.object_type_values TO authenticated;

GRANT SELECT ON TABLE dashboard_public.object_type_values TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.object_type_values TO authenticated;

GRANT DELETE ON TABLE dashboard_public.object_type_values TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.object_type_values FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_public.object_type_values FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_upd ON dashboard_public.object_type_values FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_del ON dashboard_public.object_type_values FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE TABLE dashboard_public.object_attributes (
  
);

ALTER TABLE dashboard_public.object_attributes DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.object_attributes ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.object_attributes ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.object_attributes ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.object_attributes ADD CONSTRAINT object_attributes_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.object_attributes ADD COLUMN  description text;

ALTER TABLE dashboard_public.object_attributes ADD COLUMN  location geometry(point, 4326);

ALTER TABLE dashboard_public.object_attributes ADD COLUMN  text text;

ALTER TABLE dashboard_public.object_attributes ADD COLUMN  date timestamptz;

ALTER TABLE dashboard_public.object_attributes ADD COLUMN  numeric numeric;

ALTER TABLE dashboard_public.object_attributes ADD COLUMN  image image;

ALTER TABLE dashboard_public.object_attributes ADD COLUMN  data jsonb;

ALTER TABLE dashboard_public.object_attributes ADD COLUMN  is_private bool;

ALTER TABLE dashboard_public.object_attributes ALTER COLUMN is_private SET NOT NULL;

ALTER TABLE dashboard_public.object_attributes ALTER COLUMN is_private SET DEFAULT FALSE;

ALTER TABLE dashboard_public.object_attributes ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.object_attributes ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.object_attributes ALTER COLUMN owner_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_public.object_attributes ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.object_attributes ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.object_attributes 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.object_attributes ( created_by );

CREATE INDEX ON dashboard_public.object_attributes ( updated_by );

ALTER TABLE dashboard_public.object_attributes ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.object_attributes ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.object_attributes ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.object_attributes ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.object_attributes 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.object_attributes ( created_at );

CREATE INDEX ON dashboard_public.object_attributes ( updated_at );

ALTER TABLE dashboard_public.object_attributes ADD COLUMN  unit_id uuid;

ALTER TABLE dashboard_public.object_attributes ADD CONSTRAINT object_attributes_unit_id_fkey FOREIGN KEY ( unit_id ) REFERENCES dashboard_public.units ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT object_attributes_unit_id_fkey ON dashboard_public.object_attributes IS E'@omit manyToMany';

CREATE INDEX object_attributes_unit_id_idx ON dashboard_public.object_attributes ( unit_id );

ALTER TABLE dashboard_public.object_attributes ADD CONSTRAINT object_attributes_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT object_attributes_owner_id_fkey ON dashboard_public.object_attributes IS E'@omit manyToMany';

CREATE INDEX object_attributes_owner_id_idx ON dashboard_public.object_attributes ( owner_id );

ALTER TABLE dashboard_public.object_attributes ADD COLUMN  value_id uuid;

ALTER TABLE dashboard_public.object_attributes ADD CONSTRAINT object_attributes_value_id_fkey FOREIGN KEY ( value_id ) REFERENCES dashboard_public.object_type_values ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT object_attributes_value_id_fkey ON dashboard_public.object_attributes IS E'@omit manyToMany';

CREATE INDEX object_attributes_value_id_idx ON dashboard_public.object_attributes ( value_id );

ALTER TABLE dashboard_public.object_attributes ADD COLUMN  object_id uuid;

ALTER TABLE dashboard_public.object_attributes ALTER COLUMN object_id SET NOT NULL;

ALTER TABLE dashboard_public.object_attributes ADD CONSTRAINT object_attributes_object_id_fkey FOREIGN KEY ( object_id ) REFERENCES dashboard_public.objects ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT object_attributes_object_id_fkey ON dashboard_public.object_attributes IS E'@omit manyToMany';

CREATE INDEX object_attributes_object_id_idx ON dashboard_public.object_attributes ( object_id );

CREATE TRIGGER object_attributes_object_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.object_attributes 
 FOR EACH ROW
 WHEN ( old.object_id IS DISTINCT FROM new.object_id AND old.object_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','object_id' );

CREATE INDEX object_attributes_is_private_idx ON dashboard_public.object_attributes ( is_private );

ALTER TABLE dashboard_public.object_attributes ADD COLUMN  object_type_attribute_id uuid;

ALTER TABLE dashboard_public.object_attributes ALTER COLUMN object_type_attribute_id SET NOT NULL;

ALTER TABLE dashboard_public.object_attributes ADD CONSTRAINT object_attributes_object_type_attribute_id_fkey FOREIGN KEY ( object_type_attribute_id ) REFERENCES dashboard_public.object_type_attributes ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT object_attributes_object_type_attribute_id_fkey ON dashboard_public.object_attributes IS E'@omit manyToMany';

CREATE INDEX object_attributes_object_type_attribute_id_idx ON dashboard_public.object_attributes ( object_type_attribute_id );

ALTER TABLE dashboard_public.object_attributes ADD CONSTRAINT object_attributes_object_id_object_type_attribute_id_key UNIQUE ( object_id, object_type_attribute_id );

COMMENT ON CONSTRAINT object_attributes_object_id_object_type_attribute_id_key ON dashboard_public.object_attributes IS E'@omit';

CREATE FUNCTION dashboard_private.object_attributes_denorm_object_id (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  SELECT ref.is_private,
ref.owner_id FROM "dashboard_public".objects AS ref WHERE ref.id = new.object_id
  INTO new.is_private,
new.owner_id;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_object_id 
 BEFORE INSERT ON dashboard_public.object_attributes 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. object_attributes_denorm_object_id (  );

CREATE TRIGGER _000000000_ensure_update_object_id 
 BEFORE UPDATE ON dashboard_public.object_attributes 
 FOR EACH ROW
 WHEN ( old.object_id IS DISTINCT FROM new.object_id OR old.is_private IS DISTINCT FROM new.is_private OR old.owner_id IS DISTINCT FROM new.owner_id ) 
 EXECUTE PROCEDURE dashboard_private. object_attributes_denorm_object_id (  );

ALTER TABLE dashboard_public.object_attributes ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.object_attributes TO authenticated;

GRANT SELECT ON TABLE dashboard_public.object_attributes TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.object_attributes TO authenticated;

GRANT DELETE ON TABLE dashboard_public.object_attributes TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.object_attributes FOR INSERT TO authenticated WITH CHECK ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_sel ON dashboard_public.object_attributes FOR SELECT TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_upd ON dashboard_public.object_attributes FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_del ON dashboard_public.object_attributes FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_upd_admin ON dashboard_public.object_attributes FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_del_admin ON dashboard_public.object_attributes FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_sel_public ON dashboard_public.object_attributes FOR SELECT TO authenticated USING ( is_private IS NOT TRUE );

CREATE TABLE dashboard_public.object_records (
  
);

ALTER TABLE dashboard_public.object_records DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.object_records ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.object_records ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.object_records ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.object_records ADD CONSTRAINT object_records_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.object_records ADD COLUMN  description text;

ALTER TABLE dashboard_public.object_records ADD COLUMN  location geometry(point, 4326);

ALTER TABLE dashboard_public.object_records ADD COLUMN  text text;

ALTER TABLE dashboard_public.object_records ADD COLUMN  date timestamptz;

ALTER TABLE dashboard_public.object_records ADD COLUMN  numeric numeric;

ALTER TABLE dashboard_public.object_records ADD COLUMN  image image;

ALTER TABLE dashboard_public.object_records ADD COLUMN  data jsonb;

ALTER TABLE dashboard_public.object_records ADD COLUMN  is_private bool;

ALTER TABLE dashboard_public.object_records ALTER COLUMN is_private SET NOT NULL;

ALTER TABLE dashboard_public.object_records ALTER COLUMN is_private SET DEFAULT FALSE;

ALTER TABLE dashboard_public.object_records ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.object_records ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.object_records ALTER COLUMN owner_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_public.object_records ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.object_records ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.object_records 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.object_records ( created_by );

CREATE INDEX ON dashboard_public.object_records ( updated_by );

ALTER TABLE dashboard_public.object_records ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.object_records ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.object_records ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.object_records ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.object_records 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.object_records ( created_at );

CREATE INDEX ON dashboard_public.object_records ( updated_at );

ALTER TABLE dashboard_public.object_records ADD COLUMN  unit_id uuid;

ALTER TABLE dashboard_public.object_records ADD CONSTRAINT object_records_unit_id_fkey FOREIGN KEY ( unit_id ) REFERENCES dashboard_public.units ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT object_records_unit_id_fkey ON dashboard_public.object_records IS E'@omit manyToMany';

CREATE INDEX object_records_unit_id_idx ON dashboard_public.object_records ( unit_id );

ALTER TABLE dashboard_public.object_records ADD CONSTRAINT object_records_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT object_records_owner_id_fkey ON dashboard_public.object_records IS E'@omit manyToMany';

CREATE INDEX object_records_owner_id_idx ON dashboard_public.object_records ( owner_id );

ALTER TABLE dashboard_public.object_records ADD COLUMN  value_id uuid;

ALTER TABLE dashboard_public.object_records ADD CONSTRAINT object_records_value_id_fkey FOREIGN KEY ( value_id ) REFERENCES dashboard_public.object_type_values ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT object_records_value_id_fkey ON dashboard_public.object_records IS E'@omit manyToMany';

CREATE INDEX object_records_value_id_idx ON dashboard_public.object_records ( value_id );

ALTER TABLE dashboard_public.object_records ADD COLUMN  object_id uuid;

ALTER TABLE dashboard_public.object_records ALTER COLUMN object_id SET NOT NULL;

ALTER TABLE dashboard_public.object_records ADD CONSTRAINT object_records_object_id_fkey FOREIGN KEY ( object_id ) REFERENCES dashboard_public.objects ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT object_records_object_id_fkey ON dashboard_public.object_records IS E'@omit manyToMany';

CREATE INDEX object_records_object_id_idx ON dashboard_public.object_records ( object_id );

CREATE TRIGGER object_records_object_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.object_records 
 FOR EACH ROW
 WHEN ( old.object_id IS DISTINCT FROM new.object_id AND old.object_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','object_id' );

CREATE INDEX object_records_is_private_idx ON dashboard_public.object_records ( is_private );

ALTER TABLE dashboard_public.object_records ADD COLUMN  object_type_attribute_id uuid;

ALTER TABLE dashboard_public.object_records ALTER COLUMN object_type_attribute_id SET NOT NULL;

ALTER TABLE dashboard_public.object_records ADD CONSTRAINT object_records_object_type_attribute_id_fkey FOREIGN KEY ( object_type_attribute_id ) REFERENCES dashboard_public.object_type_attributes ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT object_records_object_type_attribute_id_fkey ON dashboard_public.object_records IS E'@omit manyToMany';

CREATE INDEX object_records_object_type_attribute_id_idx ON dashboard_public.object_records ( object_type_attribute_id );

CREATE FUNCTION dashboard_private.object_records_denorm_object_id (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  SELECT ref.is_private,
ref.owner_id FROM "dashboard_public".objects AS ref WHERE ref.id = new.object_id
  INTO new.is_private,
new.owner_id;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_object_id 
 BEFORE INSERT ON dashboard_public.object_records 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. object_records_denorm_object_id (  );

CREATE TRIGGER _000000000_ensure_update_object_id 
 BEFORE UPDATE ON dashboard_public.object_records 
 FOR EACH ROW
 WHEN ( old.object_id IS DISTINCT FROM new.object_id OR old.is_private IS DISTINCT FROM new.is_private OR old.owner_id IS DISTINCT FROM new.owner_id ) 
 EXECUTE PROCEDURE dashboard_private. object_records_denorm_object_id (  );

ALTER TABLE dashboard_public.object_records ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.object_records TO authenticated;

GRANT SELECT ON TABLE dashboard_public.object_records TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.object_records TO authenticated;

GRANT DELETE ON TABLE dashboard_public.object_records TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.object_records FOR INSERT TO authenticated WITH CHECK ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_sel ON dashboard_public.object_records FOR SELECT TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_upd ON dashboard_public.object_records FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_del ON dashboard_public.object_records FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_upd_admin ON dashboard_public.object_records FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_del_admin ON dashboard_public.object_records FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_sel_public ON dashboard_public.object_records FOR SELECT TO authenticated USING ( is_private IS NOT TRUE );

CREATE TABLE dashboard_public.impacts (
  
);

ALTER TABLE dashboard_public.impacts DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.impacts ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.impacts ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.impacts ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.impacts ADD CONSTRAINT impacts_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.impacts ADD COLUMN  name text;

ALTER TABLE dashboard_public.impacts ADD COLUMN  type text;

COMMENT ON COLUMN dashboard_public.impacts.type IS E'if no object_type exists, use this';

ALTER TABLE dashboard_public.impacts ADD COLUMN  impact_type text;

COMMENT ON COLUMN dashboard_public.impacts.impact_type IS E'if no impact_object_type exists, use this';

ALTER TABLE dashboard_public.impacts ADD COLUMN  unit_value numeric;

COMMENT ON COLUMN dashboard_public.impacts.unit_value IS E'magnitude or number of the quantity';

ALTER TABLE dashboard_public.impacts ADD COLUMN  impact_unit_value numeric;

COMMENT ON COLUMN dashboard_public.impacts.impact_unit_value IS E'magnitude or number of the impact quantity';

ALTER TABLE dashboard_public.impacts ADD COLUMN  net_gain boolean;

ALTER TABLE dashboard_public.impacts ALTER COLUMN net_gain SET NOT NULL;

ALTER TABLE dashboard_public.impacts ALTER COLUMN net_gain SET DEFAULT TRUE;

COMMENT ON COLUMN dashboard_public.impacts.net_gain IS E'overall net gain or loss';

ALTER TABLE dashboard_public.impacts ADD COLUMN  per_interval interval;

COMMENT ON COLUMN dashboard_public.impacts.per_interval IS E'impact is measured per this interval';

ALTER TABLE dashboard_public.impacts ADD COLUMN  per_value numeric;

COMMENT ON COLUMN dashboard_public.impacts.per_value IS E'impact value measured for per_unit field';

ALTER TABLE dashboard_public.impacts ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.impacts ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.impacts 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.impacts ( created_by );

CREATE INDEX ON dashboard_public.impacts ( updated_by );

ALTER TABLE dashboard_public.impacts ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.impacts ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.impacts ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.impacts ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.impacts 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.impacts ( created_at );

CREATE INDEX ON dashboard_public.impacts ( updated_at );

ALTER TABLE dashboard_public.impacts ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.impacts ADD CONSTRAINT impacts_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT impacts_owner_id_fkey ON dashboard_public.impacts IS E'@omit manyToMany';

CREATE INDEX impacts_owner_id_idx ON dashboard_public.impacts ( owner_id );

ALTER TABLE dashboard_public.impacts ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.impacts TO authenticated;

GRANT SELECT ON TABLE dashboard_public.impacts TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.impacts TO authenticated;

GRANT DELETE ON TABLE dashboard_public.impacts TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.impacts FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_public.impacts FOR INSERT TO authenticated WITH CHECK ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000010000000000000') = '00000000000000000010000000000000')) AND owner_id IN (SELECT acl.actor_id FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE (acl.actor_id = owner_id AND (acl.permissions & '00000000000000000000100000000000') = '00000000000000000000100000000000')) );

CREATE POLICY auth_upd ON dashboard_public.impacts FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000')) OR EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE)) );

CREATE POLICY auth_del ON dashboard_public.impacts FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000')) OR EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE)) );

ALTER TABLE dashboard_public.impacts ADD COLUMN  unit_id uuid;

ALTER TABLE dashboard_public.impacts ADD CONSTRAINT impacts_unit_id_fkey FOREIGN KEY ( unit_id ) REFERENCES dashboard_public.units ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT impacts_unit_id_fkey ON dashboard_public.impacts IS E'@omit manyToMany';

CREATE INDEX impacts_unit_id_idx ON dashboard_public.impacts ( unit_id );

ALTER TABLE dashboard_public.impacts ADD COLUMN  per_unit_id uuid;

ALTER TABLE dashboard_public.impacts ADD CONSTRAINT impacts_per_unit_id_fkey FOREIGN KEY ( per_unit_id ) REFERENCES dashboard_public.units ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT impacts_per_unit_id_fkey ON dashboard_public.impacts IS E'@omit manyToMany';

CREATE INDEX impacts_per_unit_id_idx ON dashboard_public.impacts ( per_unit_id );

ALTER TABLE dashboard_public.impacts ADD COLUMN  impact_unit_id uuid;

ALTER TABLE dashboard_public.impacts ADD CONSTRAINT impacts_impact_unit_id_fkey FOREIGN KEY ( impact_unit_id ) REFERENCES dashboard_public.units ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT impacts_impact_unit_id_fkey ON dashboard_public.impacts IS E'@omit manyToMany';

CREATE INDEX impacts_impact_unit_id_idx ON dashboard_public.impacts ( impact_unit_id );

ALTER TABLE dashboard_public.impacts ADD COLUMN  object_type_id uuid;

ALTER TABLE dashboard_public.impacts ADD CONSTRAINT impacts_object_type_id_fkey FOREIGN KEY ( object_type_id ) REFERENCES dashboard_public.object_types ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT impacts_object_type_id_fkey ON dashboard_public.impacts IS E'@omit manyToMany';

CREATE INDEX impacts_object_type_id_idx ON dashboard_public.impacts ( object_type_id );

ALTER TABLE dashboard_public.impacts ADD COLUMN  impact_object_type_id uuid;

ALTER TABLE dashboard_public.impacts ADD CONSTRAINT impacts_impact_object_type_id_fkey FOREIGN KEY ( impact_object_type_id ) REFERENCES dashboard_public.object_types ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT impacts_impact_object_type_id_fkey ON dashboard_public.impacts IS E'@omit manyToMany';

CREATE INDEX impacts_impact_object_type_id_idx ON dashboard_public.impacts ( impact_object_type_id );

CREATE TABLE dashboard_public.impacts_conditions (
  
);

ALTER TABLE dashboard_public.impacts_conditions DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.impacts_conditions ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.impacts_conditions ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.impacts_conditions ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.impacts_conditions ADD CONSTRAINT impacts_conditions_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.impacts_conditions ADD COLUMN  name text;

ALTER TABLE dashboard_public.impacts_conditions ADD COLUMN  op int;

ALTER TABLE dashboard_public.impacts_conditions ALTER COLUMN op SET NOT NULL;

ALTER TABLE dashboard_public.impacts_conditions ALTER COLUMN op SET DEFAULT 0;

COMMENT ON COLUMN dashboard_public.impacts_conditions.op IS E'eq:0, lt:1, lte:2, gte:3, neq:4';

ALTER TABLE dashboard_public.impacts_conditions ADD COLUMN  value text;

ALTER TABLE dashboard_public.impacts_conditions ALTER COLUMN value SET NOT NULL;

ALTER TABLE dashboard_public.impacts_conditions ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.impacts_conditions ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.impacts_conditions 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.impacts_conditions ( created_by );

CREATE INDEX ON dashboard_public.impacts_conditions ( updated_by );

ALTER TABLE dashboard_public.impacts_conditions ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.impacts_conditions ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.impacts_conditions ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.impacts_conditions ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.impacts_conditions 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.impacts_conditions ( created_at );

CREATE INDEX ON dashboard_public.impacts_conditions ( updated_at );

ALTER TABLE dashboard_public.impacts_conditions ADD COLUMN  impact_id uuid;

ALTER TABLE dashboard_public.impacts_conditions ALTER COLUMN impact_id SET NOT NULL;

ALTER TABLE dashboard_public.impacts_conditions ADD CONSTRAINT impacts_conditions_impact_id_fkey FOREIGN KEY ( impact_id ) REFERENCES dashboard_public.impacts ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT impacts_conditions_impact_id_fkey ON dashboard_public.impacts_conditions IS E'@omit manyToMany';

CREATE INDEX impacts_conditions_impact_id_idx ON dashboard_public.impacts_conditions ( impact_id );

ALTER TABLE dashboard_public.impacts_conditions ADD COLUMN  attr_id uuid;

ALTER TABLE dashboard_public.impacts_conditions ALTER COLUMN attr_id SET NOT NULL;

ALTER TABLE dashboard_public.impacts_conditions ADD CONSTRAINT impacts_conditions_attr_id_fkey FOREIGN KEY ( attr_id ) REFERENCES dashboard_public.object_type_attributes ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT impacts_conditions_attr_id_fkey ON dashboard_public.impacts_conditions IS E'@omit manyToMany';

CREATE INDEX impacts_conditions_attr_id_idx ON dashboard_public.impacts_conditions ( attr_id );

ALTER TABLE dashboard_public.impacts_conditions ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.impacts_conditions ADD CONSTRAINT impacts_conditions_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT impacts_conditions_owner_id_fkey ON dashboard_public.impacts_conditions IS E'@omit manyToMany';

CREATE INDEX impacts_conditions_owner_id_idx ON dashboard_public.impacts_conditions ( owner_id );

CREATE TRIGGER impacts_conditions_owner_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.impacts_conditions 
 FOR EACH ROW
 WHEN ( old.owner_id IS DISTINCT FROM new.owner_id AND old.owner_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','owner_id' );

CREATE TRIGGER impacts_conditions_impact_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.impacts_conditions 
 FOR EACH ROW
 WHEN ( old.impact_id IS DISTINCT FROM new.impact_id AND old.impact_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','impact_id' );

ALTER TABLE dashboard_public.impacts_conditions ALTER COLUMN owner_id SET DEFAULT uuid_nil();

CREATE FUNCTION dashboard_private.impacts_conditions_denorm_impact_id (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  SELECT ref.owner_id FROM "dashboard_public".impacts AS ref WHERE ref.id = new.impact_id
  INTO new.owner_id;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_impact_id 
 BEFORE INSERT ON dashboard_public.impacts_conditions 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. impacts_conditions_denorm_impact_id (  );

CREATE TRIGGER _000000000_ensure_update_impact_id 
 BEFORE UPDATE ON dashboard_public.impacts_conditions 
 FOR EACH ROW
 WHEN ( old.impact_id IS DISTINCT FROM new.impact_id OR old.owner_id IS DISTINCT FROM new.owner_id ) 
 EXECUTE PROCEDURE dashboard_private. impacts_conditions_denorm_impact_id (  );

ALTER TABLE dashboard_public.impacts_conditions ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.impacts_conditions TO authenticated;

GRANT SELECT ON TABLE dashboard_public.impacts_conditions TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.impacts_conditions TO authenticated;

GRANT DELETE ON TABLE dashboard_public.impacts_conditions TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.impacts_conditions FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_upd ON dashboard_public.impacts_conditions FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE POLICY auth_del ON dashboard_public.impacts_conditions FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE POLICY auth_ins ON dashboard_public.impacts_conditions FOR INSERT TO authenticated WITH CHECK ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000')) AND impact_id IN (SELECT obj.id FROM dashboard_memberships_private.memberships_acl AS acl INNER JOIN dashboard_public.impacts AS obj ON acl.entity_id = obj.owner_id WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000')) );

CREATE TABLE dashboard_public.goals (
  
);

ALTER TABLE dashboard_public.goals DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.goals ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.goals ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.goals ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.goals ADD CONSTRAINT goals_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.goals ADD COLUMN  name text;

ALTER TABLE dashboard_public.goals ADD COLUMN  slug citext;

ALTER TABLE dashboard_public.goals ADD CONSTRAINT goals_slug_chk CHECK ( character_length(slug) <= 2048 );

ALTER TABLE dashboard_public.goals ADD COLUMN  short_name text;

ALTER TABLE dashboard_public.goals ADD COLUMN  impact_type text;

COMMENT ON COLUMN dashboard_public.goals.impact_type IS E'if no impact_object_type exists, use this';

ALTER TABLE dashboard_public.goals ADD COLUMN  impact_unit_value numeric;

COMMENT ON COLUMN dashboard_public.goals.impact_unit_value IS E'magnitude or number of the impact quantity';

ALTER TABLE dashboard_public.goals ADD COLUMN  per_interval interval;

COMMENT ON COLUMN dashboard_public.goals.per_interval IS E'impact is measured per this interval';

ALTER TABLE dashboard_public.goals ADD COLUMN  per_value numeric;

COMMENT ON COLUMN dashboard_public.goals.per_value IS E'impact value measured for per_unit field';

ALTER TABLE dashboard_public.goals ADD COLUMN  icon text;

ALTER TABLE dashboard_public.goals ADD COLUMN  image image;

ALTER TABLE dashboard_public.goals ADD COLUMN  sub_head text;

ALTER TABLE dashboard_public.goals ADD COLUMN  tags citext[];

ALTER TABLE dashboard_public.goals ADD COLUMN  search tsvector;

ALTER TABLE dashboard_public.goals ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.goals ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.goals 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.goals ( created_by );

CREATE INDEX ON dashboard_public.goals ( updated_by );

ALTER TABLE dashboard_public.goals ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.goals ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.goals ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.goals ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.goals 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.goals ( created_at );

CREATE INDEX ON dashboard_public.goals ( updated_at );

ALTER TABLE dashboard_public.goals ADD COLUMN  parent_id uuid;

ALTER TABLE dashboard_public.goals ADD CONSTRAINT goals_parent_id_fkey FOREIGN KEY ( parent_id ) REFERENCES dashboard_public.goals ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT goals_parent_id_fkey ON dashboard_public.goals IS E'@omit manyToMany';

CREATE INDEX goals_parent_id_idx ON dashboard_public.goals ( parent_id );

ALTER TABLE dashboard_public.goals ADD COLUMN  per_unit_id uuid;

ALTER TABLE dashboard_public.goals ADD CONSTRAINT goals_per_unit_id_fkey FOREIGN KEY ( per_unit_id ) REFERENCES dashboard_public.units ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT goals_per_unit_id_fkey ON dashboard_public.goals IS E'@omit manyToMany';

CREATE INDEX goals_per_unit_id_idx ON dashboard_public.goals ( per_unit_id );

ALTER TABLE dashboard_public.goals ADD COLUMN  impact_unit_id uuid;

ALTER TABLE dashboard_public.goals ADD CONSTRAINT goals_impact_unit_id_fkey FOREIGN KEY ( impact_unit_id ) REFERENCES dashboard_public.units ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT goals_impact_unit_id_fkey ON dashboard_public.goals IS E'@omit manyToMany';

CREATE INDEX goals_impact_unit_id_idx ON dashboard_public.goals ( impact_unit_id );

ALTER TABLE dashboard_public.goals ADD COLUMN  impact_object_type_id uuid;

ALTER TABLE dashboard_public.goals ADD CONSTRAINT goals_impact_object_type_id_fkey FOREIGN KEY ( impact_object_type_id ) REFERENCES dashboard_public.object_types ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT goals_impact_object_type_id_fkey ON dashboard_public.goals IS E'@omit manyToMany';

CREATE INDEX goals_impact_object_type_id_idx ON dashboard_public.goals ( impact_object_type_id );

CREATE FUNCTION dashboard_private.goals_search_tsv (  ) RETURNS trigger AS $EOFCODE$ 
 
BEGIN
NEW.search = (setweight(to_tsvector('pg_catalog.english', COALESCE(NEW.sub_head, '')), 'B') || (setweight(to_tsvector('pg_catalog.english', COALESCE(array_to_string(NEW.tags::citext[], ' '), '')), 'C') || (setweight(to_tsvector('pg_catalog.english', COALESCE(NEW.name, '')), 'B') || setweight(to_tsvector('pg_catalog.simple', COALESCE(NEW.name, '')), 'A'))));
RETURN NEW;
END; 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER goals_search_tsv_insert_tg 
 BEFORE INSERT ON dashboard_public.goals 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. goals_search_tsv (  );

CREATE TRIGGER goals_search_tsv_update_tg 
 BEFORE UPDATE ON dashboard_public.goals 
 FOR EACH ROW
 WHEN ( old.name IS DISTINCT FROM new.name OR old.tags IS DISTINCT FROM new.tags OR old.sub_head IS DISTINCT FROM new.sub_head ) 
 EXECUTE PROCEDURE dashboard_private. goals_search_tsv (  );

ALTER TABLE dashboard_public.goals ADD CONSTRAINT goals_name_key UNIQUE ( name );

COMMENT ON CONSTRAINT goals_name_key ON dashboard_public.goals IS NULL;

ALTER TABLE dashboard_public.goals ADD CONSTRAINT goals_slug_key UNIQUE ( slug );

COMMENT ON CONSTRAINT goals_slug_key ON dashboard_public.goals IS NULL;

CREATE FUNCTION dashboard_private.goals_slg_slug (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  new.slug = inflection.slugify(new.slug);
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER insert_slg_slug 
 BEFORE INSERT ON dashboard_public.goals 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. goals_slg_slug (  );

CREATE TRIGGER update_slg_slug 
 BEFORE UPDATE ON dashboard_public.goals 
 FOR EACH ROW
 WHEN ( OLD.slug IS DISTINCT FROM NEW.slug ) 
 EXECUTE PROCEDURE dashboard_private. goals_slg_slug (  );

CREATE INDEX goals_search_idx ON dashboard_public.goals USING GIN ( search );

ALTER TABLE dashboard_public.goals ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.goals TO authenticated;

GRANT SELECT ON TABLE dashboard_public.goals TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.goals TO authenticated;

GRANT DELETE ON TABLE dashboard_public.goals TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.goals FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_public.goals FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE) );

CREATE POLICY auth_upd ON dashboard_public.goals FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE) );

CREATE POLICY auth_del ON dashboard_public.goals FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE) );

CREATE TABLE dashboard_public.goal_explanations (
  
);

ALTER TABLE dashboard_public.goal_explanations DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.goal_explanations ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.goal_explanations ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.goal_explanations ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.goal_explanations ADD CONSTRAINT goal_explanations_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.goal_explanations ADD COLUMN  audio upload;

ALTER TABLE dashboard_public.goal_explanations ADD COLUMN  audio_duration interval;

ALTER TABLE dashboard_public.goal_explanations ADD COLUMN  explanation_title text;

ALTER TABLE dashboard_public.goal_explanations ADD COLUMN  explanation text;

ALTER TABLE dashboard_public.goal_explanations ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.goal_explanations ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.goal_explanations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.goal_explanations ( created_by );

CREATE INDEX ON dashboard_public.goal_explanations ( updated_by );

ALTER TABLE dashboard_public.goal_explanations ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.goal_explanations ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.goal_explanations ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.goal_explanations ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.goal_explanations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.goal_explanations ( created_at );

CREATE INDEX ON dashboard_public.goal_explanations ( updated_at );

ALTER TABLE dashboard_public.goal_explanations ADD COLUMN  goal_id uuid;

ALTER TABLE dashboard_public.goal_explanations ALTER COLUMN goal_id SET NOT NULL;

ALTER TABLE dashboard_public.goal_explanations ADD CONSTRAINT goal_explanations_goal_id_fkey FOREIGN KEY ( goal_id ) REFERENCES dashboard_public.goals ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT goal_explanations_goal_id_fkey ON dashboard_public.goal_explanations IS NULL;

CREATE INDEX goal_explanations_goal_id_idx ON dashboard_public.goal_explanations ( goal_id );

ALTER TABLE dashboard_public.goal_explanations ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.goal_explanations TO authenticated;

GRANT SELECT ON TABLE dashboard_public.goal_explanations TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.goal_explanations TO authenticated;

GRANT DELETE ON TABLE dashboard_public.goal_explanations TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.goal_explanations FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_public.goal_explanations FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE) );

CREATE POLICY auth_upd ON dashboard_public.goal_explanations FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE) );

CREATE POLICY auth_del ON dashboard_public.goal_explanations FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE) );

CREATE TABLE dashboard_public.actions (
  
);

ALTER TABLE dashboard_public.actions DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.actions ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.actions ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.actions ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.actions ADD CONSTRAINT actions_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.actions ADD COLUMN  slug citext;

ALTER TABLE dashboard_public.actions ADD CONSTRAINT actions_slug_chk CHECK ( character_length(slug) <= 2048 );

ALTER TABLE dashboard_public.actions ADD COLUMN  photo image;

ALTER TABLE dashboard_public.actions ADD COLUMN  share_image image;

ALTER TABLE dashboard_public.actions ADD COLUMN  title text;

ALTER TABLE dashboard_public.actions ADD COLUMN  title_object_template text;

ALTER TABLE dashboard_public.actions ADD COLUMN  url url;

ALTER TABLE dashboard_public.actions ADD COLUMN  description text;

ALTER TABLE dashboard_public.actions ADD COLUMN  discovery_header text;

ALTER TABLE dashboard_public.actions ADD COLUMN  discovery_description text;

ALTER TABLE dashboard_public.actions ADD COLUMN  notification_text text;

ALTER TABLE dashboard_public.actions ADD COLUMN  notification_object_template text;

ALTER TABLE dashboard_public.actions ADD COLUMN  enable_notifications boolean;

ALTER TABLE dashboard_public.actions ALTER COLUMN enable_notifications SET DEFAULT FALSE;

ALTER TABLE dashboard_public.actions ADD COLUMN  enable_notifications_text text;

ALTER TABLE dashboard_public.actions ADD COLUMN  search tsvector;

ALTER TABLE dashboard_public.actions ADD COLUMN  location geometry(point, 4326);

ALTER TABLE dashboard_public.actions ADD COLUMN  location_radius numeric;

ALTER TABLE dashboard_public.actions ADD COLUMN  time_required interval;

ALTER TABLE dashboard_public.actions ADD COLUMN  start_date timestamptz;

ALTER TABLE dashboard_public.actions ADD COLUMN  end_date timestamptz;

ALTER TABLE dashboard_public.actions ADD COLUMN  is_approved boolean;

ALTER TABLE dashboard_public.actions ALTER COLUMN is_approved SET NOT NULL;

ALTER TABLE dashboard_public.actions ALTER COLUMN is_approved SET DEFAULT FALSE;

ALTER TABLE dashboard_public.actions ADD COLUMN  is_published boolean;

ALTER TABLE dashboard_public.actions ALTER COLUMN is_published SET NOT NULL;

ALTER TABLE dashboard_public.actions ALTER COLUMN is_published SET DEFAULT FALSE;

ALTER TABLE dashboard_public.actions ADD COLUMN  is_private boolean;

ALTER TABLE dashboard_public.actions ALTER COLUMN is_private SET NOT NULL;

ALTER TABLE dashboard_public.actions ALTER COLUMN is_private SET DEFAULT FALSE;

ALTER TABLE dashboard_public.actions ADD COLUMN  reputation_amount numeric;

ALTER TABLE dashboard_public.actions ADD COLUMN  reward_amount numeric;

ALTER TABLE dashboard_public.actions ADD COLUMN  activity_feed_text text;

ALTER TABLE dashboard_public.actions ADD COLUMN  call_to_action text;

ALTER TABLE dashboard_public.actions ADD COLUMN  completed_action_text text;

ALTER TABLE dashboard_public.actions ADD COLUMN  already_completed_action_text text;

ALTER TABLE dashboard_public.actions ADD COLUMN  self_verifiable bool;

ALTER TABLE dashboard_public.actions ALTER COLUMN self_verifiable SET NOT NULL;

ALTER TABLE dashboard_public.actions ALTER COLUMN self_verifiable SET DEFAULT FALSE;

ALTER TABLE dashboard_public.actions ADD COLUMN  is_recurring bool;

ALTER TABLE dashboard_public.actions ALTER COLUMN is_recurring SET NOT NULL;

ALTER TABLE dashboard_public.actions ALTER COLUMN is_recurring SET DEFAULT FALSE;

ALTER TABLE dashboard_public.actions ADD COLUMN  recurring_interval interval;

ALTER TABLE dashboard_public.actions ADD COLUMN  once_per_object bool;

ALTER TABLE dashboard_public.actions ALTER COLUMN once_per_object SET NOT NULL;

ALTER TABLE dashboard_public.actions ALTER COLUMN once_per_object SET DEFAULT FALSE;

COMMENT ON COLUMN dashboard_public.actions.once_per_object IS E'if is_recurring is true';

ALTER TABLE dashboard_public.actions ADD COLUMN  minimum_group_members int;

ALTER TABLE dashboard_public.actions ADD COLUMN  minimum_group_unit_amount numeric;

ALTER TABLE dashboard_public.actions ADD COLUMN  minimum_group_unit_id uuid;

ALTER TABLE dashboard_public.actions ADD COLUMN  minimum_group_unit_type text;

COMMENT ON COLUMN dashboard_public.actions.minimum_group_unit_type IS E'if no unit available';

ALTER TABLE dashboard_public.actions ADD COLUMN  limited_to_location bool;

ALTER TABLE dashboard_public.actions ALTER COLUMN limited_to_location SET DEFAULT FALSE;

ALTER TABLE dashboard_public.actions ADD COLUMN  bounds geometry(geometrycollection, 4326);

COMMENT ON COLUMN dashboard_public.actions.bounds IS E'all locations combined using ST_Collect for search optimization';

ALTER TABLE dashboard_public.actions ADD COLUMN  tags citext[];

ALTER TABLE dashboard_public.actions ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.actions ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.actions 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.actions ( created_by );

CREATE INDEX ON dashboard_public.actions ( updated_by );

ALTER TABLE dashboard_public.actions ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.actions ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.actions ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.actions ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.actions 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.actions ( created_at );

CREATE INDEX ON dashboard_public.actions ( updated_at );

ALTER TABLE dashboard_public.actions ADD CONSTRAINT actions_minimum_group_unit_id_fkey FOREIGN KEY ( minimum_group_unit_id ) REFERENCES dashboard_public.units ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT actions_minimum_group_unit_id_fkey ON dashboard_public.actions IS E'@omit manyToMany';

CREATE INDEX actions_minimum_group_unit_id_idx ON dashboard_public.actions ( minimum_group_unit_id );

ALTER TABLE dashboard_public.actions ADD COLUMN  group_id uuid;

ALTER TABLE dashboard_public.actions ADD CONSTRAINT actions_group_id_fkey FOREIGN KEY ( group_id ) REFERENCES dashboard_public.groups ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT actions_group_id_fkey ON dashboard_public.actions IS NULL;

CREATE INDEX actions_group_id_idx ON dashboard_public.actions ( group_id );

ALTER TABLE dashboard_public.actions ADD CONSTRAINT actions_slug_key UNIQUE ( slug );

COMMENT ON CONSTRAINT actions_slug_key ON dashboard_public.actions IS NULL;

CREATE FUNCTION dashboard_private.actions_slg_slug (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  new.slug = inflection.slugify(new.slug);
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER insert_slg_slug 
 BEFORE INSERT ON dashboard_public.actions 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. actions_slg_slug (  );

CREATE TRIGGER update_slg_slug 
 BEFORE UPDATE ON dashboard_public.actions 
 FOR EACH ROW
 WHEN ( OLD.slug IS DISTINCT FROM NEW.slug ) 
 EXECUTE PROCEDURE dashboard_private. actions_slg_slug (  );

CREATE INDEX actions_is_published_idx ON dashboard_public.actions ( is_published );

CREATE INDEX actions_is_private_idx ON dashboard_public.actions ( is_private );

CREATE INDEX actions_start_date_end_date_idx ON dashboard_public.actions ( start_date, end_date );

CREATE INDEX actions_location_idx ON dashboard_public.actions USING GIST ( location );

CREATE INDEX actions_bounds_idx ON dashboard_public.actions USING GIST ( bounds );

ALTER TABLE dashboard_public.actions ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.actions ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.actions ADD CONSTRAINT actions_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT actions_owner_id_fkey ON dashboard_public.actions IS E'@omit manyToMany';

CREATE INDEX actions_owner_id_idx ON dashboard_public.actions ( owner_id );

CREATE TRIGGER actions_owner_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.actions 
 FOR EACH ROW
 WHEN ( old.owner_id IS DISTINCT FROM new.owner_id AND old.owner_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','owner_id' );

ALTER TABLE dashboard_public.actions ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.actions TO authenticated;

GRANT SELECT ON TABLE dashboard_public.actions TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.actions TO authenticated;

GRANT DELETE ON TABLE dashboard_public.actions TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.actions FOR SELECT TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000010000000000000') = '00000000000000000010000000000000')) OR (is_published = TRUE AND is_private = TRUE AND owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id())) OR (is_published = TRUE AND is_private = FALSE) );

CREATE POLICY auth_ins ON dashboard_public.actions FOR INSERT TO authenticated WITH CHECK ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000010000000000000') = '00000000000000000010000000000000')) AND owner_id IN (SELECT acl.actor_id FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE (acl.actor_id = owner_id AND (acl.permissions & '00000000000000000000100000000000') = '00000000000000000000100000000000')) );

CREATE POLICY auth_upd ON dashboard_public.actions FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE POLICY auth_del ON dashboard_public.actions FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE FUNCTION dashboard_private.actions_search_tsv (  ) RETURNS trigger AS $EOFCODE$ 
 
BEGIN
NEW.search = (setweight(to_tsvector('pg_catalog.english', COALESCE(array_to_string(NEW.tags::citext[], ' '), '')), 'B') || (setweight(to_tsvector('pg_catalog.simple', COALESCE(array_to_string(NEW.tags::citext[], ' '), '')), 'A') || (setweight(to_tsvector('pg_catalog.english', COALESCE(NEW.title, '')), 'B') || (setweight(to_tsvector('pg_catalog.simple', COALESCE(NEW.title, '')), 'A') || setweight(to_tsvector('pg_catalog.english', COALESCE(NEW.description, '')), 'C')))));
RETURN NEW;
END; 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER actions_search_tsv_insert_tg 
 BEFORE INSERT ON dashboard_public.actions 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. actions_search_tsv (  );

CREATE TRIGGER actions_search_tsv_update_tg 
 BEFORE UPDATE ON dashboard_public.actions 
 FOR EACH ROW
 WHEN ( old.description IS DISTINCT FROM new.description OR old.title IS DISTINCT FROM new.title OR old.tags IS DISTINCT FROM new.tags ) 
 EXECUTE PROCEDURE dashboard_private. actions_search_tsv (  );

CREATE INDEX actions_search_idx ON dashboard_public.actions USING GIN ( search );

CREATE INDEX actions_tags_idx ON dashboard_public.actions USING GIN ( tags );

CREATE TABLE dashboard_public.action_goals (
  
);

ALTER TABLE dashboard_public.action_goals DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.action_goals ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.action_goals ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.action_goals ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.action_goals ADD CONSTRAINT action_goals_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.action_goals ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.action_goals ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.action_goals 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.action_goals ( created_by );

CREATE INDEX ON dashboard_public.action_goals ( updated_by );

ALTER TABLE dashboard_public.action_goals ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.action_goals ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.action_goals ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.action_goals ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.action_goals 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.action_goals ( created_at );

CREATE INDEX ON dashboard_public.action_goals ( updated_at );

ALTER TABLE dashboard_public.action_goals ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.action_goals ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.action_goals ADD CONSTRAINT action_goals_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT action_goals_owner_id_fkey ON dashboard_public.action_goals IS E'@omit manyToMany';

CREATE INDEX action_goals_owner_id_idx ON dashboard_public.action_goals ( owner_id );

ALTER TABLE dashboard_public.action_goals ADD COLUMN  action_id uuid;

ALTER TABLE dashboard_public.action_goals ALTER COLUMN action_id SET NOT NULL;

ALTER TABLE dashboard_public.action_goals ADD CONSTRAINT action_goals_action_id_fkey FOREIGN KEY ( action_id ) REFERENCES dashboard_public.actions ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT action_goals_action_id_fkey ON dashboard_public.action_goals IS E'@manyToManyFieldName actions';

CREATE INDEX action_goals_action_id_idx ON dashboard_public.action_goals ( action_id );

ALTER TABLE dashboard_public.action_goals ADD COLUMN  goal_id uuid;

ALTER TABLE dashboard_public.action_goals ALTER COLUMN goal_id SET NOT NULL;

ALTER TABLE dashboard_public.action_goals ADD CONSTRAINT action_goals_goal_id_fkey FOREIGN KEY ( goal_id ) REFERENCES dashboard_public.goals ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT action_goals_goal_id_fkey ON dashboard_public.action_goals IS E'@manyToManyFieldName goals';

CREATE INDEX action_goals_goal_id_idx ON dashboard_public.action_goals ( goal_id );

ALTER TABLE dashboard_public.action_goals ADD CONSTRAINT action_goals_action_id_goal_id_key UNIQUE ( action_id, goal_id );

CREATE TRIGGER action_goals_owner_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.action_goals 
 FOR EACH ROW
 WHEN ( old.owner_id IS DISTINCT FROM new.owner_id AND old.owner_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','owner_id' );

CREATE TRIGGER action_goals_action_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.action_goals 
 FOR EACH ROW
 WHEN ( old.action_id IS DISTINCT FROM new.action_id AND old.action_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','action_id' );

ALTER TABLE dashboard_public.action_goals ALTER COLUMN owner_id SET DEFAULT uuid_nil();

CREATE FUNCTION dashboard_private.action_goals_denorm_action_id (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  SELECT ref.owner_id FROM "dashboard_public".actions AS ref WHERE ref.id = new.action_id
  INTO new.owner_id;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_action_id 
 BEFORE INSERT ON dashboard_public.action_goals 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. action_goals_denorm_action_id (  );

CREATE TRIGGER _000000000_ensure_update_action_id 
 BEFORE UPDATE ON dashboard_public.action_goals 
 FOR EACH ROW
 WHEN ( old.action_id IS DISTINCT FROM new.action_id OR old.owner_id IS DISTINCT FROM new.owner_id ) 
 EXECUTE PROCEDURE dashboard_private. action_goals_denorm_action_id (  );

ALTER TABLE dashboard_public.action_goals ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.action_goals TO authenticated;

GRANT SELECT ON TABLE dashboard_public.action_goals TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.action_goals TO authenticated;

GRANT DELETE ON TABLE dashboard_public.action_goals TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.action_goals FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_public.action_goals FOR INSERT TO authenticated WITH CHECK ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE POLICY auth_upd ON dashboard_public.action_goals FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE POLICY auth_del ON dashboard_public.action_goals FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE TABLE dashboard_public.action_variations (
  
);

ALTER TABLE dashboard_public.action_variations DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.action_variations ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.action_variations ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.action_variations ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.action_variations ADD CONSTRAINT action_variations_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.action_variations ADD COLUMN  photo image;

ALTER TABLE dashboard_public.action_variations ADD COLUMN  title text;

ALTER TABLE dashboard_public.action_variations ADD COLUMN  description text;

ALTER TABLE dashboard_public.action_variations ADD COLUMN  income numeric[];

ALTER TABLE dashboard_public.action_variations ADD COLUMN  gender char(1)[];

ALTER TABLE dashboard_public.action_variations ADD COLUMN  dob date[];

ALTER TABLE dashboard_public.action_variations ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.action_variations ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.action_variations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.action_variations ( created_by );

CREATE INDEX ON dashboard_public.action_variations ( updated_by );

ALTER TABLE dashboard_public.action_variations ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.action_variations ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.action_variations ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.action_variations ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.action_variations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.action_variations ( created_at );

CREATE INDEX ON dashboard_public.action_variations ( updated_at );

ALTER TABLE dashboard_public.action_variations ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.action_variations ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.action_variations ADD CONSTRAINT action_variations_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT action_variations_owner_id_fkey ON dashboard_public.action_variations IS E'@omit manyToMany';

CREATE INDEX action_variations_owner_id_idx ON dashboard_public.action_variations ( owner_id );

ALTER TABLE dashboard_public.action_variations ADD COLUMN  action_id uuid;

ALTER TABLE dashboard_public.action_variations ALTER COLUMN action_id SET NOT NULL;

ALTER TABLE dashboard_public.action_variations ADD CONSTRAINT action_variations_action_id_fkey FOREIGN KEY ( action_id ) REFERENCES dashboard_public.actions ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT action_variations_action_id_fkey ON dashboard_public.action_variations IS E'@omit manyToMany';

CREATE INDEX action_variations_action_id_idx ON dashboard_public.action_variations ( action_id );

CREATE TRIGGER action_variations_owner_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.action_variations 
 FOR EACH ROW
 WHEN ( old.owner_id IS DISTINCT FROM new.owner_id AND old.owner_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','owner_id' );

CREATE TRIGGER action_variations_action_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.action_variations 
 FOR EACH ROW
 WHEN ( old.action_id IS DISTINCT FROM new.action_id AND old.action_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','action_id' );

ALTER TABLE dashboard_public.action_variations ALTER COLUMN owner_id SET DEFAULT uuid_nil();

CREATE FUNCTION dashboard_private.action_variations_denorm_action_id (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  SELECT ref.owner_id FROM "dashboard_public".actions AS ref WHERE ref.id = new.action_id
  INTO new.owner_id;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_action_id 
 BEFORE INSERT ON dashboard_public.action_variations 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. action_variations_denorm_action_id (  );

CREATE TRIGGER _000000000_ensure_update_action_id 
 BEFORE UPDATE ON dashboard_public.action_variations 
 FOR EACH ROW
 WHEN ( old.action_id IS DISTINCT FROM new.action_id OR old.owner_id IS DISTINCT FROM new.owner_id ) 
 EXECUTE PROCEDURE dashboard_private. action_variations_denorm_action_id (  );

ALTER TABLE dashboard_public.action_variations ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.action_variations TO authenticated;

GRANT SELECT ON TABLE dashboard_public.action_variations TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.action_variations TO authenticated;

GRANT DELETE ON TABLE dashboard_public.action_variations TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.action_variations FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_public.action_variations FOR INSERT TO authenticated WITH CHECK ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE POLICY auth_upd ON dashboard_public.action_variations FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE POLICY auth_del ON dashboard_public.action_variations FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE TABLE dashboard_public.action_item_types (
  
);

ALTER TABLE dashboard_public.action_item_types DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.action_item_types ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.action_item_types ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.action_item_types ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.action_item_types ADD CONSTRAINT action_item_types_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.action_item_types ADD COLUMN  name text;

ALTER TABLE dashboard_public.action_item_types ALTER COLUMN name SET NOT NULL;

ALTER TABLE dashboard_public.action_item_types ADD COLUMN  description text;

ALTER TABLE dashboard_public.action_item_types ADD COLUMN  image image;

ALTER TABLE dashboard_public.action_item_types ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.action_item_types ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.action_item_types 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.action_item_types ( created_by );

CREATE INDEX ON dashboard_public.action_item_types ( updated_by );

ALTER TABLE dashboard_public.action_item_types ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.action_item_types ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.action_item_types ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.action_item_types ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.action_item_types 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.action_item_types ( created_at );

CREATE INDEX ON dashboard_public.action_item_types ( updated_at );

ALTER TABLE dashboard_public.action_item_types ADD CONSTRAINT action_item_types_name_key UNIQUE ( name );

COMMENT ON CONSTRAINT action_item_types_name_key ON dashboard_public.action_item_types IS E'@omit';

ALTER TABLE dashboard_public.action_item_types ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.action_item_types TO authenticated;

GRANT SELECT ON TABLE dashboard_public.action_item_types TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.action_item_types TO authenticated;

GRANT DELETE ON TABLE dashboard_public.action_item_types TO authenticated;

CREATE POLICY auth_ins_admin ON dashboard_public.action_item_types FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE) );

CREATE POLICY auth_upd_admin ON dashboard_public.action_item_types FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE) );

CREATE POLICY auth_del_admin ON dashboard_public.action_item_types FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE) );

CREATE POLICY auth_sel_admin ON dashboard_public.action_item_types FOR SELECT TO authenticated USING ( TRUE );

CREATE TABLE dashboard_public.action_items (
  
);

ALTER TABLE dashboard_public.action_items DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.action_items ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.action_items ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.action_items ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.action_items ADD CONSTRAINT action_items_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.action_items ADD COLUMN  name text;

ALTER TABLE dashboard_public.action_items ADD COLUMN  description text;

ALTER TABLE dashboard_public.action_items ADD COLUMN  item_order int;

ALTER TABLE dashboard_public.action_items ALTER COLUMN item_order SET DEFAULT 0;

ALTER TABLE dashboard_public.action_items ADD COLUMN  time_required interval;

ALTER TABLE dashboard_public.action_items ADD COLUMN  is_required boolean;

ALTER TABLE dashboard_public.action_items ALTER COLUMN is_required SET NOT NULL;

ALTER TABLE dashboard_public.action_items ALTER COLUMN is_required SET DEFAULT TRUE;

ALTER TABLE dashboard_public.action_items ADD COLUMN  notification_text text;

ALTER TABLE dashboard_public.action_items ADD COLUMN  embed_code text;

ALTER TABLE dashboard_public.action_items ADD COLUMN  url url;

ALTER TABLE dashboard_public.action_items ADD COLUMN  media upload;

ALTER TABLE dashboard_public.action_items ADD COLUMN  location geometry(point, 4326);

ALTER TABLE dashboard_public.action_items ADD COLUMN  location_radius numeric;

ALTER TABLE dashboard_public.action_items ADD COLUMN  reward_weight numeric;

COMMENT ON COLUMN dashboard_public.action_items.reward_weight IS E'used as a fraction against action.reward_amount';

ALTER TABLE dashboard_public.action_items ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.action_items ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.action_items 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.action_items ( created_by );

CREATE INDEX ON dashboard_public.action_items ( updated_by );

ALTER TABLE dashboard_public.action_items ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.action_items ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.action_items ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.action_items ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.action_items 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.action_items ( created_at );

CREATE INDEX ON dashboard_public.action_items ( updated_at );

ALTER TABLE dashboard_public.action_items ADD COLUMN  item_type_id uuid;

ALTER TABLE dashboard_public.action_items ALTER COLUMN item_type_id SET NOT NULL;

ALTER TABLE dashboard_public.action_items ADD CONSTRAINT action_items_item_type_id_fkey FOREIGN KEY ( item_type_id ) REFERENCES dashboard_public.action_item_types ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT action_items_item_type_id_fkey ON dashboard_public.action_items IS E'@omit manyToMany';

CREATE INDEX action_items_item_type_id_idx ON dashboard_public.action_items ( item_type_id );

ALTER TABLE dashboard_public.action_items ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.action_items ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.action_items ADD CONSTRAINT action_items_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT action_items_owner_id_fkey ON dashboard_public.action_items IS E'@omit manyToMany';

CREATE INDEX action_items_owner_id_idx ON dashboard_public.action_items ( owner_id );

ALTER TABLE dashboard_public.action_items ADD COLUMN  action_id uuid;

ALTER TABLE dashboard_public.action_items ALTER COLUMN action_id SET NOT NULL;

ALTER TABLE dashboard_public.action_items ADD CONSTRAINT action_items_action_id_fkey FOREIGN KEY ( action_id ) REFERENCES dashboard_public.actions ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT action_items_action_id_fkey ON dashboard_public.action_items IS E'@omit manyToMany';

CREATE INDEX action_items_action_id_idx ON dashboard_public.action_items ( action_id );

ALTER TABLE dashboard_public.action_items ADD CONSTRAINT action_items_action_id_name_key UNIQUE ( action_id, name );

COMMENT ON CONSTRAINT action_items_action_id_name_key ON dashboard_public.action_items IS E'@omit';

CREATE INDEX action_items_name_idx ON dashboard_public.action_items ( name );

CREATE TRIGGER action_items_owner_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.action_items 
 FOR EACH ROW
 WHEN ( old.owner_id IS DISTINCT FROM new.owner_id AND old.owner_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','owner_id' );

CREATE TRIGGER action_items_action_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.action_items 
 FOR EACH ROW
 WHEN ( old.action_id IS DISTINCT FROM new.action_id AND old.action_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','action_id' );

ALTER TABLE dashboard_public.action_items ALTER COLUMN owner_id SET DEFAULT uuid_nil();

CREATE FUNCTION dashboard_private.action_items_denorm_action_id (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  SELECT ref.owner_id FROM "dashboard_public".actions AS ref WHERE ref.id = new.action_id
  INTO new.owner_id;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_action_id 
 BEFORE INSERT ON dashboard_public.action_items 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. action_items_denorm_action_id (  );

CREATE TRIGGER _000000000_ensure_update_action_id 
 BEFORE UPDATE ON dashboard_public.action_items 
 FOR EACH ROW
 WHEN ( old.action_id IS DISTINCT FROM new.action_id OR old.owner_id IS DISTINCT FROM new.owner_id ) 
 EXECUTE PROCEDURE dashboard_private. action_items_denorm_action_id (  );

ALTER TABLE dashboard_public.action_items ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.action_items TO authenticated;

GRANT SELECT ON TABLE dashboard_public.action_items TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.action_items TO authenticated;

GRANT DELETE ON TABLE dashboard_public.action_items TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.action_items FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_public.action_items FOR INSERT TO authenticated WITH CHECK ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE POLICY auth_upd ON dashboard_public.action_items FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE POLICY auth_del ON dashboard_public.action_items FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE TABLE dashboard_public.related_actions (
  
);

ALTER TABLE dashboard_public.related_actions DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.related_actions ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.related_actions ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.related_actions ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.related_actions ADD CONSTRAINT related_actions_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.related_actions ADD COLUMN  action_order int;

ALTER TABLE dashboard_public.related_actions ALTER COLUMN action_order SET DEFAULT 0;

ALTER TABLE dashboard_public.related_actions ADD COLUMN  is_required bool;

ALTER TABLE dashboard_public.related_actions ALTER COLUMN is_required SET NOT NULL;

ALTER TABLE dashboard_public.related_actions ALTER COLUMN is_required SET DEFAULT TRUE;

ALTER TABLE dashboard_public.related_actions ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.related_actions ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.related_actions 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.related_actions ( created_by );

CREATE INDEX ON dashboard_public.related_actions ( updated_by );

ALTER TABLE dashboard_public.related_actions ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.related_actions ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.related_actions ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.related_actions ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.related_actions 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.related_actions ( created_at );

CREATE INDEX ON dashboard_public.related_actions ( updated_at );

ALTER TABLE dashboard_public.related_actions ADD COLUMN  action_id uuid;

ALTER TABLE dashboard_public.related_actions ALTER COLUMN action_id SET NOT NULL;

ALTER TABLE dashboard_public.related_actions ADD CONSTRAINT related_actions_action_id_fkey FOREIGN KEY ( action_id ) REFERENCES dashboard_public.actions ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT related_actions_action_id_fkey ON dashboard_public.related_actions IS E'@omit manyToMany';

CREATE INDEX related_actions_action_id_idx ON dashboard_public.related_actions ( action_id );

ALTER TABLE dashboard_public.related_actions ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.related_actions ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.related_actions ADD CONSTRAINT related_actions_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT related_actions_owner_id_fkey ON dashboard_public.related_actions IS E'@omit manyToMany';

CREATE INDEX related_actions_owner_id_idx ON dashboard_public.related_actions ( owner_id );

ALTER TABLE dashboard_public.related_actions ADD COLUMN  required_id uuid;

ALTER TABLE dashboard_public.related_actions ALTER COLUMN required_id SET NOT NULL;

ALTER TABLE dashboard_public.related_actions ADD CONSTRAINT related_actions_required_id_fkey FOREIGN KEY ( required_id ) REFERENCES dashboard_public.actions ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT related_actions_required_id_fkey ON dashboard_public.related_actions IS E'@omit manyToMany';

CREATE INDEX related_actions_required_id_idx ON dashboard_public.related_actions ( required_id );

CREATE TRIGGER related_actions_owner_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.related_actions 
 FOR EACH ROW
 WHEN ( old.owner_id IS DISTINCT FROM new.owner_id AND old.owner_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','owner_id' );

CREATE TRIGGER related_actions_action_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.related_actions 
 FOR EACH ROW
 WHEN ( old.action_id IS DISTINCT FROM new.action_id AND old.action_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','action_id' );

ALTER TABLE dashboard_public.related_actions ALTER COLUMN owner_id SET DEFAULT uuid_nil();

CREATE FUNCTION dashboard_private.related_actions_denorm_action_id (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  SELECT ref.owner_id FROM "dashboard_public".actions AS ref WHERE ref.id = new.action_id
  INTO new.owner_id;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_action_id 
 BEFORE INSERT ON dashboard_public.related_actions 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. related_actions_denorm_action_id (  );

CREATE TRIGGER _000000000_ensure_update_action_id 
 BEFORE UPDATE ON dashboard_public.related_actions 
 FOR EACH ROW
 WHEN ( old.action_id IS DISTINCT FROM new.action_id OR old.owner_id IS DISTINCT FROM new.owner_id ) 
 EXECUTE PROCEDURE dashboard_private. related_actions_denorm_action_id (  );

ALTER TABLE dashboard_public.related_actions ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.related_actions TO authenticated;

GRANT SELECT ON TABLE dashboard_public.related_actions TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.related_actions TO authenticated;

GRANT DELETE ON TABLE dashboard_public.related_actions TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.related_actions FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_public.related_actions FOR INSERT TO authenticated WITH CHECK ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE POLICY auth_upd ON dashboard_public.related_actions FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE POLICY auth_del ON dashboard_public.related_actions FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE TABLE dashboard_public.action_locations (
  
);

ALTER TABLE dashboard_public.action_locations DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.action_locations ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.action_locations ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.action_locations ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.action_locations ADD CONSTRAINT action_locations_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.action_locations ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.action_locations ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.action_locations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.action_locations ( created_by );

CREATE INDEX ON dashboard_public.action_locations ( updated_by );

ALTER TABLE dashboard_public.action_locations ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.action_locations ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.action_locations ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.action_locations ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.action_locations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.action_locations ( created_at );

CREATE INDEX ON dashboard_public.action_locations ( updated_at );

ALTER TABLE dashboard_public.action_locations ADD COLUMN  action_id uuid;

ALTER TABLE dashboard_public.action_locations ALTER COLUMN action_id SET NOT NULL;

ALTER TABLE dashboard_public.action_locations ADD CONSTRAINT action_locations_action_id_fkey FOREIGN KEY ( action_id ) REFERENCES dashboard_public.actions ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT action_locations_action_id_fkey ON dashboard_public.action_locations IS E'@omit manyToMany';

CREATE INDEX action_locations_action_id_idx ON dashboard_public.action_locations ( action_id );

ALTER TABLE dashboard_public.action_locations ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.action_locations ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.action_locations ADD CONSTRAINT action_locations_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT action_locations_owner_id_fkey ON dashboard_public.action_locations IS E'@omit manyToMany';

CREATE INDEX action_locations_owner_id_idx ON dashboard_public.action_locations ( owner_id );

ALTER TABLE dashboard_public.action_locations ADD COLUMN  location_id uuid;

ALTER TABLE dashboard_public.action_locations ALTER COLUMN location_id SET NOT NULL;

ALTER TABLE dashboard_public.action_locations ADD CONSTRAINT action_locations_location_id_fkey FOREIGN KEY ( location_id ) REFERENCES dashboard_public.locations ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT action_locations_location_id_fkey ON dashboard_public.action_locations IS E'@omit manyToMany';

CREATE INDEX action_locations_location_id_idx ON dashboard_public.action_locations ( location_id );

CREATE TRIGGER action_locations_owner_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.action_locations 
 FOR EACH ROW
 WHEN ( old.owner_id IS DISTINCT FROM new.owner_id AND old.owner_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','owner_id' );

CREATE TRIGGER action_locations_action_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.action_locations 
 FOR EACH ROW
 WHEN ( old.action_id IS DISTINCT FROM new.action_id AND old.action_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','action_id' );

ALTER TABLE dashboard_public.action_locations ALTER COLUMN owner_id SET DEFAULT uuid_nil();

CREATE FUNCTION dashboard_private.action_locations_denorm_action_id (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  SELECT ref.owner_id FROM "dashboard_public".actions AS ref WHERE ref.id = new.action_id
  INTO new.owner_id;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_action_id 
 BEFORE INSERT ON dashboard_public.action_locations 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. action_locations_denorm_action_id (  );

CREATE TRIGGER _000000000_ensure_update_action_id 
 BEFORE UPDATE ON dashboard_public.action_locations 
 FOR EACH ROW
 WHEN ( old.action_id IS DISTINCT FROM new.action_id OR old.owner_id IS DISTINCT FROM new.owner_id ) 
 EXECUTE PROCEDURE dashboard_private. action_locations_denorm_action_id (  );

ALTER TABLE dashboard_public.action_locations ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.action_locations TO authenticated;

GRANT SELECT ON TABLE dashboard_public.action_locations TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.action_locations TO authenticated;

GRANT DELETE ON TABLE dashboard_public.action_locations TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.action_locations FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_public.action_locations FOR INSERT TO authenticated WITH CHECK ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE POLICY auth_upd ON dashboard_public.action_locations FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE POLICY auth_del ON dashboard_public.action_locations FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE TABLE dashboard_public.user_actions (
  
);

ALTER TABLE dashboard_public.user_actions DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.user_actions ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.user_actions ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.user_actions ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.user_actions ADD CONSTRAINT user_actions_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.user_actions ADD COLUMN  user_id uuid;

ALTER TABLE dashboard_public.user_actions ALTER COLUMN user_id SET NOT NULL;

ALTER TABLE dashboard_public.user_actions ALTER COLUMN user_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_public.user_actions ADD COLUMN  action_started timestamptz;

ALTER TABLE dashboard_public.user_actions ALTER COLUMN action_started SET DEFAULT now();

ALTER TABLE dashboard_public.user_actions ADD COLUMN  complete boolean;

ALTER TABLE dashboard_public.user_actions ALTER COLUMN complete SET DEFAULT FALSE;

ALTER TABLE dashboard_public.user_actions ADD COLUMN  verified boolean;

ALTER TABLE dashboard_public.user_actions ALTER COLUMN verified SET DEFAULT FALSE;

ALTER TABLE dashboard_public.user_actions ADD COLUMN  verified_date timestamptz;

ALTER TABLE dashboard_public.user_actions ADD COLUMN  user_rating int;

ALTER TABLE dashboard_public.user_actions ADD COLUMN  rejected boolean;

ALTER TABLE dashboard_public.user_actions ALTER COLUMN rejected SET DEFAULT FALSE;

ALTER TABLE dashboard_public.user_actions ADD COLUMN  location geometry(point, 4326);

COMMENT ON COLUMN dashboard_public.user_actions.location IS E'this represents the location where the action was completed';

ALTER TABLE dashboard_public.user_actions ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.user_actions ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_actions 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.user_actions ( created_by );

CREATE INDEX ON dashboard_public.user_actions ( updated_by );

ALTER TABLE dashboard_public.user_actions ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.user_actions ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.user_actions ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.user_actions ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_actions 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.user_actions ( created_at );

CREATE INDEX ON dashboard_public.user_actions ( updated_at );

ALTER TABLE dashboard_public.user_actions ADD CONSTRAINT user_actions_user_id_fkey FOREIGN KEY ( user_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_actions_user_id_fkey ON dashboard_public.user_actions IS E'@omit manyToMany';

CREATE INDEX user_actions_user_id_idx ON dashboard_public.user_actions ( user_id );

ALTER TABLE dashboard_public.user_actions ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.user_actions ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.user_actions ADD CONSTRAINT user_actions_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_actions_owner_id_fkey ON dashboard_public.user_actions IS E'@omit manyToMany';

CREATE INDEX user_actions_owner_id_idx ON dashboard_public.user_actions ( owner_id );

CREATE INDEX user_actions_verified_idx ON dashboard_public.user_actions ( verified );

CREATE INDEX user_actions_complete_idx ON dashboard_public.user_actions ( complete );

ALTER TABLE dashboard_public.user_actions ADD COLUMN  action_id uuid;

ALTER TABLE dashboard_public.user_actions ALTER COLUMN action_id SET NOT NULL;

ALTER TABLE dashboard_public.user_actions ADD CONSTRAINT user_actions_action_id_fkey FOREIGN KEY ( action_id ) REFERENCES dashboard_public.actions ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_actions_action_id_fkey ON dashboard_public.user_actions IS E'@omit manyToMany';

CREATE INDEX user_actions_action_id_idx ON dashboard_public.user_actions ( action_id );

CREATE INDEX user_actions_location_idx ON dashboard_public.user_actions USING GIST ( location );

CREATE TRIGGER user_actions_user_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.user_actions 
 FOR EACH ROW
 WHEN ( old.user_id IS DISTINCT FROM new.user_id AND old.user_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','user_id' );

CREATE TRIGGER user_actions_action_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.user_actions 
 FOR EACH ROW
 WHEN ( old.action_id IS DISTINCT FROM new.action_id AND old.action_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','action_id' );

ALTER TABLE dashboard_public.user_actions ALTER COLUMN owner_id SET DEFAULT uuid_nil();

CREATE FUNCTION dashboard_private.user_actions_denorm_action_id (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  SELECT ref.owner_id FROM "dashboard_public".actions AS ref WHERE ref.id = new.action_id
  INTO new.owner_id;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_action_id 
 BEFORE INSERT ON dashboard_public.user_actions 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. user_actions_denorm_action_id (  );

CREATE TRIGGER _000000000_ensure_update_action_id 
 BEFORE UPDATE ON dashboard_public.user_actions 
 FOR EACH ROW
 WHEN ( old.action_id IS DISTINCT FROM new.action_id OR old.owner_id IS DISTINCT FROM new.owner_id ) 
 EXECUTE PROCEDURE dashboard_private. user_actions_denorm_action_id (  );

ALTER TABLE dashboard_public.user_actions ENABLE ROW LEVEL SECURITY;

GRANT INSERT ( user_id, action_id, user_rating, complete, location ) ON TABLE dashboard_public.user_actions TO authenticated;

GRANT SELECT ON TABLE dashboard_public.user_actions TO authenticated;

GRANT DELETE ON TABLE dashboard_public.user_actions TO authenticated;

GRANT UPDATE ( user_rating, rejected, complete, location ) ON TABLE dashboard_public.user_actions TO authenticated;

CREATE POLICY auth_ins_own ON dashboard_public.user_actions FOR INSERT TO authenticated WITH CHECK ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_upd_own ON dashboard_public.user_actions FOR UPDATE TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_sel_own ON dashboard_public.user_actions FOR SELECT TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_del_own ON dashboard_public.user_actions FOR DELETE TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_sel_verified ON dashboard_public.user_actions FOR SELECT TO authenticated USING ( verified = TRUE );

CREATE POLICY auth_sel_verifier ON dashboard_public.user_actions FOR SELECT TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000010000000000000') = '00000000000000000010000000000000') );

CREATE POLICY auth_sel_owner ON dashboard_public.user_actions FOR SELECT TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000010000000000000000') = '00000000000000010000000000000000') );

CREATE TABLE dashboard_public.user_action_verifications (
  
);

ALTER TABLE dashboard_public.user_action_verifications DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.user_action_verifications ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.user_action_verifications ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.user_action_verifications ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.user_action_verifications ADD CONSTRAINT user_action_verifications_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.user_action_verifications ADD COLUMN  verifier_id uuid;

ALTER TABLE dashboard_public.user_action_verifications ALTER COLUMN verifier_id SET NOT NULL;

ALTER TABLE dashboard_public.user_action_verifications ALTER COLUMN verifier_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_public.user_action_verifications ADD COLUMN  verified boolean;

ALTER TABLE dashboard_public.user_action_verifications ALTER COLUMN verified SET NOT NULL;

ALTER TABLE dashboard_public.user_action_verifications ALTER COLUMN verified SET DEFAULT FALSE;

ALTER TABLE dashboard_public.user_action_verifications ADD COLUMN  rejected boolean;

ALTER TABLE dashboard_public.user_action_verifications ALTER COLUMN rejected SET NOT NULL;

ALTER TABLE dashboard_public.user_action_verifications ALTER COLUMN rejected SET DEFAULT FALSE;

ALTER TABLE dashboard_public.user_action_verifications ADD COLUMN  notes text;

ALTER TABLE dashboard_public.user_action_verifications ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.user_action_verifications ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_action_verifications 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.user_action_verifications ( created_by );

CREATE INDEX ON dashboard_public.user_action_verifications ( updated_by );

ALTER TABLE dashboard_public.user_action_verifications ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.user_action_verifications ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.user_action_verifications ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.user_action_verifications ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_action_verifications 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.user_action_verifications ( created_at );

CREATE INDEX ON dashboard_public.user_action_verifications ( updated_at );

ALTER TABLE dashboard_public.user_action_verifications ADD COLUMN  user_id uuid;

ALTER TABLE dashboard_public.user_action_verifications ALTER COLUMN user_id SET NOT NULL;

ALTER TABLE dashboard_public.user_action_verifications ADD CONSTRAINT user_action_verifications_user_id_fkey FOREIGN KEY ( user_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_action_verifications_user_id_fkey ON dashboard_public.user_action_verifications IS E'@omit manyToMany';

CREATE INDEX user_action_verifications_user_id_idx ON dashboard_public.user_action_verifications ( user_id );

ALTER TABLE dashboard_public.user_action_verifications ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.user_action_verifications ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.user_action_verifications ADD CONSTRAINT user_action_verifications_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_action_verifications_owner_id_fkey ON dashboard_public.user_action_verifications IS E'@omit manyToMany';

CREATE INDEX user_action_verifications_owner_id_idx ON dashboard_public.user_action_verifications ( owner_id );

ALTER TABLE dashboard_public.user_action_verifications ADD COLUMN  action_id uuid;

ALTER TABLE dashboard_public.user_action_verifications ALTER COLUMN action_id SET NOT NULL;

ALTER TABLE dashboard_public.user_action_verifications ADD CONSTRAINT user_action_verifications_action_id_fkey FOREIGN KEY ( action_id ) REFERENCES dashboard_public.actions ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_action_verifications_action_id_fkey ON dashboard_public.user_action_verifications IS E'@omit manyToMany';

CREATE INDEX user_action_verifications_action_id_idx ON dashboard_public.user_action_verifications ( action_id );

ALTER TABLE dashboard_public.user_action_verifications ADD COLUMN  user_action_id uuid;

ALTER TABLE dashboard_public.user_action_verifications ALTER COLUMN user_action_id SET NOT NULL;

ALTER TABLE dashboard_public.user_action_verifications ADD CONSTRAINT user_action_verifications_user_action_id_fkey FOREIGN KEY ( user_action_id ) REFERENCES dashboard_public.user_actions ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_action_verifications_user_action_id_fkey ON dashboard_public.user_action_verifications IS E'@omit manyToMany';

CREATE INDEX user_action_verifications_user_action_id_idx ON dashboard_public.user_action_verifications ( user_action_id );

ALTER TABLE dashboard_public.user_action_verifications ALTER COLUMN user_id SET DEFAULT uuid_nil();

ALTER TABLE dashboard_public.user_action_verifications ALTER COLUMN owner_id SET DEFAULT uuid_nil();

ALTER TABLE dashboard_public.user_action_verifications ALTER COLUMN action_id SET DEFAULT uuid_nil();

CREATE FUNCTION dashboard_private.user_action_verifications_denorm_user_action_id (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  SELECT ref.user_id,
ref.owner_id,
ref.action_id FROM "dashboard_public".user_actions AS ref WHERE ref.id = new.user_action_id
  INTO new.user_id,
new.owner_id,
new.action_id;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_user_action_id 
 BEFORE INSERT ON dashboard_public.user_action_verifications 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. user_action_verifications_denorm_user_action_id (  );

CREATE TRIGGER _000000000_ensure_update_user_action_id 
 BEFORE UPDATE ON dashboard_public.user_action_verifications 
 FOR EACH ROW
 WHEN ( old.user_action_id IS DISTINCT FROM new.user_action_id OR old.user_id IS DISTINCT FROM new.user_id OR old.owner_id IS DISTINCT FROM new.owner_id OR old.action_id IS DISTINCT FROM new.action_id ) 
 EXECUTE PROCEDURE dashboard_private. user_action_verifications_denorm_user_action_id (  );

ALTER TABLE dashboard_public.user_action_verifications ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.user_action_verifications TO authenticated;

GRANT SELECT ON TABLE dashboard_public.user_action_verifications TO authenticated;

GRANT DELETE ON TABLE dashboard_public.user_action_verifications TO authenticated;

GRANT UPDATE ( notes, verified, rejected ) ON TABLE dashboard_public.user_action_verifications TO authenticated;

CREATE POLICY auth_ins_verifier ON dashboard_public.user_action_verifications FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000010000000000000') = '00000000000000000010000000000000') );

CREATE POLICY auth_sel_verifier ON dashboard_public.user_action_verifications FOR SELECT TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000010000000000000') = '00000000000000000010000000000000') );

CREATE POLICY auth_upd_verifier ON dashboard_public.user_action_verifications FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000010000000000000') = '00000000000000000010000000000000') );

CREATE POLICY auth_del_verifier ON dashboard_public.user_action_verifications FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000010000000000000') = '00000000000000000010000000000000') );

CREATE POLICY auth_ins_owner ON dashboard_public.user_action_verifications FOR INSERT TO authenticated WITH CHECK ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000010000000000000000') = '00000000000000010000000000000000') );

CREATE POLICY auth_sel_owner ON dashboard_public.user_action_verifications FOR SELECT TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000010000000000000000') = '00000000000000010000000000000000') );

CREATE POLICY auth_upd_owner ON dashboard_public.user_action_verifications FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000010000000000000000') = '00000000000000010000000000000000') );

CREATE POLICY auth_del_owner ON dashboard_public.user_action_verifications FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000010000000000000000') = '00000000000000010000000000000000') );

CREATE TABLE dashboard_public.user_action_items (
  
);

ALTER TABLE dashboard_public.user_action_items DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.user_action_items ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.user_action_items ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.user_action_items ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.user_action_items ADD CONSTRAINT user_action_items_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.user_action_items ADD COLUMN  user_id uuid;

ALTER TABLE dashboard_public.user_action_items ALTER COLUMN user_id SET NOT NULL;

ALTER TABLE dashboard_public.user_action_items ALTER COLUMN user_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_public.user_action_items ADD COLUMN  text text;

ALTER TABLE dashboard_public.user_action_items ADD COLUMN  media upload;

ALTER TABLE dashboard_public.user_action_items ADD COLUMN  location geometry(point, 4326);

ALTER TABLE dashboard_public.user_action_items ADD COLUMN  bbox geometry(polygon, 4326);

ALTER TABLE dashboard_public.user_action_items ADD COLUMN  data jsonb;

ALTER TABLE dashboard_public.user_action_items ADD COLUMN  complete boolean;

ALTER TABLE dashboard_public.user_action_items ALTER COLUMN complete SET DEFAULT FALSE;

ALTER TABLE dashboard_public.user_action_items ADD COLUMN  verified boolean;

ALTER TABLE dashboard_public.user_action_items ALTER COLUMN verified SET DEFAULT FALSE;

ALTER TABLE dashboard_public.user_action_items ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.user_action_items ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_action_items 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.user_action_items ( created_by );

CREATE INDEX ON dashboard_public.user_action_items ( updated_by );

ALTER TABLE dashboard_public.user_action_items ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.user_action_items ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.user_action_items ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.user_action_items ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_action_items 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.user_action_items ( created_at );

CREATE INDEX ON dashboard_public.user_action_items ( updated_at );

ALTER TABLE dashboard_public.user_action_items ADD CONSTRAINT user_action_items_user_id_fkey FOREIGN KEY ( user_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_action_items_user_id_fkey ON dashboard_public.user_action_items IS E'@omit manyToMany';

CREATE INDEX user_action_items_user_id_idx ON dashboard_public.user_action_items ( user_id );

ALTER TABLE dashboard_public.user_action_items ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.user_action_items ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.user_action_items ADD CONSTRAINT user_action_items_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_action_items_owner_id_fkey ON dashboard_public.user_action_items IS E'@omit manyToMany';

CREATE INDEX user_action_items_owner_id_idx ON dashboard_public.user_action_items ( owner_id );

ALTER TABLE dashboard_public.user_action_items ADD COLUMN  action_id uuid;

ALTER TABLE dashboard_public.user_action_items ALTER COLUMN action_id SET NOT NULL;

ALTER TABLE dashboard_public.user_action_items ADD CONSTRAINT user_action_items_action_id_fkey FOREIGN KEY ( action_id ) REFERENCES dashboard_public.actions ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_action_items_action_id_fkey ON dashboard_public.user_action_items IS E'@omit manyToMany';

CREATE INDEX user_action_items_action_id_idx ON dashboard_public.user_action_items ( action_id );

ALTER TABLE dashboard_public.user_action_items ADD COLUMN  user_action_id uuid;

ALTER TABLE dashboard_public.user_action_items ALTER COLUMN user_action_id SET NOT NULL;

ALTER TABLE dashboard_public.user_action_items ADD CONSTRAINT user_action_items_user_action_id_fkey FOREIGN KEY ( user_action_id ) REFERENCES dashboard_public.user_actions ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_action_items_user_action_id_fkey ON dashboard_public.user_action_items IS E'@omit manyToMany';

CREATE INDEX user_action_items_user_action_id_idx ON dashboard_public.user_action_items ( user_action_id );

ALTER TABLE dashboard_public.user_action_items ADD COLUMN  action_item_id uuid;

ALTER TABLE dashboard_public.user_action_items ALTER COLUMN action_item_id SET NOT NULL;

ALTER TABLE dashboard_public.user_action_items ADD CONSTRAINT user_action_items_action_item_id_fkey FOREIGN KEY ( action_item_id ) REFERENCES dashboard_public.action_items ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_action_items_action_item_id_fkey ON dashboard_public.user_action_items IS E'@omit manyToMany';

CREATE INDEX user_action_items_action_item_id_idx ON dashboard_public.user_action_items ( action_item_id );

ALTER TABLE dashboard_public.user_action_items ADD CONSTRAINT user_action_items_user_id_user_action_id_action_item_id_key UNIQUE ( user_id, user_action_id, action_item_id );

COMMENT ON CONSTRAINT user_action_items_user_id_user_action_id_action_item_id_key ON dashboard_public.user_action_items IS E'@omit';

CREATE INDEX user_action_items_verified_idx ON dashboard_public.user_action_items ( verified );

CREATE INDEX user_action_items_complete_idx ON dashboard_public.user_action_items ( complete );

CREATE TRIGGER user_action_items_user_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.user_action_items 
 FOR EACH ROW
 WHEN ( old.user_id IS DISTINCT FROM new.user_id AND old.user_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','user_id' );

CREATE TRIGGER user_action_items_action_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.user_action_items 
 FOR EACH ROW
 WHEN ( old.action_id IS DISTINCT FROM new.action_id AND old.action_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','action_id' );

CREATE TRIGGER user_action_items_user_action_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.user_action_items 
 FOR EACH ROW
 WHEN ( old.user_action_id IS DISTINCT FROM new.user_action_id AND old.user_action_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','user_action_id' );

CREATE TRIGGER user_action_items_action_item_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.user_action_items 
 FOR EACH ROW
 WHEN ( old.action_item_id IS DISTINCT FROM new.action_item_id AND old.action_item_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','action_item_id' );

ALTER TABLE dashboard_public.user_action_items ALTER COLUMN user_id SET DEFAULT uuid_nil();

ALTER TABLE dashboard_public.user_action_items ALTER COLUMN owner_id SET DEFAULT uuid_nil();

ALTER TABLE dashboard_public.user_action_items ALTER COLUMN action_id SET DEFAULT uuid_nil();

CREATE FUNCTION dashboard_private.user_action_items_denorm_user_action_id (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  SELECT ref.user_id,
ref.owner_id,
ref.action_id FROM "dashboard_public".user_actions AS ref WHERE ref.id = new.user_action_id
  INTO new.user_id,
new.owner_id,
new.action_id;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_user_action_id 
 BEFORE INSERT ON dashboard_public.user_action_items 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. user_action_items_denorm_user_action_id (  );

CREATE TRIGGER _000000000_ensure_update_user_action_id 
 BEFORE UPDATE ON dashboard_public.user_action_items 
 FOR EACH ROW
 WHEN ( old.user_action_id IS DISTINCT FROM new.user_action_id OR old.user_id IS DISTINCT FROM new.user_id OR old.owner_id IS DISTINCT FROM new.owner_id OR old.action_id IS DISTINCT FROM new.action_id ) 
 EXECUTE PROCEDURE dashboard_private. user_action_items_denorm_user_action_id (  );

ALTER TABLE dashboard_public.user_action_items ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.user_action_items TO authenticated;

GRANT SELECT ON TABLE dashboard_public.user_action_items TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.user_action_items TO authenticated;

GRANT DELETE ON TABLE dashboard_public.user_action_items TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.user_action_items FOR INSERT TO authenticated WITH CHECK ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_sel ON dashboard_public.user_action_items FOR SELECT TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_upd ON dashboard_public.user_action_items FOR UPDATE TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_del ON dashboard_public.user_action_items FOR DELETE TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_sel_verifier ON dashboard_public.user_action_items FOR SELECT TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000010000000000000') = '00000000000000000010000000000000') );

CREATE TABLE dashboard_public.user_action_item_verifications (
  
);

ALTER TABLE dashboard_public.user_action_item_verifications DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.user_action_item_verifications ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.user_action_item_verifications ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.user_action_item_verifications ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.user_action_item_verifications ADD CONSTRAINT user_action_item_verifications_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.user_action_item_verifications ADD COLUMN  verifier_id uuid;

ALTER TABLE dashboard_public.user_action_item_verifications ALTER COLUMN verifier_id SET NOT NULL;

ALTER TABLE dashboard_public.user_action_item_verifications ALTER COLUMN verifier_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_public.user_action_item_verifications ADD COLUMN  verified boolean;

ALTER TABLE dashboard_public.user_action_item_verifications ALTER COLUMN verified SET NOT NULL;

ALTER TABLE dashboard_public.user_action_item_verifications ALTER COLUMN verified SET DEFAULT FALSE;

ALTER TABLE dashboard_public.user_action_item_verifications ADD COLUMN  rejected boolean;

ALTER TABLE dashboard_public.user_action_item_verifications ALTER COLUMN rejected SET NOT NULL;

ALTER TABLE dashboard_public.user_action_item_verifications ALTER COLUMN rejected SET DEFAULT FALSE;

ALTER TABLE dashboard_public.user_action_item_verifications ADD COLUMN  notes text;

ALTER TABLE dashboard_public.user_action_item_verifications ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.user_action_item_verifications ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_action_item_verifications 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.user_action_item_verifications ( created_by );

CREATE INDEX ON dashboard_public.user_action_item_verifications ( updated_by );

ALTER TABLE dashboard_public.user_action_item_verifications ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.user_action_item_verifications ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.user_action_item_verifications ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.user_action_item_verifications ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_action_item_verifications 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.user_action_item_verifications ( created_at );

CREATE INDEX ON dashboard_public.user_action_item_verifications ( updated_at );

ALTER TABLE dashboard_public.user_action_item_verifications ADD CONSTRAINT user_action_item_verifications_verifier_id_fkey FOREIGN KEY ( verifier_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_action_item_verifications_verifier_id_fkey ON dashboard_public.user_action_item_verifications IS E'@omit manyToMany';

CREATE INDEX user_action_item_verifications_verifier_id_idx ON dashboard_public.user_action_item_verifications ( verifier_id );

ALTER TABLE dashboard_public.user_action_item_verifications ADD COLUMN  user_id uuid;

ALTER TABLE dashboard_public.user_action_item_verifications ALTER COLUMN user_id SET NOT NULL;

ALTER TABLE dashboard_public.user_action_item_verifications ADD CONSTRAINT user_action_item_verifications_user_id_fkey FOREIGN KEY ( user_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_action_item_verifications_user_id_fkey ON dashboard_public.user_action_item_verifications IS E'@omit manyToMany';

CREATE INDEX user_action_item_verifications_user_id_idx ON dashboard_public.user_action_item_verifications ( user_id );

ALTER TABLE dashboard_public.user_action_item_verifications ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.user_action_item_verifications ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.user_action_item_verifications ADD CONSTRAINT user_action_item_verifications_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_action_item_verifications_owner_id_fkey ON dashboard_public.user_action_item_verifications IS E'@omit manyToMany';

CREATE INDEX user_action_item_verifications_owner_id_idx ON dashboard_public.user_action_item_verifications ( owner_id );

ALTER TABLE dashboard_public.user_action_item_verifications ADD COLUMN  action_id uuid;

ALTER TABLE dashboard_public.user_action_item_verifications ALTER COLUMN action_id SET NOT NULL;

ALTER TABLE dashboard_public.user_action_item_verifications ADD CONSTRAINT user_action_item_verifications_action_id_fkey FOREIGN KEY ( action_id ) REFERENCES dashboard_public.actions ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_action_item_verifications_action_id_fkey ON dashboard_public.user_action_item_verifications IS E'@omit manyToMany';

CREATE INDEX user_action_item_verifications_action_id_idx ON dashboard_public.user_action_item_verifications ( action_id );

ALTER TABLE dashboard_public.user_action_item_verifications ADD COLUMN  user_action_id uuid;

ALTER TABLE dashboard_public.user_action_item_verifications ALTER COLUMN user_action_id SET NOT NULL;

ALTER TABLE dashboard_public.user_action_item_verifications ADD CONSTRAINT user_action_item_verifications_user_action_id_fkey FOREIGN KEY ( user_action_id ) REFERENCES dashboard_public.user_actions ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_action_item_verifications_user_action_id_fkey ON dashboard_public.user_action_item_verifications IS E'@omit manyToMany';

CREATE INDEX user_action_item_verifications_user_action_id_idx ON dashboard_public.user_action_item_verifications ( user_action_id );

ALTER TABLE dashboard_public.user_action_item_verifications ADD COLUMN  action_item_id uuid;

ALTER TABLE dashboard_public.user_action_item_verifications ALTER COLUMN action_item_id SET NOT NULL;

ALTER TABLE dashboard_public.user_action_item_verifications ADD CONSTRAINT user_action_item_verifications_action_item_id_fkey FOREIGN KEY ( action_item_id ) REFERENCES dashboard_public.action_items ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_action_item_verifications_action_item_id_fkey ON dashboard_public.user_action_item_verifications IS E'@omit manyToMany';

CREATE INDEX user_action_item_verifications_action_item_id_idx ON dashboard_public.user_action_item_verifications ( action_item_id );

ALTER TABLE dashboard_public.user_action_item_verifications ADD COLUMN  user_action_item_id uuid;

ALTER TABLE dashboard_public.user_action_item_verifications ALTER COLUMN user_action_item_id SET NOT NULL;

ALTER TABLE dashboard_public.user_action_item_verifications ADD CONSTRAINT user_action_item_verifications_user_action_item_id_fkey FOREIGN KEY ( user_action_item_id ) REFERENCES dashboard_public.user_action_items ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_action_item_verifications_user_action_item_id_fkey ON dashboard_public.user_action_item_verifications IS E'@omit manyToMany';

CREATE INDEX user_action_item_verifications_user_action_item_id_idx ON dashboard_public.user_action_item_verifications ( user_action_item_id );

ALTER TABLE dashboard_public.user_action_item_verifications ALTER COLUMN user_id SET DEFAULT uuid_nil();

ALTER TABLE dashboard_public.user_action_item_verifications ALTER COLUMN owner_id SET DEFAULT uuid_nil();

ALTER TABLE dashboard_public.user_action_item_verifications ALTER COLUMN action_id SET DEFAULT uuid_nil();

ALTER TABLE dashboard_public.user_action_item_verifications ALTER COLUMN user_action_id SET DEFAULT uuid_nil();

ALTER TABLE dashboard_public.user_action_item_verifications ALTER COLUMN action_item_id SET DEFAULT uuid_nil();

CREATE FUNCTION dashboard_private.user_action_item_verifications_denorm_user_action_item_id (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  SELECT ref.user_id,
ref.owner_id,
ref.action_id,
ref.user_action_id,
ref.action_item_id FROM "dashboard_public".user_action_items AS ref WHERE ref.id = new.user_action_item_id
  INTO new.user_id,
new.owner_id,
new.action_id,
new.user_action_id,
new.action_item_id;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_user_action_item_id 
 BEFORE INSERT ON dashboard_public.user_action_item_verifications 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. user_action_item_verifications_denorm_user_action_item_id (  );

CREATE TRIGGER _000000000_ensure_update_user_action_item_id 
 BEFORE UPDATE ON dashboard_public.user_action_item_verifications 
 FOR EACH ROW
 WHEN ( old.user_action_item_id IS DISTINCT FROM new.user_action_item_id OR old.user_id IS DISTINCT FROM new.user_id OR old.owner_id IS DISTINCT FROM new.owner_id OR old.action_id IS DISTINCT FROM new.action_id OR old.user_action_id IS DISTINCT FROM new.user_action_id OR old.action_item_id IS DISTINCT FROM new.action_item_id ) 
 EXECUTE PROCEDURE dashboard_private. user_action_item_verifications_denorm_user_action_item_id (  );

ALTER TABLE dashboard_public.user_action_item_verifications ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.user_action_item_verifications TO authenticated;

GRANT SELECT ON TABLE dashboard_public.user_action_item_verifications TO authenticated;

GRANT DELETE ON TABLE dashboard_public.user_action_item_verifications TO authenticated;

GRANT UPDATE ( notes, verified, rejected ) ON TABLE dashboard_public.user_action_item_verifications TO authenticated;

CREATE POLICY auth_ins_verifier ON dashboard_public.user_action_item_verifications FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000010000000000000') = '00000000000000000010000000000000') );

CREATE POLICY auth_sel_verifier ON dashboard_public.user_action_item_verifications FOR SELECT TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000010000000000000') = '00000000000000000010000000000000') );

CREATE POLICY auth_upd_verifier ON dashboard_public.user_action_item_verifications FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000010000000000000') = '00000000000000000010000000000000') );

CREATE POLICY auth_del_verifier ON dashboard_public.user_action_item_verifications FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000010000000000000') = '00000000000000000010000000000000') );

CREATE POLICY auth_sel_owner ON dashboard_public.user_action_item_verifications FOR SELECT TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000010000000000000000') = '00000000000000010000000000000000') );

CREATE TABLE dashboard_public.tracks (
  
);

ALTER TABLE dashboard_public.tracks DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.tracks ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.tracks ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.tracks ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.tracks ADD CONSTRAINT tracks_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.tracks ADD COLUMN  name text;

ALTER TABLE dashboard_public.tracks ADD COLUMN  slug citext;

ALTER TABLE dashboard_public.tracks ADD CONSTRAINT tracks_slug_chk CHECK ( character_length(slug) <= 2048 );

ALTER TABLE dashboard_public.tracks ADD COLUMN  description text;

ALTER TABLE dashboard_public.tracks ADD COLUMN  photo image;

ALTER TABLE dashboard_public.tracks ADD COLUMN  icon image;

ALTER TABLE dashboard_public.tracks ADD COLUMN  is_published boolean;

ALTER TABLE dashboard_public.tracks ALTER COLUMN is_published SET DEFAULT FALSE;

ALTER TABLE dashboard_public.tracks ADD COLUMN  is_approved boolean;

ALTER TABLE dashboard_public.tracks ALTER COLUMN is_approved SET DEFAULT FALSE;

ALTER TABLE dashboard_public.tracks ADD COLUMN  is_private boolean;

ALTER TABLE dashboard_public.tracks ALTER COLUMN is_private SET DEFAULT FALSE;

ALTER TABLE dashboard_public.tracks ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.tracks ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.tracks 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.tracks ( created_by );

CREATE INDEX ON dashboard_public.tracks ( updated_by );

ALTER TABLE dashboard_public.tracks ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.tracks ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.tracks ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.tracks ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.tracks 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.tracks ( created_at );

CREATE INDEX ON dashboard_public.tracks ( updated_at );

ALTER TABLE dashboard_public.tracks ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.tracks ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.tracks ADD CONSTRAINT tracks_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT tracks_owner_id_fkey ON dashboard_public.tracks IS E'@omit manyToMany';

CREATE INDEX tracks_owner_id_idx ON dashboard_public.tracks ( owner_id );

ALTER TABLE dashboard_public.tracks ADD CONSTRAINT tracks_slug_key UNIQUE ( slug );

COMMENT ON CONSTRAINT tracks_slug_key ON dashboard_public.tracks IS NULL;

CREATE FUNCTION dashboard_private.tracks_slg_slug (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  new.slug = inflection.slugify(new.slug);
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER insert_slg_slug 
 BEFORE INSERT ON dashboard_public.tracks 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. tracks_slg_slug (  );

CREATE TRIGGER update_slg_slug 
 BEFORE UPDATE ON dashboard_public.tracks 
 FOR EACH ROW
 WHEN ( OLD.slug IS DISTINCT FROM NEW.slug ) 
 EXECUTE PROCEDURE dashboard_private. tracks_slg_slug (  );

CREATE INDEX tracks_is_published_idx ON dashboard_public.tracks ( is_published );

CREATE INDEX tracks_is_private_idx ON dashboard_public.tracks ( is_private );

CREATE INDEX tracks_name_idx ON dashboard_public.tracks ( name );

ALTER TABLE dashboard_public.tracks ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.tracks TO authenticated;

GRANT SELECT ON TABLE dashboard_public.tracks TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.tracks TO authenticated;

GRANT DELETE ON TABLE dashboard_public.tracks TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.tracks FOR INSERT TO authenticated WITH CHECK ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE POLICY auth_upd ON dashboard_public.tracks FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE POLICY auth_del ON dashboard_public.tracks FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE POLICY auth_ins_create_track_check ON dashboard_public.tracks AS RESTRICTIVE FOR INSERT TO authenticated WITH CHECK ( owner_id IN (SELECT acl.actor_id FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = owner_id AND (acl.permissions & '00000000000000000000100000000000') = '00000000000000000000100000000000') );

CREATE POLICY auth_sel ON dashboard_public.tracks FOR SELECT TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000')) OR (is_published = TRUE AND is_private = TRUE AND owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id())) OR (is_published = TRUE AND is_private = FALSE) );

CREATE TABLE dashboard_public.track_actions (
  
);

ALTER TABLE dashboard_public.track_actions DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.track_actions ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.track_actions ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.track_actions ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.track_actions ADD CONSTRAINT track_actions_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.track_actions ADD COLUMN  track_order int;

ALTER TABLE dashboard_public.track_actions ALTER COLUMN track_order SET DEFAULT 0;

ALTER TABLE dashboard_public.track_actions ADD COLUMN  is_required bool;

ALTER TABLE dashboard_public.track_actions ALTER COLUMN is_required SET NOT NULL;

ALTER TABLE dashboard_public.track_actions ALTER COLUMN is_required SET DEFAULT TRUE;

COMMENT ON COLUMN dashboard_public.track_actions.is_required IS E'required to progress';

ALTER TABLE dashboard_public.track_actions ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.track_actions ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.track_actions 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.track_actions ( created_by );

CREATE INDEX ON dashboard_public.track_actions ( updated_by );

ALTER TABLE dashboard_public.track_actions ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.track_actions ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.track_actions ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.track_actions ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.track_actions 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.track_actions ( created_at );

CREATE INDEX ON dashboard_public.track_actions ( updated_at );

ALTER TABLE dashboard_public.track_actions ADD COLUMN  action_id uuid;

ALTER TABLE dashboard_public.track_actions ALTER COLUMN action_id SET NOT NULL;

ALTER TABLE dashboard_public.track_actions ADD CONSTRAINT track_actions_action_id_fkey FOREIGN KEY ( action_id ) REFERENCES dashboard_public.actions ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT track_actions_action_id_fkey ON dashboard_public.track_actions IS E'@omit manyToMany';

CREATE INDEX track_actions_action_id_idx ON dashboard_public.track_actions ( action_id );

CREATE TRIGGER track_actions_action_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.track_actions 
 FOR EACH ROW
 WHEN ( old.action_id IS DISTINCT FROM new.action_id AND old.action_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','action_id' );

ALTER TABLE dashboard_public.track_actions ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.track_actions ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.track_actions ADD CONSTRAINT track_actions_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT track_actions_owner_id_fkey ON dashboard_public.track_actions IS E'@omit manyToMany';

CREATE INDEX track_actions_owner_id_idx ON dashboard_public.track_actions ( owner_id );

CREATE TRIGGER track_actions_owner_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.track_actions 
 FOR EACH ROW
 WHEN ( old.owner_id IS DISTINCT FROM new.owner_id AND old.owner_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','owner_id' );

ALTER TABLE dashboard_public.track_actions ADD COLUMN  track_id uuid;

ALTER TABLE dashboard_public.track_actions ALTER COLUMN track_id SET NOT NULL;

ALTER TABLE dashboard_public.track_actions ADD CONSTRAINT track_actions_track_id_fkey FOREIGN KEY ( track_id ) REFERENCES dashboard_public.tracks ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT track_actions_track_id_fkey ON dashboard_public.track_actions IS E'@omit manyToMany';

CREATE INDEX track_actions_track_id_idx ON dashboard_public.track_actions ( track_id );

CREATE TRIGGER track_actions_track_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.track_actions 
 FOR EACH ROW
 WHEN ( old.track_id IS DISTINCT FROM new.track_id AND old.track_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','track_id' );

ALTER TABLE dashboard_public.track_actions ALTER COLUMN owner_id SET DEFAULT uuid_nil();

CREATE FUNCTION dashboard_private.track_actions_denorm_track_id (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  SELECT ref.owner_id FROM "dashboard_public".tracks AS ref WHERE ref.id = new.track_id
  INTO new.owner_id;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_track_id 
 BEFORE INSERT ON dashboard_public.track_actions 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. track_actions_denorm_track_id (  );

CREATE TRIGGER _000000000_ensure_update_track_id 
 BEFORE UPDATE ON dashboard_public.track_actions 
 FOR EACH ROW
 WHEN ( old.track_id IS DISTINCT FROM new.track_id OR old.owner_id IS DISTINCT FROM new.owner_id ) 
 EXECUTE PROCEDURE dashboard_private. track_actions_denorm_track_id (  );

ALTER TABLE dashboard_public.track_actions ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.track_actions TO authenticated;

GRANT SELECT ON TABLE dashboard_public.track_actions TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.track_actions TO authenticated;

GRANT DELETE ON TABLE dashboard_public.track_actions TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.track_actions FOR INSERT TO authenticated WITH CHECK ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE POLICY auth_upd ON dashboard_public.track_actions FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE POLICY auth_del ON dashboard_public.track_actions FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE POLICY auth_sel ON dashboard_public.track_actions FOR SELECT TO authenticated USING ( TRUE );

CREATE TABLE dashboard_public.user_tracks (
  
);

ALTER TABLE dashboard_public.user_tracks DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.user_tracks ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.user_tracks ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.user_tracks ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.user_tracks ADD CONSTRAINT user_tracks_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.user_tracks ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.user_tracks ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_tracks 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.user_tracks ( created_by );

CREATE INDEX ON dashboard_public.user_tracks ( updated_by );

ALTER TABLE dashboard_public.user_tracks ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.user_tracks ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.user_tracks ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.user_tracks ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_tracks 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.user_tracks ( created_at );

CREATE INDEX ON dashboard_public.user_tracks ( updated_at );

ALTER TABLE dashboard_public.user_tracks ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.user_tracks ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.user_tracks ADD CONSTRAINT user_tracks_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_tracks_owner_id_fkey ON dashboard_public.user_tracks IS E'@omit manyToMany';

CREATE INDEX user_tracks_owner_id_idx ON dashboard_public.user_tracks ( owner_id );

ALTER TABLE dashboard_public.user_tracks ADD COLUMN  user_id uuid;

ALTER TABLE dashboard_public.user_tracks ALTER COLUMN user_id SET NOT NULL;

ALTER TABLE dashboard_public.user_tracks ADD CONSTRAINT user_tracks_user_id_fkey FOREIGN KEY ( user_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_tracks_user_id_fkey ON dashboard_public.user_tracks IS E'@omit manyToMany';

CREATE INDEX user_tracks_user_id_idx ON dashboard_public.user_tracks ( user_id );

CREATE TRIGGER user_tracks_owner_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.user_tracks 
 FOR EACH ROW
 WHEN ( old.owner_id IS DISTINCT FROM new.owner_id AND old.owner_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','owner_id' );

CREATE TRIGGER user_tracks_user_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.user_tracks 
 FOR EACH ROW
 WHEN ( old.user_id IS DISTINCT FROM new.user_id AND old.user_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','user_id' );

ALTER TABLE dashboard_public.user_tracks ADD COLUMN  track_id uuid;

ALTER TABLE dashboard_public.user_tracks ALTER COLUMN track_id SET NOT NULL;

ALTER TABLE dashboard_public.user_tracks ADD CONSTRAINT user_tracks_track_id_fkey FOREIGN KEY ( track_id ) REFERENCES dashboard_public.tracks ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_tracks_track_id_fkey ON dashboard_public.user_tracks IS E'@omit manyToMany';

CREATE INDEX user_tracks_track_id_idx ON dashboard_public.user_tracks ( track_id );

CREATE TRIGGER user_tracks_track_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.user_tracks 
 FOR EACH ROW
 WHEN ( old.track_id IS DISTINCT FROM new.track_id AND old.track_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','track_id' );

ALTER TABLE dashboard_public.user_tracks ALTER COLUMN owner_id SET DEFAULT uuid_nil();

CREATE FUNCTION dashboard_private.user_tracks_denorm_track_id (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  SELECT ref.owner_id FROM "dashboard_public".tracks AS ref WHERE ref.id = new.track_id
  INTO new.owner_id;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_track_id 
 BEFORE INSERT ON dashboard_public.user_tracks 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. user_tracks_denorm_track_id (  );

CREATE TRIGGER _000000000_ensure_update_track_id 
 BEFORE UPDATE ON dashboard_public.user_tracks 
 FOR EACH ROW
 WHEN ( old.track_id IS DISTINCT FROM new.track_id OR old.owner_id IS DISTINCT FROM new.owner_id ) 
 EXECUTE PROCEDURE dashboard_private. user_tracks_denorm_track_id (  );

ALTER TABLE dashboard_public.user_tracks ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.user_tracks TO authenticated;

GRANT SELECT ON TABLE dashboard_public.user_tracks TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.user_tracks TO authenticated;

GRANT DELETE ON TABLE dashboard_public.user_tracks TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.user_tracks FOR INSERT TO authenticated WITH CHECK ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_upd ON dashboard_public.user_tracks FOR UPDATE TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_del ON dashboard_public.user_tracks FOR DELETE TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_sel ON dashboard_public.user_tracks FOR SELECT TO authenticated USING ( TRUE );

ALTER TABLE dashboard_public.actions ADD COLUMN  object_type_id uuid;

ALTER TABLE dashboard_public.actions ADD CONSTRAINT actions_object_type_id_fkey FOREIGN KEY ( object_type_id ) REFERENCES dashboard_public.object_types ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT actions_object_type_id_fkey ON dashboard_public.actions IS E'@omit manyToMany';

CREATE INDEX actions_object_type_id_idx ON dashboard_public.actions ( object_type_id );

ALTER TABLE dashboard_public.tracks ADD COLUMN  object_type_id uuid;

ALTER TABLE dashboard_public.tracks ADD CONSTRAINT tracks_object_type_id_fkey FOREIGN KEY ( object_type_id ) REFERENCES dashboard_public.object_types ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT tracks_object_type_id_fkey ON dashboard_public.tracks IS E'@omit manyToMany';

CREATE INDEX tracks_object_type_id_idx ON dashboard_public.tracks ( object_type_id );

ALTER TABLE dashboard_public.user_actions ADD COLUMN  object_id uuid;

ALTER TABLE dashboard_public.user_actions ADD CONSTRAINT user_actions_object_id_fkey FOREIGN KEY ( object_id ) REFERENCES dashboard_public.objects ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_actions_object_id_fkey ON dashboard_public.user_actions IS E'@omit manyToMany';

CREATE INDEX user_actions_object_id_idx ON dashboard_public.user_actions ( object_id );

GRANT INSERT ( object_id ) ON TABLE dashboard_public.user_actions TO authenticated;

GRANT UPDATE ( object_id ) ON TABLE dashboard_public.user_actions TO authenticated;

CREATE TABLE dashboard_public.action_impacts (
  
);

ALTER TABLE dashboard_public.action_impacts DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.action_impacts ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.action_impacts ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.action_impacts ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.action_impacts ADD CONSTRAINT action_impacts_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.action_impacts ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.action_impacts ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.action_impacts 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.action_impacts ( created_by );

CREATE INDEX ON dashboard_public.action_impacts ( updated_by );

ALTER TABLE dashboard_public.action_impacts ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.action_impacts ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.action_impacts ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.action_impacts ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.action_impacts 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.action_impacts ( created_at );

CREATE INDEX ON dashboard_public.action_impacts ( updated_at );

ALTER TABLE dashboard_public.action_impacts ADD COLUMN  action_id uuid;

ALTER TABLE dashboard_public.action_impacts ALTER COLUMN action_id SET NOT NULL;

ALTER TABLE dashboard_public.action_impacts ADD CONSTRAINT action_impacts_action_id_fkey FOREIGN KEY ( action_id ) REFERENCES dashboard_public.actions ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT action_impacts_action_id_fkey ON dashboard_public.action_impacts IS NULL;

CREATE INDEX action_impacts_action_id_idx ON dashboard_public.action_impacts ( action_id );

ALTER TABLE dashboard_public.action_impacts ADD COLUMN  impact_id uuid;

ALTER TABLE dashboard_public.action_impacts ALTER COLUMN impact_id SET NOT NULL;

ALTER TABLE dashboard_public.action_impacts ADD CONSTRAINT action_impacts_impact_id_fkey FOREIGN KEY ( impact_id ) REFERENCES dashboard_public.impacts ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT action_impacts_impact_id_fkey ON dashboard_public.action_impacts IS NULL;

CREATE INDEX action_impacts_impact_id_idx ON dashboard_public.action_impacts ( impact_id );

ALTER TABLE dashboard_public.action_impacts ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.action_impacts ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.action_impacts ADD CONSTRAINT action_impacts_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT action_impacts_owner_id_fkey ON dashboard_public.action_impacts IS E'@omit manyToMany';

CREATE INDEX action_impacts_owner_id_idx ON dashboard_public.action_impacts ( owner_id );

CREATE TRIGGER action_impacts_owner_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.action_impacts 
 FOR EACH ROW
 WHEN ( old.owner_id IS DISTINCT FROM new.owner_id AND old.owner_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','owner_id' );

CREATE TRIGGER action_impacts_action_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.action_impacts 
 FOR EACH ROW
 WHEN ( old.action_id IS DISTINCT FROM new.action_id AND old.action_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','action_id' );

ALTER TABLE dashboard_public.action_impacts ALTER COLUMN owner_id SET DEFAULT uuid_nil();

CREATE FUNCTION dashboard_private.action_impacts_denorm_action_id (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  SELECT ref.owner_id FROM "dashboard_public".actions AS ref WHERE ref.id = new.action_id
  INTO new.owner_id;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_action_id 
 BEFORE INSERT ON dashboard_public.action_impacts 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. action_impacts_denorm_action_id (  );

CREATE TRIGGER _000000000_ensure_update_action_id 
 BEFORE UPDATE ON dashboard_public.action_impacts 
 FOR EACH ROW
 WHEN ( old.action_id IS DISTINCT FROM new.action_id OR old.owner_id IS DISTINCT FROM new.owner_id ) 
 EXECUTE PROCEDURE dashboard_private. action_impacts_denorm_action_id (  );

ALTER TABLE dashboard_public.action_impacts ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.action_impacts TO authenticated;

GRANT SELECT ON TABLE dashboard_public.action_impacts TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.action_impacts TO authenticated;

GRANT DELETE ON TABLE dashboard_public.action_impacts TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.action_impacts FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_upd ON dashboard_public.action_impacts FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE POLICY auth_del ON dashboard_public.action_impacts FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE POLICY auth_ins ON dashboard_public.action_impacts FOR INSERT TO authenticated WITH CHECK ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000')) AND action_id IN (SELECT obj.id FROM dashboard_memberships_private.memberships_acl AS acl INNER JOIN dashboard_public.actions AS obj ON acl.entity_id = obj.owner_id WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000')) );

CREATE TABLE dashboard_public.zip_codes (
  
);

ALTER TABLE dashboard_public.zip_codes DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.zip_codes ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.zip_codes ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.zip_codes ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.zip_codes ADD CONSTRAINT zip_codes_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.zip_codes ADD COLUMN  zip int;

ALTER TABLE dashboard_public.zip_codes ADD COLUMN  location geometry(point, 4326);

ALTER TABLE dashboard_public.zip_codes ADD COLUMN  bbox geometry(polygon, 4326);

ALTER TABLE dashboard_public.zip_codes ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.zip_codes ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.zip_codes 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.zip_codes ( created_by );

CREATE INDEX ON dashboard_public.zip_codes ( updated_by );

ALTER TABLE dashboard_public.zip_codes ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.zip_codes ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.zip_codes ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.zip_codes ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.zip_codes 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.zip_codes ( created_at );

CREATE INDEX ON dashboard_public.zip_codes ( updated_at );

ALTER TABLE dashboard_public.zip_codes ADD CONSTRAINT zip_codes_zip_key UNIQUE ( zip );

COMMENT ON CONSTRAINT zip_codes_zip_key ON dashboard_public.zip_codes IS NULL;

CREATE INDEX zip_codes_zip_idx ON dashboard_public.zip_codes ( zip );

CREATE INDEX zip_codes_location_idx ON dashboard_public.zip_codes USING GIST ( location );

CREATE INDEX zip_codes_bbox_idx ON dashboard_public.zip_codes USING GIST ( bbox );

ALTER TABLE dashboard_public.zip_codes ENABLE ROW LEVEL SECURITY;

CREATE POLICY anon_sel ON dashboard_public.zip_codes FOR SELECT TO anonymous USING ( TRUE );

CREATE POLICY auth_sel ON dashboard_public.zip_codes FOR SELECT TO authenticated USING ( TRUE );

GRANT SELECT ON TABLE dashboard_public.zip_codes TO anonymous;

GRANT SELECT ON TABLE dashboard_public.zip_codes TO authenticated;

CREATE TABLE dashboard_public.organization_profiles (
  
);

ALTER TABLE dashboard_public.organization_profiles DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.organization_profiles ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.organization_profiles ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.organization_profiles ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.organization_profiles ADD CONSTRAINT organization_profiles_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.organization_profiles ADD COLUMN  name text;

ALTER TABLE dashboard_public.organization_profiles ADD COLUMN  header_image image;

ALTER TABLE dashboard_public.organization_profiles ADD COLUMN  description text;

ALTER TABLE dashboard_public.organization_profiles ADD COLUMN  website url;

ALTER TABLE dashboard_public.organization_profiles ADD COLUMN  reputation numeric;

ALTER TABLE dashboard_public.organization_profiles ALTER COLUMN reputation SET DEFAULT 0;

ALTER TABLE dashboard_public.organization_profiles ADD COLUMN  tags citext[];

ALTER TABLE dashboard_public.organization_profiles ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.organization_profiles ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.organization_profiles 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.organization_profiles ( created_by );

CREATE INDEX ON dashboard_public.organization_profiles ( updated_by );

ALTER TABLE dashboard_public.organization_profiles ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.organization_profiles ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.organization_profiles ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.organization_profiles ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.organization_profiles 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.organization_profiles ( created_at );

CREATE INDEX ON dashboard_public.organization_profiles ( updated_at );

ALTER TABLE dashboard_public.organization_profiles ADD COLUMN  organization_id uuid;

ALTER TABLE dashboard_public.organization_profiles ALTER COLUMN organization_id SET NOT NULL;

ALTER TABLE dashboard_public.organization_profiles ADD CONSTRAINT organization_profiles_organization_id_fkey FOREIGN KEY ( organization_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT organization_profiles_organization_id_fkey ON dashboard_public.organization_profiles IS E'@omit manyToMany';

CREATE INDEX organization_profiles_organization_id_idx ON dashboard_public.organization_profiles ( organization_id );

CREATE TRIGGER organization_profiles_organization_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.organization_profiles 
 FOR EACH ROW
 WHEN ( old.organization_id IS DISTINCT FROM new.organization_id AND old.organization_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','organization_id' );

ALTER TABLE dashboard_public.organization_profiles ADD CONSTRAINT organization_profiles_organization_id_key UNIQUE ( organization_id );

COMMENT ON CONSTRAINT organization_profiles_organization_id_key ON dashboard_public.organization_profiles IS E'@omit';

ALTER TABLE dashboard_public.organization_profiles ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.organization_profiles TO authenticated;

GRANT SELECT ON TABLE dashboard_public.organization_profiles TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.organization_profiles TO authenticated;

GRANT DELETE ON TABLE dashboard_public.organization_profiles TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.organization_profiles FOR INSERT TO authenticated WITH CHECK ( organization_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000001000000000000') = '00000000000000000001000000000000') );

CREATE POLICY auth_upd ON dashboard_public.organization_profiles FOR UPDATE TO authenticated USING ( organization_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000001000000000000') = '00000000000000000001000000000000') );

CREATE POLICY auth_del ON dashboard_public.organization_profiles FOR DELETE TO authenticated USING ( organization_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000001000000000000') = '00000000000000000001000000000000') );

CREATE POLICY auth_sel ON dashboard_public.organization_profiles FOR SELECT TO authenticated USING ( TRUE );

CREATE TABLE dashboard_public.user_pass_actions (
  
);

ALTER TABLE dashboard_public.user_pass_actions DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.user_pass_actions ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.user_pass_actions ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.user_pass_actions ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.user_pass_actions ADD CONSTRAINT user_pass_actions_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.user_pass_actions ADD COLUMN  user_id uuid;

ALTER TABLE dashboard_public.user_pass_actions ALTER COLUMN user_id SET NOT NULL;

ALTER TABLE dashboard_public.user_pass_actions ALTER COLUMN user_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_public.user_pass_actions ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.user_pass_actions ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_pass_actions 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.user_pass_actions ( created_by );

CREATE INDEX ON dashboard_public.user_pass_actions ( updated_by );

ALTER TABLE dashboard_public.user_pass_actions ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.user_pass_actions ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.user_pass_actions ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.user_pass_actions ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_pass_actions 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.user_pass_actions ( created_at );

CREATE INDEX ON dashboard_public.user_pass_actions ( updated_at );

ALTER TABLE dashboard_public.user_pass_actions ADD CONSTRAINT user_pass_actions_user_id_fkey FOREIGN KEY ( user_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_pass_actions_user_id_fkey ON dashboard_public.user_pass_actions IS E'@omit manyToMany';

CREATE INDEX user_pass_actions_user_id_idx ON dashboard_public.user_pass_actions ( user_id );

ALTER TABLE dashboard_public.user_pass_actions ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.user_pass_actions ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.user_pass_actions ADD CONSTRAINT user_pass_actions_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_pass_actions_owner_id_fkey ON dashboard_public.user_pass_actions IS E'@omit manyToMany';

CREATE INDEX user_pass_actions_owner_id_idx ON dashboard_public.user_pass_actions ( owner_id );

ALTER TABLE dashboard_public.user_pass_actions ADD COLUMN  action_id uuid;

ALTER TABLE dashboard_public.user_pass_actions ALTER COLUMN action_id SET NOT NULL;

ALTER TABLE dashboard_public.user_pass_actions ADD CONSTRAINT user_pass_actions_action_id_fkey FOREIGN KEY ( action_id ) REFERENCES dashboard_public.actions ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_pass_actions_action_id_fkey ON dashboard_public.user_pass_actions IS E'@omit manyToMany';

CREATE INDEX user_pass_actions_action_id_idx ON dashboard_public.user_pass_actions ( action_id );

ALTER TABLE dashboard_public.user_pass_actions ADD CONSTRAINT user_pass_actions_user_id_action_id_key UNIQUE ( user_id, action_id );

COMMENT ON CONSTRAINT user_pass_actions_user_id_action_id_key ON dashboard_public.user_pass_actions IS E'@omit';

CREATE TRIGGER user_pass_actions_action_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.user_pass_actions 
 FOR EACH ROW
 WHEN ( old.action_id IS DISTINCT FROM new.action_id AND old.action_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','action_id' );

ALTER TABLE dashboard_public.user_pass_actions ALTER COLUMN owner_id SET DEFAULT uuid_nil();

CREATE FUNCTION dashboard_private.user_pass_actions_denorm_action_id (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  SELECT ref.owner_id FROM "dashboard_public".actions AS ref WHERE ref.id = new.action_id
  INTO new.owner_id;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_action_id 
 BEFORE INSERT ON dashboard_public.user_pass_actions 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. user_pass_actions_denorm_action_id (  );

CREATE TRIGGER _000000000_ensure_update_action_id 
 BEFORE UPDATE ON dashboard_public.user_pass_actions 
 FOR EACH ROW
 WHEN ( old.action_id IS DISTINCT FROM new.action_id OR old.owner_id IS DISTINCT FROM new.owner_id ) 
 EXECUTE PROCEDURE dashboard_private. user_pass_actions_denorm_action_id (  );

ALTER TABLE dashboard_public.user_pass_actions ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.user_pass_actions TO authenticated;

GRANT SELECT ON TABLE dashboard_public.user_pass_actions TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.user_pass_actions TO authenticated;

GRANT DELETE ON TABLE dashboard_public.user_pass_actions TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.user_pass_actions FOR INSERT TO authenticated WITH CHECK ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_sel ON dashboard_public.user_pass_actions FOR SELECT TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_upd ON dashboard_public.user_pass_actions FOR UPDATE TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_del ON dashboard_public.user_pass_actions FOR DELETE TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_sel_owner ON dashboard_public.user_pass_actions FOR SELECT TO authenticated USING ( owner_id = jwt_public.current_user_id() );

CREATE TABLE dashboard_public.user_saved_actions (
  
);

ALTER TABLE dashboard_public.user_saved_actions DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.user_saved_actions ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.user_saved_actions ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.user_saved_actions ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.user_saved_actions ADD CONSTRAINT user_saved_actions_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.user_saved_actions ADD COLUMN  user_id uuid;

ALTER TABLE dashboard_public.user_saved_actions ALTER COLUMN user_id SET NOT NULL;

ALTER TABLE dashboard_public.user_saved_actions ALTER COLUMN user_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_public.user_saved_actions ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.user_saved_actions ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_saved_actions 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.user_saved_actions ( created_by );

CREATE INDEX ON dashboard_public.user_saved_actions ( updated_by );

ALTER TABLE dashboard_public.user_saved_actions ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.user_saved_actions ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.user_saved_actions ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.user_saved_actions ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_saved_actions 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.user_saved_actions ( created_at );

CREATE INDEX ON dashboard_public.user_saved_actions ( updated_at );

ALTER TABLE dashboard_public.user_saved_actions ADD CONSTRAINT user_saved_actions_user_id_fkey FOREIGN KEY ( user_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_saved_actions_user_id_fkey ON dashboard_public.user_saved_actions IS E'@omit manyToMany';

CREATE INDEX user_saved_actions_user_id_idx ON dashboard_public.user_saved_actions ( user_id );

ALTER TABLE dashboard_public.user_saved_actions ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.user_saved_actions ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.user_saved_actions ADD CONSTRAINT user_saved_actions_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_saved_actions_owner_id_fkey ON dashboard_public.user_saved_actions IS E'@omit manyToMany';

CREATE INDEX user_saved_actions_owner_id_idx ON dashboard_public.user_saved_actions ( owner_id );

ALTER TABLE dashboard_public.user_saved_actions ADD COLUMN  action_id uuid;

ALTER TABLE dashboard_public.user_saved_actions ALTER COLUMN action_id SET NOT NULL;

ALTER TABLE dashboard_public.user_saved_actions ADD CONSTRAINT user_saved_actions_action_id_fkey FOREIGN KEY ( action_id ) REFERENCES dashboard_public.actions ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_saved_actions_action_id_fkey ON dashboard_public.user_saved_actions IS E'@omit manyToMany';

CREATE INDEX user_saved_actions_action_id_idx ON dashboard_public.user_saved_actions ( action_id );

CREATE TRIGGER user_saved_actions_action_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.user_saved_actions 
 FOR EACH ROW
 WHEN ( old.action_id IS DISTINCT FROM new.action_id AND old.action_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','action_id' );

ALTER TABLE dashboard_public.user_saved_actions ADD CONSTRAINT user_saved_actions_user_id_action_id_key UNIQUE ( user_id, action_id );

COMMENT ON CONSTRAINT user_saved_actions_user_id_action_id_key ON dashboard_public.user_saved_actions IS E'@omit';

ALTER TABLE dashboard_public.user_saved_actions ALTER COLUMN owner_id SET DEFAULT uuid_nil();

CREATE FUNCTION dashboard_private.user_saved_actions_denorm_action_id (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  SELECT ref.owner_id FROM "dashboard_public".actions AS ref WHERE ref.id = new.action_id
  INTO new.owner_id;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_action_id 
 BEFORE INSERT ON dashboard_public.user_saved_actions 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. user_saved_actions_denorm_action_id (  );

CREATE TRIGGER _000000000_ensure_update_action_id 
 BEFORE UPDATE ON dashboard_public.user_saved_actions 
 FOR EACH ROW
 WHEN ( old.action_id IS DISTINCT FROM new.action_id OR old.owner_id IS DISTINCT FROM new.owner_id ) 
 EXECUTE PROCEDURE dashboard_private. user_saved_actions_denorm_action_id (  );

ALTER TABLE dashboard_public.user_saved_actions ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.user_saved_actions TO authenticated;

GRANT SELECT ON TABLE dashboard_public.user_saved_actions TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.user_saved_actions TO authenticated;

GRANT DELETE ON TABLE dashboard_public.user_saved_actions TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.user_saved_actions FOR INSERT TO authenticated WITH CHECK ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_sel ON dashboard_public.user_saved_actions FOR SELECT TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_upd ON dashboard_public.user_saved_actions FOR UPDATE TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_del ON dashboard_public.user_saved_actions FOR DELETE TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_sel_owner ON dashboard_public.user_saved_actions FOR SELECT TO authenticated USING ( owner_id = jwt_public.current_user_id() );

CREATE TABLE dashboard_public.user_viewed_actions (
  
);

ALTER TABLE dashboard_public.user_viewed_actions DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.user_viewed_actions ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.user_viewed_actions ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.user_viewed_actions ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.user_viewed_actions ADD CONSTRAINT user_viewed_actions_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.user_viewed_actions ADD COLUMN  user_id uuid;

ALTER TABLE dashboard_public.user_viewed_actions ALTER COLUMN user_id SET NOT NULL;

ALTER TABLE dashboard_public.user_viewed_actions ALTER COLUMN user_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_public.user_viewed_actions ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.user_viewed_actions ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_viewed_actions 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.user_viewed_actions ( created_by );

CREATE INDEX ON dashboard_public.user_viewed_actions ( updated_by );

ALTER TABLE dashboard_public.user_viewed_actions ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.user_viewed_actions ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.user_viewed_actions ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.user_viewed_actions ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_viewed_actions 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.user_viewed_actions ( created_at );

CREATE INDEX ON dashboard_public.user_viewed_actions ( updated_at );

ALTER TABLE dashboard_public.user_viewed_actions ADD CONSTRAINT user_viewed_actions_user_id_fkey FOREIGN KEY ( user_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_viewed_actions_user_id_fkey ON dashboard_public.user_viewed_actions IS E'@omit manyToMany';

CREATE INDEX user_viewed_actions_user_id_idx ON dashboard_public.user_viewed_actions ( user_id );

ALTER TABLE dashboard_public.user_viewed_actions ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.user_viewed_actions ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.user_viewed_actions ADD CONSTRAINT user_viewed_actions_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_viewed_actions_owner_id_fkey ON dashboard_public.user_viewed_actions IS E'@omit manyToMany';

CREATE INDEX user_viewed_actions_owner_id_idx ON dashboard_public.user_viewed_actions ( owner_id );

ALTER TABLE dashboard_public.user_viewed_actions ADD COLUMN  action_id uuid;

ALTER TABLE dashboard_public.user_viewed_actions ALTER COLUMN action_id SET NOT NULL;

ALTER TABLE dashboard_public.user_viewed_actions ADD CONSTRAINT user_viewed_actions_action_id_fkey FOREIGN KEY ( action_id ) REFERENCES dashboard_public.actions ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_viewed_actions_action_id_fkey ON dashboard_public.user_viewed_actions IS E'@omit manyToMany';

CREATE INDEX user_viewed_actions_action_id_idx ON dashboard_public.user_viewed_actions ( action_id );

CREATE TRIGGER user_viewed_actions_action_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.user_viewed_actions 
 FOR EACH ROW
 WHEN ( old.action_id IS DISTINCT FROM new.action_id AND old.action_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','action_id' );

ALTER TABLE dashboard_public.user_viewed_actions ALTER COLUMN owner_id SET DEFAULT uuid_nil();

CREATE FUNCTION dashboard_private.user_viewed_actions_denorm_action_id (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  SELECT ref.owner_id FROM "dashboard_public".actions AS ref WHERE ref.id = new.action_id
  INTO new.owner_id;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_action_id 
 BEFORE INSERT ON dashboard_public.user_viewed_actions 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. user_viewed_actions_denorm_action_id (  );

CREATE TRIGGER _000000000_ensure_update_action_id 
 BEFORE UPDATE ON dashboard_public.user_viewed_actions 
 FOR EACH ROW
 WHEN ( old.action_id IS DISTINCT FROM new.action_id OR old.owner_id IS DISTINCT FROM new.owner_id ) 
 EXECUTE PROCEDURE dashboard_private. user_viewed_actions_denorm_action_id (  );

ALTER TABLE dashboard_public.user_viewed_actions ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.user_viewed_actions TO authenticated;

GRANT SELECT ON TABLE dashboard_public.user_viewed_actions TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.user_viewed_actions TO authenticated;

GRANT DELETE ON TABLE dashboard_public.user_viewed_actions TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.user_viewed_actions FOR INSERT TO authenticated WITH CHECK ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_sel ON dashboard_public.user_viewed_actions FOR SELECT TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_upd ON dashboard_public.user_viewed_actions FOR UPDATE TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_del ON dashboard_public.user_viewed_actions FOR DELETE TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_sel_owner ON dashboard_public.user_viewed_actions FOR SELECT TO authenticated USING ( owner_id = jwt_public.current_user_id() );

CREATE TABLE dashboard_public.user_action_reactions (
  
);

ALTER TABLE dashboard_public.user_action_reactions DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.user_action_reactions ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.user_action_reactions ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.user_action_reactions ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.user_action_reactions ADD CONSTRAINT user_action_reactions_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.user_action_reactions ADD COLUMN  reacter_id uuid;

ALTER TABLE dashboard_public.user_action_reactions ALTER COLUMN reacter_id SET NOT NULL;

ALTER TABLE dashboard_public.user_action_reactions ALTER COLUMN reacter_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_public.user_action_reactions ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.user_action_reactions ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_action_reactions 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.user_action_reactions ( created_by );

CREATE INDEX ON dashboard_public.user_action_reactions ( updated_by );

ALTER TABLE dashboard_public.user_action_reactions ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.user_action_reactions ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.user_action_reactions ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.user_action_reactions ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_action_reactions 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.user_action_reactions ( created_at );

CREATE INDEX ON dashboard_public.user_action_reactions ( updated_at );

ALTER TABLE dashboard_public.user_action_reactions ADD COLUMN  user_action_id uuid;

ALTER TABLE dashboard_public.user_action_reactions ALTER COLUMN user_action_id SET NOT NULL;

ALTER TABLE dashboard_public.user_action_reactions ADD CONSTRAINT user_action_reactions_user_action_id_fkey FOREIGN KEY ( user_action_id ) REFERENCES dashboard_public.user_actions ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_action_reactions_user_action_id_fkey ON dashboard_public.user_action_reactions IS E'@omit manyToMany';

CREATE INDEX user_action_reactions_user_action_id_idx ON dashboard_public.user_action_reactions ( user_action_id );

CREATE TRIGGER user_action_reactions_user_action_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.user_action_reactions 
 FOR EACH ROW
 WHEN ( old.user_action_id IS DISTINCT FROM new.user_action_id AND old.user_action_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','user_action_id' );

ALTER TABLE dashboard_public.user_action_reactions ADD COLUMN  user_id uuid;

ALTER TABLE dashboard_public.user_action_reactions ALTER COLUMN user_id SET NOT NULL;

ALTER TABLE dashboard_public.user_action_reactions ADD CONSTRAINT user_action_reactions_user_id_fkey FOREIGN KEY ( user_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_action_reactions_user_id_fkey ON dashboard_public.user_action_reactions IS E'@omit manyToMany';

CREATE INDEX user_action_reactions_user_id_idx ON dashboard_public.user_action_reactions ( user_id );

CREATE TRIGGER user_action_reactions_user_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.user_action_reactions 
 FOR EACH ROW
 WHEN ( old.user_id IS DISTINCT FROM new.user_id AND old.user_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','user_id' );

ALTER TABLE dashboard_public.user_action_reactions ADD CONSTRAINT user_action_reactions_reacter_id_fkey FOREIGN KEY ( reacter_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_action_reactions_reacter_id_fkey ON dashboard_public.user_action_reactions IS E'@omit manyToMany';

CREATE INDEX user_action_reactions_reacter_id_idx ON dashboard_public.user_action_reactions ( reacter_id );

CREATE TRIGGER user_action_reactions_reacter_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.user_action_reactions 
 FOR EACH ROW
 WHEN ( old.reacter_id IS DISTINCT FROM new.reacter_id AND old.reacter_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','reacter_id' );

ALTER TABLE dashboard_public.user_action_reactions ADD COLUMN  action_id uuid;

ALTER TABLE dashboard_public.user_action_reactions ALTER COLUMN action_id SET NOT NULL;

ALTER TABLE dashboard_public.user_action_reactions ADD CONSTRAINT user_action_reactions_action_id_fkey FOREIGN KEY ( action_id ) REFERENCES dashboard_public.actions ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_action_reactions_action_id_fkey ON dashboard_public.user_action_reactions IS E'@omit manyToMany';

CREATE INDEX user_action_reactions_action_id_idx ON dashboard_public.user_action_reactions ( action_id );

CREATE TRIGGER user_action_reactions_action_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.user_action_reactions 
 FOR EACH ROW
 WHEN ( old.action_id IS DISTINCT FROM new.action_id AND old.action_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','action_id' );

ALTER TABLE dashboard_public.user_action_reactions ALTER COLUMN user_id SET DEFAULT uuid_nil();

ALTER TABLE dashboard_public.user_action_reactions ALTER COLUMN action_id SET DEFAULT uuid_nil();

CREATE FUNCTION dashboard_private.user_action_reactions_denorm_user_action_id (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  SELECT ref.action_id,
ref.user_id FROM "dashboard_public".user_actions AS ref WHERE ref.id = new.user_action_id
  INTO new.action_id,
new.user_id;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_user_action_id 
 BEFORE INSERT ON dashboard_public.user_action_reactions 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. user_action_reactions_denorm_user_action_id (  );

CREATE TRIGGER _000000000_ensure_update_user_action_id 
 BEFORE UPDATE ON dashboard_public.user_action_reactions 
 FOR EACH ROW
 WHEN ( old.user_action_id IS DISTINCT FROM new.user_action_id OR old.action_id IS DISTINCT FROM new.action_id OR old.user_id IS DISTINCT FROM new.user_id ) 
 EXECUTE PROCEDURE dashboard_private. user_action_reactions_denorm_user_action_id (  );

ALTER TABLE dashboard_public.user_action_reactions ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.user_action_reactions TO authenticated;

GRANT SELECT ON TABLE dashboard_public.user_action_reactions TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.user_action_reactions TO authenticated;

GRANT DELETE ON TABLE dashboard_public.user_action_reactions TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.user_action_reactions FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_public.user_action_reactions FOR INSERT TO authenticated WITH CHECK ( reacter_id = jwt_public.current_user_id() );

CREATE POLICY auth_upd ON dashboard_public.user_action_reactions FOR UPDATE TO authenticated USING ( reacter_id = jwt_public.current_user_id() );

CREATE POLICY auth_del ON dashboard_public.user_action_reactions FOR DELETE TO authenticated USING ( reacter_id = jwt_public.current_user_id() );

CREATE TABLE dashboard_public.user_messages (
  
);

ALTER TABLE dashboard_public.user_messages DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.user_messages ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.user_messages ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.user_messages ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.user_messages ADD CONSTRAINT user_messages_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.user_messages ADD COLUMN  sender_id uuid;

ALTER TABLE dashboard_public.user_messages ALTER COLUMN sender_id SET NOT NULL;

ALTER TABLE dashboard_public.user_messages ALTER COLUMN sender_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_public.user_messages ADD COLUMN  type text;

ALTER TABLE dashboard_public.user_messages ALTER COLUMN type SET NOT NULL;

ALTER TABLE dashboard_public.user_messages ALTER COLUMN type SET DEFAULT 'text';

ALTER TABLE dashboard_public.user_messages ADD COLUMN  content jsonb;

ALTER TABLE dashboard_public.user_messages ADD COLUMN  upload upload;

ALTER TABLE dashboard_public.user_messages ADD COLUMN  received boolean;

ALTER TABLE dashboard_public.user_messages ALTER COLUMN received SET DEFAULT FALSE;

ALTER TABLE dashboard_public.user_messages ADD COLUMN  receiver_read boolean;

ALTER TABLE dashboard_public.user_messages ALTER COLUMN receiver_read SET DEFAULT FALSE;

ALTER TABLE dashboard_public.user_messages ADD COLUMN  sender_reaction text;

ALTER TABLE dashboard_public.user_messages ADD COLUMN  receiver_reaction text;

ALTER TABLE dashboard_public.user_messages ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.user_messages ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_messages 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.user_messages ( created_by );

CREATE INDEX ON dashboard_public.user_messages ( updated_by );

ALTER TABLE dashboard_public.user_messages ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.user_messages ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.user_messages ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.user_messages ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_messages 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.user_messages ( created_at );

CREATE INDEX ON dashboard_public.user_messages ( updated_at );

ALTER TABLE dashboard_public.user_messages ADD CONSTRAINT user_messages_sender_id_fkey FOREIGN KEY ( sender_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_messages_sender_id_fkey ON dashboard_public.user_messages IS E'@omit manyToMany';

CREATE INDEX user_messages_sender_id_idx ON dashboard_public.user_messages ( sender_id );

ALTER TABLE dashboard_public.user_messages ADD COLUMN  receiver_id uuid;

ALTER TABLE dashboard_public.user_messages ALTER COLUMN receiver_id SET NOT NULL;

ALTER TABLE dashboard_public.user_messages ADD CONSTRAINT user_messages_receiver_id_fkey FOREIGN KEY ( receiver_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_messages_receiver_id_fkey ON dashboard_public.user_messages IS E'@omit manyToMany';

CREATE INDEX user_messages_receiver_id_idx ON dashboard_public.user_messages ( receiver_id );

CREATE TRIGGER user_messages_sender_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.user_messages 
 FOR EACH ROW
 WHEN ( old.sender_id IS DISTINCT FROM new.sender_id AND old.sender_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','sender_id' );

CREATE TRIGGER user_messages_receiver_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.user_messages 
 FOR EACH ROW
 WHEN ( old.receiver_id IS DISTINCT FROM new.receiver_id AND old.receiver_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','receiver_id' );

ALTER TABLE dashboard_public.user_messages ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.user_messages TO authenticated;

GRANT SELECT ON TABLE dashboard_public.user_messages TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.user_messages TO authenticated;

GRANT DELETE ON TABLE dashboard_public.user_messages TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.user_messages FOR SELECT TO authenticated USING ( receiver_id = jwt_public.current_user_id() OR sender_id = jwt_public.current_user_id() );

CREATE POLICY auth_del ON dashboard_public.user_messages FOR DELETE TO authenticated USING ( receiver_id = jwt_public.current_user_id() OR sender_id = jwt_public.current_user_id() );

CREATE POLICY auth_upd_receiver ON dashboard_public.user_messages FOR UPDATE TO authenticated USING ( receiver_id = jwt_public.current_user_id() OR sender_id = jwt_public.current_user_id() );

CREATE POLICY auth_ins_sender_create ON dashboard_public.user_messages FOR INSERT TO authenticated WITH CHECK ( sender_id = jwt_public.current_user_id() );

CREATE TRIGGER user_messages_sender_id_owned_tg 
 AFTER UPDATE ON dashboard_public.user_messages 
 FOR EACH ROW
 WHEN ( new.sender_id <> jwt_public.current_user_id() AND old.content IS DISTINCT FROM new.content ) 
 EXECUTE PROCEDURE utils. throw ( 'OWNED_PROPS','sender_id' );

CREATE TRIGGER user_messages_receiver_id_owned_tg 
 AFTER UPDATE ON dashboard_public.user_messages 
 FOR EACH ROW
 WHEN ( new.receiver_id <> jwt_public.current_user_id() AND (old.received IS DISTINCT FROM new.received OR old.receiver_read IS DISTINCT FROM new.receiver_read) ) 
 EXECUTE PROCEDURE utils. throw ( 'OWNED_PROPS','receiver_id' );

CREATE TABLE dashboard_public.message_groups (
  
);

ALTER TABLE dashboard_public.message_groups DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.message_groups ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.message_groups ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.message_groups ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.message_groups ADD CONSTRAINT message_groups_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.message_groups ADD COLUMN  name text;

ALTER TABLE dashboard_public.message_groups ADD COLUMN  member_ids uuid[];

ALTER TABLE dashboard_public.message_groups ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.message_groups ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.message_groups 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.message_groups ( created_by );

CREATE INDEX ON dashboard_public.message_groups ( updated_by );

ALTER TABLE dashboard_public.message_groups ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.message_groups ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.message_groups ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.message_groups ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.message_groups 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.message_groups ( created_at );

CREATE INDEX ON dashboard_public.message_groups ( updated_at );

CREATE INDEX message_groups_member_ids_idx ON dashboard_public.message_groups ( member_ids );

ALTER TABLE dashboard_public.message_groups ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.message_groups TO authenticated;

GRANT SELECT ON TABLE dashboard_public.message_groups TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.message_groups TO authenticated;

GRANT DELETE ON TABLE dashboard_public.message_groups TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.message_groups FOR INSERT TO authenticated WITH CHECK ( jwt_public.current_user_id() = ANY (member_ids) );

CREATE POLICY auth_upd ON dashboard_public.message_groups FOR UPDATE TO authenticated USING ( jwt_public.current_user_id() = ANY (member_ids) );

CREATE POLICY auth_sel ON dashboard_public.message_groups FOR SELECT TO authenticated USING ( jwt_public.current_user_id() = ANY (member_ids) );

CREATE POLICY auth_del ON dashboard_public.message_groups FOR DELETE TO authenticated USING ( jwt_public.current_user_id() = ANY (member_ids) );

CREATE TABLE dashboard_public.messages (
  
);

ALTER TABLE dashboard_public.messages DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.messages ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.messages ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.messages ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.messages ADD CONSTRAINT messages_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.messages ADD COLUMN  sender_id uuid;

ALTER TABLE dashboard_public.messages ALTER COLUMN sender_id SET NOT NULL;

ALTER TABLE dashboard_public.messages ALTER COLUMN sender_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_public.messages ADD COLUMN  type text;

ALTER TABLE dashboard_public.messages ALTER COLUMN type SET NOT NULL;

ALTER TABLE dashboard_public.messages ALTER COLUMN type SET DEFAULT 'text';

ALTER TABLE dashboard_public.messages ADD COLUMN  content jsonb;

ALTER TABLE dashboard_public.messages ADD COLUMN  upload upload;

ALTER TABLE dashboard_public.messages ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.messages ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.messages 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.messages ( created_by );

CREATE INDEX ON dashboard_public.messages ( updated_by );

ALTER TABLE dashboard_public.messages ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.messages ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.messages ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.messages ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.messages 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.messages ( created_at );

CREATE INDEX ON dashboard_public.messages ( updated_at );

ALTER TABLE dashboard_public.messages ADD CONSTRAINT messages_sender_id_fkey FOREIGN KEY ( sender_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT messages_sender_id_fkey ON dashboard_public.messages IS E'@omit manyToMany';

CREATE INDEX messages_sender_id_idx ON dashboard_public.messages ( sender_id );

ALTER TABLE dashboard_public.messages ADD COLUMN  group_id uuid;

ALTER TABLE dashboard_public.messages ALTER COLUMN group_id SET NOT NULL;

ALTER TABLE dashboard_public.messages ADD CONSTRAINT messages_group_id_fkey FOREIGN KEY ( group_id ) REFERENCES dashboard_public.message_groups ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT messages_group_id_fkey ON dashboard_public.messages IS E'@omit manyToMany';

CREATE INDEX messages_group_id_idx ON dashboard_public.messages ( group_id );

ALTER TABLE dashboard_public.messages ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.messages TO authenticated;

GRANT SELECT ON TABLE dashboard_public.messages TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.messages TO authenticated;

GRANT DELETE ON TABLE dashboard_public.messages TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.messages FOR SELECT TO authenticated USING ( (SELECT jwt_public.current_user_id() = ANY (p.member_ids) FROM dashboard_public.message_groups AS p WHERE p.id = group_id) );

CREATE POLICY auth_ins_own ON dashboard_public.messages AS RESTRICTIVE FOR INSERT TO authenticated WITH CHECK ( sender_id = jwt_public.current_user_id() );

CREATE POLICY auth_upd_own ON dashboard_public.messages AS RESTRICTIVE FOR UPDATE TO authenticated USING ( sender_id = jwt_public.current_user_id() );

CREATE POLICY auth_del_own ON dashboard_public.messages AS RESTRICTIVE FOR DELETE TO authenticated USING ( sender_id = jwt_public.current_user_id() );

CREATE TRIGGER messages_sender_id_owned_tg 
 AFTER UPDATE ON dashboard_public.messages 
 FOR EACH ROW
 WHEN ( new.sender_id <> jwt_public.current_user_id() AND old.content IS DISTINCT FROM new.content ) 
 EXECUTE PROCEDURE utils. throw ( 'OWNED_PROPS','sender_id' );

CREATE TABLE dashboard_public.posts (
  
);

ALTER TABLE dashboard_public.posts DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.posts ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.posts ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.posts ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.posts ADD CONSTRAINT posts_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.posts ADD COLUMN  poster_id uuid;

ALTER TABLE dashboard_public.posts ALTER COLUMN poster_id SET NOT NULL;

ALTER TABLE dashboard_public.posts ALTER COLUMN poster_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_public.posts ADD COLUMN  type text;

ALTER TABLE dashboard_public.posts ADD COLUMN  flagged bool;

ALTER TABLE dashboard_public.posts ALTER COLUMN flagged SET DEFAULT FALSE;

ALTER TABLE dashboard_public.posts ADD COLUMN  image image;

ALTER TABLE dashboard_public.posts ADD COLUMN  url url;

ALTER TABLE dashboard_public.posts ADD COLUMN  location geometry(point, 4326);

ALTER TABLE dashboard_public.posts ADD COLUMN  data jsonb;

ALTER TABLE dashboard_public.posts ADD COLUMN  tagged_user_ids uuid[];

ALTER TABLE dashboard_public.posts ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.posts ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.posts 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.posts ( created_by );

CREATE INDEX ON dashboard_public.posts ( updated_by );

ALTER TABLE dashboard_public.posts ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.posts ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.posts ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.posts ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.posts 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.posts ( created_at );

CREATE INDEX ON dashboard_public.posts ( updated_at );

ALTER TABLE dashboard_public.posts ADD CONSTRAINT posts_poster_id_fkey FOREIGN KEY ( poster_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT posts_poster_id_fkey ON dashboard_public.posts IS E'@omit manyToMany';

CREATE INDEX posts_poster_id_idx ON dashboard_public.posts ( poster_id );

ALTER TABLE dashboard_public.posts ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.posts TO authenticated;

GRANT SELECT ON TABLE dashboard_public.posts TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.posts TO authenticated;

GRANT DELETE ON TABLE dashboard_public.posts TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.posts FOR INSERT TO authenticated WITH CHECK ( poster_id = jwt_public.current_user_id() );

CREATE POLICY auth_upd ON dashboard_public.posts FOR UPDATE TO authenticated USING ( poster_id = jwt_public.current_user_id() );

CREATE POLICY auth_del ON dashboard_public.posts FOR DELETE TO authenticated USING ( poster_id = jwt_public.current_user_id() );

CREATE POLICY auth_del_admins ON dashboard_public.posts AS RESTRICTIVE FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000010000000000000000') = '00000000000000010000000000000000') );

CREATE POLICY auth_ins_create_post_check ON dashboard_public.posts AS RESTRICTIVE FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE POLICY auth_sel ON dashboard_public.posts FOR SELECT TO authenticated USING ( TRUE );

CREATE TABLE dashboard_public.post_reactions (
  
);

ALTER TABLE dashboard_public.post_reactions DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.post_reactions ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.post_reactions ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.post_reactions ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.post_reactions ADD CONSTRAINT post_reactions_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.post_reactions ADD COLUMN  reacter_id uuid;

ALTER TABLE dashboard_public.post_reactions ALTER COLUMN reacter_id SET NOT NULL;

ALTER TABLE dashboard_public.post_reactions ALTER COLUMN reacter_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_public.post_reactions ADD COLUMN  type int;

COMMENT ON COLUMN dashboard_public.post_reactions.type IS E'different types of reactions';

ALTER TABLE dashboard_public.post_reactions ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.post_reactions ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.post_reactions 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.post_reactions ( created_by );

CREATE INDEX ON dashboard_public.post_reactions ( updated_by );

ALTER TABLE dashboard_public.post_reactions ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.post_reactions ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.post_reactions ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.post_reactions ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.post_reactions 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.post_reactions ( created_at );

CREATE INDEX ON dashboard_public.post_reactions ( updated_at );

ALTER TABLE dashboard_public.post_reactions ADD CONSTRAINT post_reactions_reacter_id_fkey FOREIGN KEY ( reacter_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT post_reactions_reacter_id_fkey ON dashboard_public.post_reactions IS E'@omit manyToMany';

CREATE INDEX post_reactions_reacter_id_idx ON dashboard_public.post_reactions ( reacter_id );

ALTER TABLE dashboard_public.post_reactions ADD COLUMN  post_id uuid;

ALTER TABLE dashboard_public.post_reactions ALTER COLUMN post_id SET NOT NULL;

ALTER TABLE dashboard_public.post_reactions ADD CONSTRAINT post_reactions_post_id_fkey FOREIGN KEY ( post_id ) REFERENCES dashboard_public.posts ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT post_reactions_post_id_fkey ON dashboard_public.post_reactions IS E'@omit manyToMany';

CREATE INDEX post_reactions_post_id_idx ON dashboard_public.post_reactions ( post_id );

ALTER TABLE dashboard_public.post_reactions ADD COLUMN  poster_id uuid;

ALTER TABLE dashboard_public.post_reactions ALTER COLUMN poster_id SET NOT NULL;

ALTER TABLE dashboard_public.post_reactions ADD CONSTRAINT post_reactions_poster_id_fkey FOREIGN KEY ( poster_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT post_reactions_poster_id_fkey ON dashboard_public.post_reactions IS E'@omit manyToMany';

CREATE INDEX post_reactions_poster_id_idx ON dashboard_public.post_reactions ( poster_id );

ALTER TABLE dashboard_public.post_reactions ALTER COLUMN poster_id SET DEFAULT uuid_nil();

CREATE FUNCTION dashboard_private.post_reactions_denorm_post_id (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  SELECT ref.poster_id FROM "dashboard_public".posts AS ref WHERE ref.id = new.post_id
  INTO new.poster_id;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_post_id 
 BEFORE INSERT ON dashboard_public.post_reactions 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. post_reactions_denorm_post_id (  );

CREATE TRIGGER _000000000_ensure_update_post_id 
 BEFORE UPDATE ON dashboard_public.post_reactions 
 FOR EACH ROW
 WHEN ( old.post_id IS DISTINCT FROM new.post_id OR old.poster_id IS DISTINCT FROM new.poster_id ) 
 EXECUTE PROCEDURE dashboard_private. post_reactions_denorm_post_id (  );

ALTER TABLE dashboard_public.post_reactions ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.post_reactions TO authenticated;

GRANT SELECT ON TABLE dashboard_public.post_reactions TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.post_reactions TO authenticated;

GRANT DELETE ON TABLE dashboard_public.post_reactions TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.post_reactions FOR INSERT TO authenticated WITH CHECK ( reacter_id = jwt_public.current_user_id() );

CREATE POLICY auth_upd ON dashboard_public.post_reactions FOR UPDATE TO authenticated USING ( reacter_id = jwt_public.current_user_id() );

CREATE POLICY auth_del ON dashboard_public.post_reactions FOR DELETE TO authenticated USING ( reacter_id = jwt_public.current_user_id() );

CREATE POLICY auth_sel ON dashboard_public.post_reactions FOR SELECT TO authenticated USING ( TRUE );

CREATE TABLE dashboard_public.post_comments (
  
);

ALTER TABLE dashboard_public.post_comments DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.post_comments ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.post_comments ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.post_comments ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.post_comments ADD CONSTRAINT post_comments_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.post_comments ADD COLUMN  commenter_id uuid;

ALTER TABLE dashboard_public.post_comments ALTER COLUMN commenter_id SET NOT NULL;

ALTER TABLE dashboard_public.post_comments ALTER COLUMN commenter_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_public.post_comments ADD COLUMN  parent_id uuid;

COMMENT ON COLUMN dashboard_public.post_comments.parent_id IS E'optional, parent comment.';

ALTER TABLE dashboard_public.post_comments ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.post_comments ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.post_comments 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.post_comments ( created_by );

CREATE INDEX ON dashboard_public.post_comments ( updated_by );

ALTER TABLE dashboard_public.post_comments ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.post_comments ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.post_comments ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.post_comments ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.post_comments 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.post_comments ( created_at );

CREATE INDEX ON dashboard_public.post_comments ( updated_at );

ALTER TABLE dashboard_public.post_comments ADD CONSTRAINT post_comments_commenter_id_fkey FOREIGN KEY ( commenter_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT post_comments_commenter_id_fkey ON dashboard_public.post_comments IS E'@omit manyToMany';

CREATE INDEX post_comments_commenter_id_idx ON dashboard_public.post_comments ( commenter_id );

ALTER TABLE dashboard_public.post_comments ADD COLUMN  post_id uuid;

ALTER TABLE dashboard_public.post_comments ALTER COLUMN post_id SET NOT NULL;

ALTER TABLE dashboard_public.post_comments ADD CONSTRAINT post_comments_post_id_fkey FOREIGN KEY ( post_id ) REFERENCES dashboard_public.posts ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT post_comments_post_id_fkey ON dashboard_public.post_comments IS E'@omit manyToMany';

CREATE INDEX post_comments_post_id_idx ON dashboard_public.post_comments ( post_id );

ALTER TABLE dashboard_public.post_comments ADD COLUMN  poster_id uuid;

ALTER TABLE dashboard_public.post_comments ALTER COLUMN poster_id SET NOT NULL;

ALTER TABLE dashboard_public.post_comments ADD CONSTRAINT post_comments_poster_id_fkey FOREIGN KEY ( poster_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT post_comments_poster_id_fkey ON dashboard_public.post_comments IS E'@omit manyToMany';

CREATE INDEX post_comments_poster_id_idx ON dashboard_public.post_comments ( poster_id );

ALTER TABLE dashboard_public.post_comments ADD CONSTRAINT post_comments_parent_id_fkey FOREIGN KEY ( parent_id ) REFERENCES dashboard_public.post_comments ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT post_comments_parent_id_fkey ON dashboard_public.post_comments IS E'@omit manyToMany';

CREATE INDEX post_comments_parent_id_idx ON dashboard_public.post_comments ( parent_id );

ALTER TABLE dashboard_public.post_comments ALTER COLUMN poster_id SET DEFAULT uuid_nil();

CREATE FUNCTION dashboard_private.post_comments_denorm_post_id (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  SELECT ref.poster_id FROM "dashboard_public".posts AS ref WHERE ref.id = new.post_id
  INTO new.poster_id;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_post_id 
 BEFORE INSERT ON dashboard_public.post_comments 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. post_comments_denorm_post_id (  );

CREATE TRIGGER _000000000_ensure_update_post_id 
 BEFORE UPDATE ON dashboard_public.post_comments 
 FOR EACH ROW
 WHEN ( old.post_id IS DISTINCT FROM new.post_id OR old.poster_id IS DISTINCT FROM new.poster_id ) 
 EXECUTE PROCEDURE dashboard_private. post_comments_denorm_post_id (  );

ALTER TABLE dashboard_public.post_comments ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.post_comments TO authenticated;

GRANT SELECT ON TABLE dashboard_public.post_comments TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.post_comments TO authenticated;

GRANT DELETE ON TABLE dashboard_public.post_comments TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.post_comments FOR INSERT TO authenticated WITH CHECK ( commenter_id = jwt_public.current_user_id() );

CREATE POLICY auth_upd ON dashboard_public.post_comments FOR UPDATE TO authenticated USING ( commenter_id = jwt_public.current_user_id() );

CREATE POLICY auth_del ON dashboard_public.post_comments FOR DELETE TO authenticated USING ( commenter_id = jwt_public.current_user_id() );

CREATE POLICY auth_sel ON dashboard_public.post_comments FOR SELECT TO authenticated USING ( TRUE );

CREATE TABLE dashboard_public.group_posts (
  
);

ALTER TABLE dashboard_public.group_posts DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.group_posts ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.group_posts ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.group_posts ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.group_posts ADD CONSTRAINT group_posts_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.group_posts ADD COLUMN  poster_id uuid;

ALTER TABLE dashboard_public.group_posts ALTER COLUMN poster_id SET NOT NULL;

ALTER TABLE dashboard_public.group_posts ALTER COLUMN poster_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_public.group_posts ADD COLUMN  type text;

ALTER TABLE dashboard_public.group_posts ADD COLUMN  flagged bool;

ALTER TABLE dashboard_public.group_posts ALTER COLUMN flagged SET DEFAULT FALSE;

ALTER TABLE dashboard_public.group_posts ADD COLUMN  image image;

ALTER TABLE dashboard_public.group_posts ADD COLUMN  url url;

ALTER TABLE dashboard_public.group_posts ADD COLUMN  location geometry(point, 4326);

ALTER TABLE dashboard_public.group_posts ADD COLUMN  data jsonb;

ALTER TABLE dashboard_public.group_posts ADD COLUMN  tagged_user_ids uuid[];

ALTER TABLE dashboard_public.group_posts ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.group_posts ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.group_posts 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.group_posts ( created_by );

CREATE INDEX ON dashboard_public.group_posts ( updated_by );

ALTER TABLE dashboard_public.group_posts ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.group_posts ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.group_posts ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.group_posts ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.group_posts 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.group_posts ( created_at );

CREATE INDEX ON dashboard_public.group_posts ( updated_at );

ALTER TABLE dashboard_public.group_posts ADD COLUMN  group_id uuid;

ALTER TABLE dashboard_public.group_posts ALTER COLUMN group_id SET NOT NULL;

ALTER TABLE dashboard_public.group_posts ADD CONSTRAINT group_posts_group_id_fkey FOREIGN KEY ( group_id ) REFERENCES dashboard_public.groups ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT group_posts_group_id_fkey ON dashboard_public.group_posts IS E'@omit manyToMany';

CREATE INDEX group_posts_group_id_idx ON dashboard_public.group_posts ( group_id );

ALTER TABLE dashboard_public.group_posts ADD CONSTRAINT group_posts_poster_id_fkey FOREIGN KEY ( poster_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT group_posts_poster_id_fkey ON dashboard_public.group_posts IS E'@omit manyToMany';

CREATE INDEX group_posts_poster_id_idx ON dashboard_public.group_posts ( poster_id );

ALTER TABLE dashboard_public.group_posts ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.group_posts TO authenticated;

GRANT SELECT ON TABLE dashboard_public.group_posts TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.group_posts TO authenticated;

GRANT DELETE ON TABLE dashboard_public.group_posts TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.group_posts FOR INSERT TO authenticated WITH CHECK ( poster_id = jwt_public.current_user_id() );

CREATE POLICY auth_upd ON dashboard_public.group_posts FOR UPDATE TO authenticated USING ( poster_id = jwt_public.current_user_id() );

CREATE POLICY auth_del ON dashboard_public.group_posts FOR DELETE TO authenticated USING ( poster_id = jwt_public.current_user_id() );

CREATE POLICY auth_del_admins ON dashboard_public.group_posts AS RESTRICTIVE FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000100000000000') = '00000000000000000000100000000000') );

CREATE POLICY auth_ins_create_post_check ON dashboard_public.group_posts AS RESTRICTIVE FOR INSERT TO authenticated WITH CHECK ( group_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000010000000000') = '00000000000000000000010000000000') );

CREATE POLICY auth_sel ON dashboard_public.group_posts FOR SELECT TO authenticated USING ( group_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id()) );

CREATE TABLE dashboard_public.group_post_reactions (
  
);

ALTER TABLE dashboard_public.group_post_reactions DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.group_post_reactions ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.group_post_reactions ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.group_post_reactions ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.group_post_reactions ADD CONSTRAINT group_post_reactions_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.group_post_reactions ADD COLUMN  reacter_id uuid;

ALTER TABLE dashboard_public.group_post_reactions ALTER COLUMN reacter_id SET NOT NULL;

ALTER TABLE dashboard_public.group_post_reactions ALTER COLUMN reacter_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_public.group_post_reactions ADD COLUMN  type text;

COMMENT ON COLUMN dashboard_public.group_post_reactions.type IS E'different types of reactions';

ALTER TABLE dashboard_public.group_post_reactions ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.group_post_reactions ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.group_post_reactions 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.group_post_reactions ( created_by );

CREATE INDEX ON dashboard_public.group_post_reactions ( updated_by );

ALTER TABLE dashboard_public.group_post_reactions ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.group_post_reactions ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.group_post_reactions ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.group_post_reactions ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.group_post_reactions 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.group_post_reactions ( created_at );

CREATE INDEX ON dashboard_public.group_post_reactions ( updated_at );

ALTER TABLE dashboard_public.group_post_reactions ADD CONSTRAINT group_post_reactions_reacter_id_fkey FOREIGN KEY ( reacter_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT group_post_reactions_reacter_id_fkey ON dashboard_public.group_post_reactions IS E'@omit manyToMany';

CREATE INDEX group_post_reactions_reacter_id_idx ON dashboard_public.group_post_reactions ( reacter_id );

ALTER TABLE dashboard_public.group_post_reactions ADD COLUMN  group_id uuid;

ALTER TABLE dashboard_public.group_post_reactions ALTER COLUMN group_id SET NOT NULL;

ALTER TABLE dashboard_public.group_post_reactions ADD CONSTRAINT group_post_reactions_group_id_fkey FOREIGN KEY ( group_id ) REFERENCES dashboard_public.groups ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT group_post_reactions_group_id_fkey ON dashboard_public.group_post_reactions IS E'@omit manyToMany';

CREATE INDEX group_post_reactions_group_id_idx ON dashboard_public.group_post_reactions ( group_id );

ALTER TABLE dashboard_public.group_post_reactions ADD COLUMN  poster_id uuid;

ALTER TABLE dashboard_public.group_post_reactions ALTER COLUMN poster_id SET NOT NULL;

ALTER TABLE dashboard_public.group_post_reactions ADD CONSTRAINT group_post_reactions_poster_id_fkey FOREIGN KEY ( poster_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT group_post_reactions_poster_id_fkey ON dashboard_public.group_post_reactions IS E'@omit manyToMany';

CREATE INDEX group_post_reactions_poster_id_idx ON dashboard_public.group_post_reactions ( poster_id );

ALTER TABLE dashboard_public.group_post_reactions ADD COLUMN  post_id uuid;

ALTER TABLE dashboard_public.group_post_reactions ALTER COLUMN post_id SET NOT NULL;

ALTER TABLE dashboard_public.group_post_reactions ADD CONSTRAINT group_post_reactions_post_id_fkey FOREIGN KEY ( post_id ) REFERENCES dashboard_public.group_posts ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT group_post_reactions_post_id_fkey ON dashboard_public.group_post_reactions IS E'@omit manyToMany';

CREATE INDEX group_post_reactions_post_id_idx ON dashboard_public.group_post_reactions ( post_id );

ALTER TABLE dashboard_public.group_post_reactions ALTER COLUMN group_id SET DEFAULT uuid_nil();

ALTER TABLE dashboard_public.group_post_reactions ALTER COLUMN poster_id SET DEFAULT uuid_nil();

CREATE FUNCTION dashboard_private.group_post_reactions_denorm_post_id (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  SELECT ref.poster_id,
ref.group_id FROM "dashboard_public".group_posts AS ref WHERE ref.id = new.post_id
  INTO new.poster_id,
new.group_id;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_post_id 
 BEFORE INSERT ON dashboard_public.group_post_reactions 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. group_post_reactions_denorm_post_id (  );

CREATE TRIGGER _000000000_ensure_update_post_id 
 BEFORE UPDATE ON dashboard_public.group_post_reactions 
 FOR EACH ROW
 WHEN ( old.post_id IS DISTINCT FROM new.post_id OR old.poster_id IS DISTINCT FROM new.poster_id OR old.group_id IS DISTINCT FROM new.group_id ) 
 EXECUTE PROCEDURE dashboard_private. group_post_reactions_denorm_post_id (  );

ALTER TABLE dashboard_public.group_post_reactions ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.group_post_reactions TO authenticated;

GRANT SELECT ON TABLE dashboard_public.group_post_reactions TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.group_post_reactions TO authenticated;

GRANT DELETE ON TABLE dashboard_public.group_post_reactions TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.group_post_reactions FOR INSERT TO authenticated WITH CHECK ( reacter_id = jwt_public.current_user_id() );

CREATE POLICY auth_upd ON dashboard_public.group_post_reactions FOR UPDATE TO authenticated USING ( reacter_id = jwt_public.current_user_id() );

CREATE POLICY auth_del ON dashboard_public.group_post_reactions FOR DELETE TO authenticated USING ( reacter_id = jwt_public.current_user_id() );

CREATE POLICY auth_ins_create_post_reaction_check ON dashboard_public.group_post_reactions AS RESTRICTIVE FOR INSERT TO authenticated WITH CHECK ( group_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id()) );

CREATE POLICY auth_sel ON dashboard_public.group_post_reactions FOR SELECT TO authenticated USING ( group_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id()) );

CREATE TABLE dashboard_public.group_post_comments (
  
);

ALTER TABLE dashboard_public.group_post_comments DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.group_post_comments ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.group_post_comments ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.group_post_comments ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.group_post_comments ADD CONSTRAINT group_post_comments_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.group_post_comments ADD COLUMN  commenter_id uuid;

ALTER TABLE dashboard_public.group_post_comments ALTER COLUMN commenter_id SET NOT NULL;

ALTER TABLE dashboard_public.group_post_comments ALTER COLUMN commenter_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_public.group_post_comments ADD COLUMN  parent_id uuid;

COMMENT ON COLUMN dashboard_public.group_post_comments.parent_id IS E'optional, parent comment.';

ALTER TABLE dashboard_public.group_post_comments ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.group_post_comments ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.group_post_comments 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.group_post_comments ( created_by );

CREATE INDEX ON dashboard_public.group_post_comments ( updated_by );

ALTER TABLE dashboard_public.group_post_comments ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.group_post_comments ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.group_post_comments ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.group_post_comments ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.group_post_comments 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.group_post_comments ( created_at );

CREATE INDEX ON dashboard_public.group_post_comments ( updated_at );

ALTER TABLE dashboard_public.group_post_comments ADD COLUMN  group_id uuid;

ALTER TABLE dashboard_public.group_post_comments ALTER COLUMN group_id SET NOT NULL;

ALTER TABLE dashboard_public.group_post_comments ADD CONSTRAINT group_post_comments_group_id_fkey FOREIGN KEY ( group_id ) REFERENCES dashboard_public.groups ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT group_post_comments_group_id_fkey ON dashboard_public.group_post_comments IS E'@omit manyToMany';

CREATE INDEX group_post_comments_group_id_idx ON dashboard_public.group_post_comments ( group_id );

ALTER TABLE dashboard_public.group_post_comments ADD CONSTRAINT group_post_comments_commenter_id_fkey FOREIGN KEY ( commenter_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT group_post_comments_commenter_id_fkey ON dashboard_public.group_post_comments IS E'@omit manyToMany';

CREATE INDEX group_post_comments_commenter_id_idx ON dashboard_public.group_post_comments ( commenter_id );

ALTER TABLE dashboard_public.group_post_comments ADD COLUMN  post_id uuid;

ALTER TABLE dashboard_public.group_post_comments ALTER COLUMN post_id SET NOT NULL;

ALTER TABLE dashboard_public.group_post_comments ADD CONSTRAINT group_post_comments_post_id_fkey FOREIGN KEY ( post_id ) REFERENCES dashboard_public.group_posts ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT group_post_comments_post_id_fkey ON dashboard_public.group_post_comments IS E'@omit manyToMany';

CREATE INDEX group_post_comments_post_id_idx ON dashboard_public.group_post_comments ( post_id );

ALTER TABLE dashboard_public.group_post_comments ADD COLUMN  poster_id uuid;

ALTER TABLE dashboard_public.group_post_comments ALTER COLUMN poster_id SET NOT NULL;

ALTER TABLE dashboard_public.group_post_comments ADD CONSTRAINT group_post_comments_poster_id_fkey FOREIGN KEY ( poster_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT group_post_comments_poster_id_fkey ON dashboard_public.group_post_comments IS E'@omit manyToMany';

CREATE INDEX group_post_comments_poster_id_idx ON dashboard_public.group_post_comments ( poster_id );

ALTER TABLE dashboard_public.group_post_comments ADD CONSTRAINT group_post_comments_parent_id_fkey FOREIGN KEY ( parent_id ) REFERENCES dashboard_public.group_post_comments ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT group_post_comments_parent_id_fkey ON dashboard_public.group_post_comments IS E'@omit manyToMany';

CREATE INDEX group_post_comments_parent_id_idx ON dashboard_public.group_post_comments ( parent_id );

ALTER TABLE dashboard_public.group_post_comments ALTER COLUMN group_id SET DEFAULT uuid_nil();

ALTER TABLE dashboard_public.group_post_comments ALTER COLUMN poster_id SET DEFAULT uuid_nil();

CREATE FUNCTION dashboard_private.group_post_comments_denorm_post_id (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  SELECT ref.poster_id,
ref.group_id FROM "dashboard_public".group_posts AS ref WHERE ref.id = new.post_id
  INTO new.poster_id,
new.group_id;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_post_id 
 BEFORE INSERT ON dashboard_public.group_post_comments 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. group_post_comments_denorm_post_id (  );

CREATE TRIGGER _000000000_ensure_update_post_id 
 BEFORE UPDATE ON dashboard_public.group_post_comments 
 FOR EACH ROW
 WHEN ( old.post_id IS DISTINCT FROM new.post_id OR old.poster_id IS DISTINCT FROM new.poster_id OR old.group_id IS DISTINCT FROM new.group_id ) 
 EXECUTE PROCEDURE dashboard_private. group_post_comments_denorm_post_id (  );

ALTER TABLE dashboard_public.group_post_comments ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.group_post_comments TO authenticated;

GRANT SELECT ON TABLE dashboard_public.group_post_comments TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.group_post_comments TO authenticated;

GRANT DELETE ON TABLE dashboard_public.group_post_comments TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.group_post_comments FOR INSERT TO authenticated WITH CHECK ( commenter_id = jwt_public.current_user_id() );

CREATE POLICY auth_upd ON dashboard_public.group_post_comments FOR UPDATE TO authenticated USING ( commenter_id = jwt_public.current_user_id() );

CREATE POLICY auth_del ON dashboard_public.group_post_comments FOR DELETE TO authenticated USING ( commenter_id = jwt_public.current_user_id() );

CREATE POLICY auth_ins_create_post_comment_check ON dashboard_public.group_post_comments AS RESTRICTIVE FOR INSERT TO authenticated WITH CHECK ( group_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id()) );

CREATE POLICY auth_sel ON dashboard_public.group_post_comments FOR SELECT TO authenticated USING ( group_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id()) );

CREATE TABLE dashboard_public.group_locations (
  
);

ALTER TABLE dashboard_public.group_locations DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.group_locations ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.group_locations ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.group_locations ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.group_locations ADD CONSTRAINT group_locations_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.group_locations ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.group_locations ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.group_locations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.group_locations ( created_by );

CREATE INDEX ON dashboard_public.group_locations ( updated_by );

ALTER TABLE dashboard_public.group_locations ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.group_locations ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.group_locations ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.group_locations ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.group_locations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.group_locations ( created_at );

CREATE INDEX ON dashboard_public.group_locations ( updated_at );

ALTER TABLE dashboard_public.group_locations ADD COLUMN  group_id uuid;

ALTER TABLE dashboard_public.group_locations ALTER COLUMN group_id SET NOT NULL;

ALTER TABLE dashboard_public.group_locations ADD CONSTRAINT group_locations_group_id_fkey FOREIGN KEY ( group_id ) REFERENCES dashboard_public.groups ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT group_locations_group_id_fkey ON dashboard_public.group_locations IS E'@omit manyToMany';

CREATE INDEX group_locations_group_id_idx ON dashboard_public.group_locations ( group_id );

ALTER TABLE dashboard_public.group_locations ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.group_locations ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.group_locations ADD CONSTRAINT group_locations_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT group_locations_owner_id_fkey ON dashboard_public.group_locations IS E'@omit manyToMany';

CREATE INDEX group_locations_owner_id_idx ON dashboard_public.group_locations ( owner_id );

ALTER TABLE dashboard_public.group_locations ADD COLUMN  location_id uuid;

ALTER TABLE dashboard_public.group_locations ALTER COLUMN location_id SET NOT NULL;

ALTER TABLE dashboard_public.group_locations ADD CONSTRAINT group_locations_location_id_fkey FOREIGN KEY ( location_id ) REFERENCES dashboard_public.locations ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT group_locations_location_id_fkey ON dashboard_public.group_locations IS E'@omit manyToMany';

CREATE INDEX group_locations_location_id_idx ON dashboard_public.group_locations ( location_id );

CREATE TRIGGER group_locations_owner_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.group_locations 
 FOR EACH ROW
 WHEN ( old.owner_id IS DISTINCT FROM new.owner_id AND old.owner_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','owner_id' );

CREATE TRIGGER group_locations_group_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.group_locations 
 FOR EACH ROW
 WHEN ( old.group_id IS DISTINCT FROM new.group_id AND old.group_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','group_id' );

ALTER TABLE dashboard_public.group_locations ALTER COLUMN owner_id SET DEFAULT uuid_nil();

CREATE FUNCTION dashboard_private.group_locations_denorm_group_id (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  SELECT ref.owner_id FROM "dashboard_public".groups AS ref WHERE ref.id = new.group_id
  INTO new.owner_id;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_group_id 
 BEFORE INSERT ON dashboard_public.group_locations 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. group_locations_denorm_group_id (  );

CREATE TRIGGER _000000000_ensure_update_group_id 
 BEFORE UPDATE ON dashboard_public.group_locations 
 FOR EACH ROW
 WHEN ( old.group_id IS DISTINCT FROM new.group_id OR old.owner_id IS DISTINCT FROM new.owner_id ) 
 EXECUTE PROCEDURE dashboard_private. group_locations_denorm_group_id (  );

ALTER TABLE dashboard_public.group_locations ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.group_locations TO authenticated;

GRANT SELECT ON TABLE dashboard_public.group_locations TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.group_locations TO authenticated;

GRANT DELETE ON TABLE dashboard_public.group_locations TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.group_locations FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_public.group_locations FOR INSERT TO authenticated WITH CHECK ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_upd ON dashboard_public.group_locations FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_del ON dashboard_public.group_locations FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE TABLE dashboard_public.group_goals (
  
);

ALTER TABLE dashboard_public.group_goals DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.group_goals ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.group_goals ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.group_goals ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.group_goals ADD CONSTRAINT group_goals_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.group_goals ADD COLUMN  name text;

ALTER TABLE dashboard_public.group_goals ADD COLUMN  icon text;

ALTER TABLE dashboard_public.group_goals ADD COLUMN  image image;

ALTER TABLE dashboard_public.group_goals ADD COLUMN  impact_type text;

COMMENT ON COLUMN dashboard_public.group_goals.impact_type IS E'if no impact_object_type exists, use this';

ALTER TABLE dashboard_public.group_goals ADD COLUMN  impact_unit_value numeric;

COMMENT ON COLUMN dashboard_public.group_goals.impact_unit_value IS E'magnitude or number of the impact quantity';

ALTER TABLE dashboard_public.group_goals ADD COLUMN  per_interval interval;

COMMENT ON COLUMN dashboard_public.group_goals.per_interval IS E'impact is measured per this interval';

ALTER TABLE dashboard_public.group_goals ADD COLUMN  per_value numeric;

COMMENT ON COLUMN dashboard_public.group_goals.per_value IS E'impact value measured for per_unit field';

ALTER TABLE dashboard_public.group_goals ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.group_goals ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.group_goals 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.group_goals ( created_by );

CREATE INDEX ON dashboard_public.group_goals ( updated_by );

ALTER TABLE dashboard_public.group_goals ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.group_goals ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.group_goals ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.group_goals ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.group_goals 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.group_goals ( created_at );

CREATE INDEX ON dashboard_public.group_goals ( updated_at );

ALTER TABLE dashboard_public.group_goals ADD COLUMN  group_id uuid;

ALTER TABLE dashboard_public.group_goals ALTER COLUMN group_id SET NOT NULL;

ALTER TABLE dashboard_public.group_goals ADD CONSTRAINT group_goals_group_id_fkey FOREIGN KEY ( group_id ) REFERENCES dashboard_public.groups ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT group_goals_group_id_fkey ON dashboard_public.group_goals IS E'@omit manyToMany';

CREATE INDEX group_goals_group_id_idx ON dashboard_public.group_goals ( group_id );

ALTER TABLE dashboard_public.group_goals ADD COLUMN  per_unit_id uuid;

ALTER TABLE dashboard_public.group_goals ADD CONSTRAINT group_goals_per_unit_id_fkey FOREIGN KEY ( per_unit_id ) REFERENCES dashboard_public.units ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT group_goals_per_unit_id_fkey ON dashboard_public.group_goals IS E'@omit manyToMany';

CREATE INDEX group_goals_per_unit_id_idx ON dashboard_public.group_goals ( per_unit_id );

ALTER TABLE dashboard_public.group_goals ADD COLUMN  impact_unit_id uuid;

ALTER TABLE dashboard_public.group_goals ADD CONSTRAINT group_goals_impact_unit_id_fkey FOREIGN KEY ( impact_unit_id ) REFERENCES dashboard_public.units ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT group_goals_impact_unit_id_fkey ON dashboard_public.group_goals IS E'@omit manyToMany';

CREATE INDEX group_goals_impact_unit_id_idx ON dashboard_public.group_goals ( impact_unit_id );

ALTER TABLE dashboard_public.group_goals ADD COLUMN  impact_object_type_id uuid;

ALTER TABLE dashboard_public.group_goals ADD CONSTRAINT group_goals_impact_object_type_id_fkey FOREIGN KEY ( impact_object_type_id ) REFERENCES dashboard_public.object_types ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT group_goals_impact_object_type_id_fkey ON dashboard_public.group_goals IS E'@omit manyToMany';

CREATE INDEX group_goals_impact_object_type_id_idx ON dashboard_public.group_goals ( impact_object_type_id );

ALTER TABLE dashboard_public.group_goals ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.group_goals TO authenticated;

GRANT SELECT ON TABLE dashboard_public.group_goals TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.group_goals TO authenticated;

GRANT DELETE ON TABLE dashboard_public.group_goals TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.group_goals FOR INSERT TO authenticated WITH CHECK ( group_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_upd ON dashboard_public.group_goals FOR UPDATE TO authenticated USING ( group_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_del ON dashboard_public.group_goals FOR DELETE TO authenticated USING ( group_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_sel ON dashboard_public.group_goals FOR SELECT TO authenticated USING ( group_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id()) );

CREATE TABLE dashboard_public.user_devices (
  
);

ALTER TABLE dashboard_public.user_devices DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.user_devices ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.user_devices ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.user_devices ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.user_devices ADD CONSTRAINT user_devices_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.user_devices ADD COLUMN  type int;

ALTER TABLE dashboard_public.user_devices ALTER COLUMN type SET NOT NULL;

ALTER TABLE dashboard_public.user_devices ADD COLUMN  device_id text;

ALTER TABLE dashboard_public.user_devices ADD CONSTRAINT user_devices_device_id_chk CHECK ( character_length(device_id) <= 1048 );

ALTER TABLE dashboard_public.user_devices ADD COLUMN  push_token text;

ALTER TABLE dashboard_public.user_devices ADD CONSTRAINT user_devices_push_token_chk CHECK ( character_length(push_token) <= 1048 );

ALTER TABLE dashboard_public.user_devices ADD COLUMN  push_token_requested boolean;

ALTER TABLE dashboard_public.user_devices ALTER COLUMN push_token_requested SET DEFAULT FALSE;

ALTER TABLE dashboard_public.user_devices ADD COLUMN  data jsonb;

ALTER TABLE dashboard_public.user_devices ADD COLUMN  user_id uuid;

ALTER TABLE dashboard_public.user_devices ALTER COLUMN user_id SET NOT NULL;

ALTER TABLE dashboard_public.user_devices ALTER COLUMN user_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_public.user_devices ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.user_devices ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_devices 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.user_devices ( created_by );

CREATE INDEX ON dashboard_public.user_devices ( updated_by );

ALTER TABLE dashboard_public.user_devices ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.user_devices ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.user_devices ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.user_devices ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_devices 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.user_devices ( created_at );

CREATE INDEX ON dashboard_public.user_devices ( updated_at );

ALTER TABLE dashboard_public.user_devices ADD CONSTRAINT user_devices_user_id_fkey FOREIGN KEY ( user_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_devices_user_id_fkey ON dashboard_public.user_devices IS E'@omit manyToMany';

CREATE INDEX user_devices_user_id_idx ON dashboard_public.user_devices ( user_id );

ALTER TABLE dashboard_public.user_devices ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.user_devices TO authenticated;

GRANT SELECT ON TABLE dashboard_public.user_devices TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.user_devices TO authenticated;

GRANT DELETE ON TABLE dashboard_public.user_devices TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.user_devices FOR INSERT TO authenticated WITH CHECK ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_sel ON dashboard_public.user_devices FOR SELECT TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_upd ON dashboard_public.user_devices FOR UPDATE TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_del ON dashboard_public.user_devices FOR DELETE TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE TABLE dashboard_public.notifications (
  
);

ALTER TABLE dashboard_public.notifications DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.notifications ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.notifications ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.notifications ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.notifications ADD CONSTRAINT notifications_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.notifications ADD COLUMN  actor_id uuid;

ALTER TABLE dashboard_public.notifications ADD COLUMN  recipient_id uuid;

ALTER TABLE dashboard_public.notifications ADD COLUMN  notification_type text;

COMMENT ON COLUMN dashboard_public.notifications.notification_type IS E'the verb';

ALTER TABLE dashboard_public.notifications ADD COLUMN  should_push boolean;

ALTER TABLE dashboard_public.notifications ALTER COLUMN should_push SET NOT NULL;

ALTER TABLE dashboard_public.notifications ALTER COLUMN should_push SET DEFAULT FALSE;

ALTER TABLE dashboard_public.notifications ADD COLUMN  notification_text text;

COMMENT ON COLUMN dashboard_public.notifications.notification_text IS E'the text you actually see on the phone';

ALTER TABLE dashboard_public.notifications ADD COLUMN  entity_type text;

COMMENT ON COLUMN dashboard_public.notifications.entity_type IS E'e.g., Post, Comment, Action, etc.';

ALTER TABLE dashboard_public.notifications ADD COLUMN  data jsonb;

COMMENT ON COLUMN dashboard_public.notifications.data IS E'all data required to send user to URLs, create emails, send notifications, etc';

ALTER TABLE dashboard_public.notifications ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.notifications ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.notifications 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.notifications ( created_by );

CREATE INDEX ON dashboard_public.notifications ( updated_by );

ALTER TABLE dashboard_public.notifications ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.notifications ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.notifications ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.notifications ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.notifications 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.notifications ( created_at );

CREATE INDEX ON dashboard_public.notifications ( updated_at );

ALTER TABLE dashboard_public.notifications ADD CONSTRAINT notifications_actor_id_fkey FOREIGN KEY ( actor_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT notifications_actor_id_fkey ON dashboard_public.notifications IS E'@omit manyToMany';

CREATE INDEX notifications_actor_id_idx ON dashboard_public.notifications ( actor_id );

ALTER TABLE dashboard_public.notifications ADD CONSTRAINT notifications_recipient_id_fkey FOREIGN KEY ( recipient_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT notifications_recipient_id_fkey ON dashboard_public.notifications IS E'@omit manyToMany';

CREATE INDEX notifications_recipient_id_idx ON dashboard_public.notifications ( recipient_id );

ALTER TABLE dashboard_public.notifications ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.notifications TO authenticated;

GRANT SELECT ON TABLE dashboard_public.notifications TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.notifications TO authenticated;

GRANT DELETE ON TABLE dashboard_public.notifications TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.notifications FOR SELECT TO authenticated USING ( recipient_id = jwt_public.current_user_id() );

CREATE POLICY auth_ins ON dashboard_public.notifications FOR INSERT TO authenticated WITH CHECK ( recipient_id = jwt_public.current_user_id() );

CREATE POLICY auth_upd ON dashboard_public.notifications FOR UPDATE TO authenticated USING ( recipient_id = jwt_public.current_user_id() );

CREATE POLICY auth_del ON dashboard_public.notifications FOR DELETE TO authenticated USING ( recipient_id = jwt_public.current_user_id() );

CREATE TABLE dashboard_public.notification_preferences (
  
);

ALTER TABLE dashboard_public.notification_preferences DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.notification_preferences ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.notification_preferences ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.notification_preferences ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.notification_preferences ADD CONSTRAINT notification_preferences_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.notification_preferences ADD COLUMN  user_id uuid;

ALTER TABLE dashboard_public.notification_preferences ALTER COLUMN user_id SET NOT NULL;

ALTER TABLE dashboard_public.notification_preferences ALTER COLUMN user_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_public.notification_preferences ADD COLUMN  emails boolean;

ALTER TABLE dashboard_public.notification_preferences ALTER COLUMN emails SET DEFAULT FALSE;

ALTER TABLE dashboard_public.notification_preferences ADD COLUMN  sms boolean;

ALTER TABLE dashboard_public.notification_preferences ALTER COLUMN sms SET DEFAULT FALSE;

ALTER TABLE dashboard_public.notification_preferences ADD COLUMN  notifications boolean;

ALTER TABLE dashboard_public.notification_preferences ALTER COLUMN notifications SET DEFAULT FALSE;

ALTER TABLE dashboard_public.notification_preferences ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.notification_preferences ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.notification_preferences 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.notification_preferences ( created_by );

CREATE INDEX ON dashboard_public.notification_preferences ( updated_by );

ALTER TABLE dashboard_public.notification_preferences ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.notification_preferences ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.notification_preferences ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.notification_preferences ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.notification_preferences 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.notification_preferences ( created_at );

CREATE INDEX ON dashboard_public.notification_preferences ( updated_at );

ALTER TABLE dashboard_public.notification_preferences ADD CONSTRAINT notification_preferences_user_id_fkey FOREIGN KEY ( user_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT notification_preferences_user_id_fkey ON dashboard_public.notification_preferences IS E'@omit manyToMany';

CREATE INDEX notification_preferences_user_id_idx ON dashboard_public.notification_preferences ( user_id );

ALTER TABLE dashboard_public.notification_preferences ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.notification_preferences TO authenticated;

GRANT SELECT ON TABLE dashboard_public.notification_preferences TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.notification_preferences TO authenticated;

GRANT DELETE ON TABLE dashboard_public.notification_preferences TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.notification_preferences FOR INSERT TO authenticated WITH CHECK ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_sel ON dashboard_public.notification_preferences FOR SELECT TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_upd ON dashboard_public.notification_preferences FOR UPDATE TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_del ON dashboard_public.notification_preferences FOR DELETE TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE TABLE dashboard_public.question_templates (
  
);

ALTER TABLE dashboard_public.question_templates DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.question_templates ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.question_templates ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.question_templates ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.question_templates ADD CONSTRAINT question_templates_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.question_templates ADD COLUMN  name text;

ALTER TABLE dashboard_public.question_templates ADD COLUMN  question_type text;

COMMENT ON COLUMN dashboard_public.question_templates.question_type IS E'e.g., text, number, image, location';

ALTER TABLE dashboard_public.question_templates ADD COLUMN  question_prompt text;

ALTER TABLE dashboard_public.question_templates ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.question_templates ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.question_templates 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.question_templates ( created_by );

CREATE INDEX ON dashboard_public.question_templates ( updated_by );

ALTER TABLE dashboard_public.question_templates ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.question_templates ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.question_templates ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.question_templates ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.question_templates 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.question_templates ( created_at );

CREATE INDEX ON dashboard_public.question_templates ( updated_at );

ALTER TABLE dashboard_public.question_templates ADD CONSTRAINT question_templates_name_key UNIQUE ( name );

COMMENT ON CONSTRAINT question_templates_name_key ON dashboard_public.question_templates IS E'@omit';

ALTER TABLE dashboard_public.question_templates ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.question_templates TO authenticated;

GRANT SELECT ON TABLE dashboard_public.question_templates TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.question_templates TO authenticated;

GRANT DELETE ON TABLE dashboard_public.question_templates TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.question_templates FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_public.question_templates FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000100000000000000000') = '00000000000000100000000000000000') );

CREATE POLICY auth_upd ON dashboard_public.question_templates FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000100000000000000000') = '00000000000000100000000000000000') );

CREATE POLICY auth_del ON dashboard_public.question_templates FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000100000000000000000') = '00000000000000100000000000000000') );

CREATE TABLE dashboard_public.user_questions (
  
);

ALTER TABLE dashboard_public.user_questions DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.user_questions ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.user_questions ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.user_questions ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.user_questions ADD CONSTRAINT user_questions_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.user_questions ADD COLUMN  question_type text;

COMMENT ON COLUMN dashboard_public.user_questions.question_type IS E'e.g., text, number, image, location';

ALTER TABLE dashboard_public.user_questions ADD COLUMN  question_prompt text;

ALTER TABLE dashboard_public.user_questions ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.user_questions ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_questions 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.user_questions ( created_by );

CREATE INDEX ON dashboard_public.user_questions ( updated_by );

ALTER TABLE dashboard_public.user_questions ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.user_questions ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.user_questions ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.user_questions ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_questions 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.user_questions ( created_at );

CREATE INDEX ON dashboard_public.user_questions ( updated_at );

ALTER TABLE dashboard_public.user_questions ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.user_questions ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.user_questions ADD CONSTRAINT user_questions_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_questions_owner_id_fkey ON dashboard_public.user_questions IS E'@omit manyToMany';

CREATE INDEX user_questions_owner_id_idx ON dashboard_public.user_questions ( owner_id );

ALTER TABLE dashboard_public.user_questions ADD COLUMN  template_id uuid;

ALTER TABLE dashboard_public.user_questions ADD CONSTRAINT user_questions_template_id_fkey FOREIGN KEY ( template_id ) REFERENCES dashboard_public.question_templates ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_questions_template_id_fkey ON dashboard_public.user_questions IS E'@omit manyToMany';

CREATE INDEX user_questions_template_id_idx ON dashboard_public.user_questions ( template_id );

ALTER TABLE dashboard_public.user_questions ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.user_questions TO authenticated;

GRANT SELECT ON TABLE dashboard_public.user_questions TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.user_questions TO authenticated;

GRANT DELETE ON TABLE dashboard_public.user_questions TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.user_questions FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_public.user_questions FOR INSERT TO authenticated WITH CHECK ( owner_id IN (SELECT acl.actor_id FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE (acl.actor_id = owner_id AND (acl.permissions & '00000000000000100000000000000000') = '00000000000000100000000000000000')) AND owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000100000000000000000000') = '00000000000100000000000000000000')) );

CREATE POLICY auth_upd ON dashboard_public.user_questions FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000100000000000000000000') = '00000000000100000000000000000000') );

CREATE POLICY auth_del ON dashboard_public.user_questions FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000100000000000000000000') = '00000000000100000000000000000000') );

CREATE TABLE dashboard_public.user_answers (
  
);

ALTER TABLE dashboard_public.user_answers DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.user_answers ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.user_answers ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.user_answers ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.user_answers ADD CONSTRAINT user_answers_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.user_answers ADD COLUMN  user_id uuid;

ALTER TABLE dashboard_public.user_answers ALTER COLUMN user_id SET NOT NULL;

ALTER TABLE dashboard_public.user_answers ALTER COLUMN user_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_public.user_answers ADD COLUMN  location geometry(point, 4326);

ALTER TABLE dashboard_public.user_answers ADD COLUMN  text text;

ALTER TABLE dashboard_public.user_answers ADD COLUMN  numeric numeric;

ALTER TABLE dashboard_public.user_answers ADD COLUMN  image image;

ALTER TABLE dashboard_public.user_answers ADD COLUMN  data jsonb;

ALTER TABLE dashboard_public.user_answers ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.user_answers ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_answers 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.user_answers ( created_by );

CREATE INDEX ON dashboard_public.user_answers ( updated_by );

ALTER TABLE dashboard_public.user_answers ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.user_answers ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.user_answers ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.user_answers ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_answers 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.user_answers ( created_at );

CREATE INDEX ON dashboard_public.user_answers ( updated_at );

ALTER TABLE dashboard_public.user_answers ADD CONSTRAINT user_answers_user_id_fkey FOREIGN KEY ( user_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_answers_user_id_fkey ON dashboard_public.user_answers IS E'@omit manyToMany';

CREATE INDEX user_answers_user_id_idx ON dashboard_public.user_answers ( user_id );

ALTER TABLE dashboard_public.user_answers ADD COLUMN  question_id uuid;

ALTER TABLE dashboard_public.user_answers ALTER COLUMN question_id SET NOT NULL;

ALTER TABLE dashboard_public.user_answers ADD CONSTRAINT user_answers_question_id_fkey FOREIGN KEY ( question_id ) REFERENCES dashboard_public.user_questions ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_answers_question_id_fkey ON dashboard_public.user_answers IS E'@omit manyToMany';

CREATE INDEX user_answers_question_id_idx ON dashboard_public.user_answers ( question_id );

ALTER TABLE dashboard_public.user_answers ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.user_answers ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.user_answers ADD CONSTRAINT user_answers_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_answers_owner_id_fkey ON dashboard_public.user_answers IS E'@omit manyToMany';

CREATE INDEX user_answers_owner_id_idx ON dashboard_public.user_answers ( owner_id );

ALTER TABLE dashboard_public.user_answers ALTER COLUMN owner_id SET DEFAULT uuid_nil();

CREATE FUNCTION dashboard_private.user_answers_denorm_question_id (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  SELECT ref.owner_id FROM "dashboard_public".user_questions AS ref WHERE ref.id = new.question_id
  INTO new.owner_id;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_question_id 
 BEFORE INSERT ON dashboard_public.user_answers 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. user_answers_denorm_question_id (  );

CREATE TRIGGER _000000000_ensure_update_question_id 
 BEFORE UPDATE ON dashboard_public.user_answers 
 FOR EACH ROW
 WHEN ( old.question_id IS DISTINCT FROM new.question_id OR old.owner_id IS DISTINCT FROM new.owner_id ) 
 EXECUTE PROCEDURE dashboard_private. user_answers_denorm_question_id (  );

ALTER TABLE dashboard_public.user_answers ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.user_answers TO authenticated;

GRANT SELECT ON TABLE dashboard_public.user_answers TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.user_answers TO authenticated;

GRANT DELETE ON TABLE dashboard_public.user_answers TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.user_answers FOR INSERT TO authenticated WITH CHECK ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_sel ON dashboard_public.user_answers FOR SELECT TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_upd ON dashboard_public.user_answers FOR UPDATE TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_del ON dashboard_public.user_answers FOR DELETE TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_sel_admin ON dashboard_public.user_answers FOR SELECT TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000100000000000000000000') = '00000000000100000000000000000000') );

CREATE TABLE dashboard_public.action_questions (
  
);

ALTER TABLE dashboard_public.action_questions DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.action_questions ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.action_questions ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.action_questions ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.action_questions ADD CONSTRAINT action_questions_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.action_questions ADD COLUMN  question_order int;

ALTER TABLE dashboard_public.action_questions ALTER COLUMN question_order SET DEFAULT 0;

ALTER TABLE dashboard_public.action_questions ADD COLUMN  is_required bool;

ALTER TABLE dashboard_public.action_questions ALTER COLUMN is_required SET NOT NULL;

ALTER TABLE dashboard_public.action_questions ALTER COLUMN is_required SET DEFAULT TRUE;

COMMENT ON COLUMN dashboard_public.action_questions.is_required IS E'required to progress';

ALTER TABLE dashboard_public.action_questions ADD COLUMN  is_before boolean;

ALTER TABLE dashboard_public.action_questions ALTER COLUMN is_before SET NOT NULL;

ALTER TABLE dashboard_public.action_questions ALTER COLUMN is_before SET DEFAULT TRUE;

COMMENT ON COLUMN dashboard_public.action_questions.is_before IS E'prompt user before beginning action items.';

ALTER TABLE dashboard_public.action_questions ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.action_questions ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.action_questions 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.action_questions ( created_by );

CREATE INDEX ON dashboard_public.action_questions ( updated_by );

ALTER TABLE dashboard_public.action_questions ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.action_questions ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.action_questions ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.action_questions ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.action_questions 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.action_questions ( created_at );

CREATE INDEX ON dashboard_public.action_questions ( updated_at );

ALTER TABLE dashboard_public.action_questions ADD COLUMN  action_id uuid;

ALTER TABLE dashboard_public.action_questions ALTER COLUMN action_id SET NOT NULL;

ALTER TABLE dashboard_public.action_questions ADD CONSTRAINT action_questions_action_id_fkey FOREIGN KEY ( action_id ) REFERENCES dashboard_public.actions ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT action_questions_action_id_fkey ON dashboard_public.action_questions IS E'@omit manyToMany';

CREATE INDEX action_questions_action_id_idx ON dashboard_public.action_questions ( action_id );

CREATE TRIGGER action_questions_action_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.action_questions 
 FOR EACH ROW
 WHEN ( old.action_id IS DISTINCT FROM new.action_id AND old.action_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','action_id' );

ALTER TABLE dashboard_public.action_questions ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.action_questions ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.action_questions ADD CONSTRAINT action_questions_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT action_questions_owner_id_fkey ON dashboard_public.action_questions IS E'@omit manyToMany';

CREATE INDEX action_questions_owner_id_idx ON dashboard_public.action_questions ( owner_id );

CREATE TRIGGER action_questions_owner_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.action_questions 
 FOR EACH ROW
 WHEN ( old.owner_id IS DISTINCT FROM new.owner_id AND old.owner_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','owner_id' );

ALTER TABLE dashboard_public.action_questions ADD COLUMN  question_id uuid;

ALTER TABLE dashboard_public.action_questions ALTER COLUMN question_id SET NOT NULL;

ALTER TABLE dashboard_public.action_questions ADD CONSTRAINT action_questions_question_id_fkey FOREIGN KEY ( question_id ) REFERENCES dashboard_public.user_questions ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT action_questions_question_id_fkey ON dashboard_public.action_questions IS E'@omit manyToMany';

CREATE INDEX action_questions_question_id_idx ON dashboard_public.action_questions ( question_id );

CREATE TRIGGER action_questions_question_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.action_questions 
 FOR EACH ROW
 WHEN ( old.question_id IS DISTINCT FROM new.question_id AND old.question_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','question_id' );

ALTER TABLE dashboard_public.action_questions ALTER COLUMN owner_id SET DEFAULT uuid_nil();

CREATE FUNCTION dashboard_private.action_questions_denorm_action_id (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  SELECT ref.owner_id FROM "dashboard_public".actions AS ref WHERE ref.id = new.action_id
  INTO new.owner_id;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_action_id 
 BEFORE INSERT ON dashboard_public.action_questions 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. action_questions_denorm_action_id (  );

CREATE TRIGGER _000000000_ensure_update_action_id 
 BEFORE UPDATE ON dashboard_public.action_questions 
 FOR EACH ROW
 WHEN ( old.action_id IS DISTINCT FROM new.action_id OR old.owner_id IS DISTINCT FROM new.owner_id ) 
 EXECUTE PROCEDURE dashboard_private. action_questions_denorm_action_id (  );

ALTER TABLE dashboard_public.action_questions ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.action_questions TO authenticated;

GRANT SELECT ON TABLE dashboard_public.action_questions TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.action_questions TO authenticated;

GRANT DELETE ON TABLE dashboard_public.action_questions TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.action_questions FOR INSERT TO authenticated WITH CHECK ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000100000000000000000000') = '00000000000100000000000000000000') );

CREATE POLICY auth_upd ON dashboard_public.action_questions FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000100000000000000000000') = '00000000000100000000000000000000') );

CREATE POLICY auth_del ON dashboard_public.action_questions FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000100000000000000000000') = '00000000000100000000000000000000') );

CREATE POLICY auth_sel ON dashboard_public.action_questions FOR SELECT TO authenticated USING ( TRUE );

CREATE TABLE dashboard_public.onboarding_questions (
  
);

ALTER TABLE dashboard_public.onboarding_questions DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.onboarding_questions ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.onboarding_questions ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.onboarding_questions ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.onboarding_questions ADD CONSTRAINT onboarding_questions_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.onboarding_questions ADD COLUMN  question_order int;

ALTER TABLE dashboard_public.onboarding_questions ALTER COLUMN question_order SET DEFAULT 0;

ALTER TABLE dashboard_public.onboarding_questions ADD COLUMN  is_required bool;

ALTER TABLE dashboard_public.onboarding_questions ALTER COLUMN is_required SET NOT NULL;

ALTER TABLE dashboard_public.onboarding_questions ALTER COLUMN is_required SET DEFAULT TRUE;

COMMENT ON COLUMN dashboard_public.onboarding_questions.is_required IS E'required to progress';

ALTER TABLE dashboard_public.onboarding_questions ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.onboarding_questions ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.onboarding_questions 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.onboarding_questions ( created_by );

CREATE INDEX ON dashboard_public.onboarding_questions ( updated_by );

ALTER TABLE dashboard_public.onboarding_questions ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.onboarding_questions ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.onboarding_questions ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.onboarding_questions ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.onboarding_questions 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.onboarding_questions ( created_at );

CREATE INDEX ON dashboard_public.onboarding_questions ( updated_at );

ALTER TABLE dashboard_public.onboarding_questions ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.onboarding_questions ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.onboarding_questions ADD CONSTRAINT onboarding_questions_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT onboarding_questions_owner_id_fkey ON dashboard_public.onboarding_questions IS E'@omit manyToMany';

CREATE INDEX onboarding_questions_owner_id_idx ON dashboard_public.onboarding_questions ( owner_id );

CREATE TRIGGER onboarding_questions_owner_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.onboarding_questions 
 FOR EACH ROW
 WHEN ( old.owner_id IS DISTINCT FROM new.owner_id AND old.owner_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','owner_id' );

ALTER TABLE dashboard_public.onboarding_questions ADD COLUMN  question_id uuid;

ALTER TABLE dashboard_public.onboarding_questions ALTER COLUMN question_id SET NOT NULL;

ALTER TABLE dashboard_public.onboarding_questions ADD CONSTRAINT onboarding_questions_question_id_fkey FOREIGN KEY ( question_id ) REFERENCES dashboard_public.user_questions ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT onboarding_questions_question_id_fkey ON dashboard_public.onboarding_questions IS E'@omit manyToMany';

CREATE INDEX onboarding_questions_question_id_idx ON dashboard_public.onboarding_questions ( question_id );

CREATE TRIGGER onboarding_questions_question_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.onboarding_questions 
 FOR EACH ROW
 WHEN ( old.question_id IS DISTINCT FROM new.question_id AND old.question_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','question_id' );

ALTER TABLE dashboard_public.onboarding_questions ALTER COLUMN owner_id SET DEFAULT uuid_nil();

CREATE FUNCTION dashboard_private.onboarding_questions_denorm_question_id (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  SELECT ref.owner_id FROM "dashboard_public".user_questions AS ref WHERE ref.id = new.question_id
  INTO new.owner_id;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_question_id 
 BEFORE INSERT ON dashboard_public.onboarding_questions 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. onboarding_questions_denorm_question_id (  );

CREATE TRIGGER _000000000_ensure_update_question_id 
 BEFORE UPDATE ON dashboard_public.onboarding_questions 
 FOR EACH ROW
 WHEN ( old.question_id IS DISTINCT FROM new.question_id OR old.owner_id IS DISTINCT FROM new.owner_id ) 
 EXECUTE PROCEDURE dashboard_private. onboarding_questions_denorm_question_id (  );

ALTER TABLE dashboard_public.onboarding_questions ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.onboarding_questions TO authenticated;

GRANT SELECT ON TABLE dashboard_public.onboarding_questions TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.onboarding_questions TO authenticated;

GRANT DELETE ON TABLE dashboard_public.onboarding_questions TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.onboarding_questions FOR INSERT TO authenticated WITH CHECK ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000100000000000000000000') = '00000000000100000000000000000000') );

CREATE POLICY auth_upd ON dashboard_public.onboarding_questions FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000100000000000000000000') = '00000000000100000000000000000000') );

CREATE POLICY auth_del ON dashboard_public.onboarding_questions FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000100000000000000000000') = '00000000000100000000000000000000') );

CREATE POLICY auth_sel ON dashboard_public.onboarding_questions FOR SELECT TO authenticated USING ( TRUE );

CREATE TRIGGER users_insert_status_achievement_profile_picture_tg 
 BEFORE INSERT ON dashboard_public.users 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_status_private. tg_achv_tgl ( 'profile_picture','upload_profile_picture' );

CREATE TRIGGER users_update_status_achievement_profile_picture_tg 
 BEFORE UPDATE ON dashboard_public.users 
 FOR EACH ROW
 WHEN ( OLD.profile_picture IS DISTINCT FROM NEW.profile_picture ) 
 EXECUTE PROCEDURE dashboard_status_private. tg_achv_tgl ( 'profile_picture','upload_profile_picture' );

CREATE TRIGGER emails_insert_status_achievement_is_verified_tg 
 BEFORE INSERT ON dashboard_public.emails 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_status_private. tg_achv_bool ( 'is_verified','email_verified' );

CREATE TRIGGER emails_update_status_achievement_is_verified_tg 
 BEFORE UPDATE ON dashboard_public.emails 
 FOR EACH ROW
 WHEN ( OLD.is_verified IS DISTINCT FROM NEW.is_verified ) 
 EXECUTE PROCEDURE dashboard_status_private. tg_achv_bool ( 'is_verified','email_verified' );

CREATE TABLE dashboard_public.rewards (
  
);

ALTER TABLE dashboard_public.rewards DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.rewards ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.rewards ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.rewards ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.rewards ADD CONSTRAINT rewards_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.rewards ADD COLUMN  reputation_amount numeric;

ALTER TABLE dashboard_public.rewards ADD COLUMN  reward_amount numeric;

ALTER TABLE dashboard_public.rewards ADD COLUMN  reward_unit text;

ALTER TABLE dashboard_public.rewards ADD COLUMN  total_reward_limit numeric;

ALTER TABLE dashboard_public.rewards ADD COLUMN  weekly_limit numeric;

ALTER TABLE dashboard_public.rewards ADD COLUMN  daily_limit numeric;

ALTER TABLE dashboard_public.rewards ADD COLUMN  total_limit numeric;

ALTER TABLE dashboard_public.rewards ADD COLUMN  user_total_limit numeric;

ALTER TABLE dashboard_public.rewards ADD COLUMN  user_weekly_limit numeric;

ALTER TABLE dashboard_public.rewards ADD COLUMN  user_daily_limit numeric;

ALTER TABLE dashboard_public.rewards ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.rewards ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.rewards 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.rewards ( created_by );

CREATE INDEX ON dashboard_public.rewards ( updated_by );

ALTER TABLE dashboard_public.rewards ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.rewards ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.rewards ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.rewards ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.rewards 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.rewards ( created_at );

CREATE INDEX ON dashboard_public.rewards ( updated_at );

ALTER TABLE dashboard_public.rewards ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.rewards ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.rewards ADD CONSTRAINT rewards_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT rewards_owner_id_fkey ON dashboard_public.rewards IS NULL;

CREATE INDEX rewards_owner_id_idx ON dashboard_public.rewards ( owner_id );

ALTER TABLE dashboard_public.rewards ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.rewards TO authenticated;

GRANT SELECT ON TABLE dashboard_public.rewards TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.rewards TO authenticated;

GRANT DELETE ON TABLE dashboard_public.rewards TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.rewards FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins_admin ON dashboard_public.rewards FOR INSERT TO authenticated WITH CHECK ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000100000000000000000') = '00000000000000100000000000000000') );

CREATE POLICY auth_upd_admin ON dashboard_public.rewards FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000100000000000000000') = '00000000000000100000000000000000') );

CREATE POLICY auth_del_admin ON dashboard_public.rewards FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000100000000000000000') = '00000000000000100000000000000000') );

CREATE TRIGGER rewards_owner_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.rewards 
 FOR EACH ROW
 WHEN ( old.owner_id IS DISTINCT FROM new.owner_id AND old.owner_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','owner_id' );

ALTER TABLE dashboard_status_public.app_levels ADD COLUMN  reward_id uuid;

ALTER TABLE dashboard_status_public.app_levels ADD CONSTRAINT app_levels_reward_id_fkey FOREIGN KEY ( reward_id ) REFERENCES dashboard_public.rewards ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT app_levels_reward_id_fkey ON dashboard_status_public.app_levels IS NULL;

CREATE INDEX app_levels_reward_id_idx ON dashboard_status_public.app_levels ( reward_id );

ALTER TABLE dashboard_public.actions ADD COLUMN  reward_id uuid;

ALTER TABLE dashboard_public.actions ADD CONSTRAINT actions_reward_id_fkey FOREIGN KEY ( reward_id ) REFERENCES dashboard_public.rewards ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT actions_reward_id_fkey ON dashboard_public.actions IS NULL;

CREATE INDEX actions_reward_id_idx ON dashboard_public.actions ( reward_id );

ALTER TABLE dashboard_public.actions ADD COLUMN  verify_reward_id uuid;

ALTER TABLE dashboard_public.actions ADD CONSTRAINT actions_verify_reward_id_fkey FOREIGN KEY ( verify_reward_id ) REFERENCES dashboard_public.rewards ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT actions_verify_reward_id_fkey ON dashboard_public.actions IS NULL;

CREATE INDEX actions_verify_reward_id_idx ON dashboard_public.actions ( verify_reward_id );

CREATE TABLE dashboard_public.reward_payments (
  
);

ALTER TABLE dashboard_public.reward_payments DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.reward_payments ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.reward_payments ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.reward_payments ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.reward_payments ADD CONSTRAINT reward_payments_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.reward_payments ADD COLUMN  tx_id text;

ALTER TABLE dashboard_public.reward_payments ADD COLUMN  hash text;

ALTER TABLE dashboard_public.reward_payments ADD COLUMN  amount numeric;

ALTER TABLE dashboard_public.reward_payments ADD COLUMN  description text;

ALTER TABLE dashboard_public.reward_payments ADD COLUMN  ref_type text;

COMMENT ON COLUMN dashboard_public.reward_payments.ref_type IS E'if not an action, which table';

ALTER TABLE dashboard_public.reward_payments ADD COLUMN  ref_id uuid;

COMMENT ON COLUMN dashboard_public.reward_payments.ref_id IS E'if not an action, which record id in table';

ALTER TABLE dashboard_public.reward_payments ADD COLUMN  is_finalized boolean;

ALTER TABLE dashboard_public.reward_payments ALTER COLUMN is_finalized SET NOT NULL;

ALTER TABLE dashboard_public.reward_payments ALTER COLUMN is_finalized SET DEFAULT FALSE;

ALTER TABLE dashboard_public.reward_payments ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.reward_payments ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.reward_payments 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.reward_payments ( created_by );

CREATE INDEX ON dashboard_public.reward_payments ( updated_by );

ALTER TABLE dashboard_public.reward_payments ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.reward_payments ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.reward_payments ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.reward_payments ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.reward_payments 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.reward_payments ( created_at );

CREATE INDEX ON dashboard_public.reward_payments ( updated_at );

ALTER TABLE dashboard_public.reward_payments ADD COLUMN  action_id uuid;

ALTER TABLE dashboard_public.reward_payments ADD CONSTRAINT reward_payments_action_id_fkey FOREIGN KEY ( action_id ) REFERENCES dashboard_public.actions ( id );

COMMENT ON CONSTRAINT reward_payments_action_id_fkey ON dashboard_public.reward_payments IS NULL;

CREATE INDEX reward_payments_action_id_idx ON dashboard_public.reward_payments ( action_id );

ALTER TABLE dashboard_public.reward_payments ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.reward_payments ADD CONSTRAINT reward_payments_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id );

COMMENT ON CONSTRAINT reward_payments_owner_id_fkey ON dashboard_public.reward_payments IS NULL;

CREATE INDEX reward_payments_owner_id_idx ON dashboard_public.reward_payments ( owner_id );

ALTER TABLE dashboard_public.reward_payments ADD COLUMN  reward_id uuid;

ALTER TABLE dashboard_public.reward_payments ADD CONSTRAINT reward_payments_reward_id_fkey FOREIGN KEY ( reward_id ) REFERENCES dashboard_public.rewards ( id );

COMMENT ON CONSTRAINT reward_payments_reward_id_fkey ON dashboard_public.reward_payments IS NULL;

CREATE INDEX reward_payments_reward_id_idx ON dashboard_public.reward_payments ( reward_id );

ALTER TABLE dashboard_public.reward_payments ADD COLUMN  user_id uuid;

ALTER TABLE dashboard_public.reward_payments ADD CONSTRAINT reward_payments_user_id_fkey FOREIGN KEY ( user_id ) REFERENCES dashboard_public.users ( id );

COMMENT ON CONSTRAINT reward_payments_user_id_fkey ON dashboard_public.reward_payments IS NULL;

CREATE INDEX reward_payments_user_id_idx ON dashboard_public.reward_payments ( user_id );

ALTER TABLE dashboard_public.reward_payments ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.reward_payments TO authenticated;

GRANT SELECT ON TABLE dashboard_public.reward_payments TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.reward_payments TO authenticated;

GRANT DELETE ON TABLE dashboard_public.reward_payments TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.reward_payments FOR SELECT TO authenticated USING ( TRUE );

INSERT INTO dashboard_public.quantities ( id, name, label, unit, unit_desc, description ) VALUES ('04579afd-6a5a-57e7-b2dd-26d838a0342a', 'Date', 'Date', NULL, 'date', 'date'), ('e57f108e-45d9-54c5-8c06-54186136172d', 'Datetime', 'Datetime', NULL, 'datetime', 'datetime'), ('d532e57e-fdfa-533b-8c5f-cdf2f2827d67', 'Time', 'Time', NULL, 'time', 'time'), ('4e12b16f-e71c-52f5-97f7-f93c4f766b3b', 'Acceleration', 'Acceleration', 'm/s²', 'meter per square second', 'the rate of change of velocity with respect to time'), ('19dfdeec-7a3a-5779-9e14-fcddce424abb', 'AmountOfSubstance', 'Amount Of Substance', 'mol', 'mole', 'the number of elementary entities (molecules, for example) of a substance'), ('1aa3390a-db36-5eca-a448-fba1de72fb37', 'Angle', 'Angle', 'rad', 'radian', 'the figure formed by two lines diverging from a common point'), ('9380c8ea-9a54-5741-bf62-346867ba07be', 'AngularAcceleration', 'Angular Acceleration', 'rad/s²', 'radian per square second', 'the rate of change of angular velocity with respect to time'), ('737211fe-54e9-5e63-be0a-c7b03cbb0fd3', 'AngularVelocity', 'Angular Velocity', 'rad/s', 'radian per second', 'the rate of change of angular displacement with respect to time'), ('949f4b12-723e-5e81-aaf6-ed6248d9fbaa', 'Area', 'Area', 'm²', 'square meter', 'the extent of a planar region or of the surface of a solid measured in square units'), ('65439178-4a6a-5dba-b94f-3dfba6c5a370', 'CatalyticActivity', 'Catalytic Activity', 'kat', 'katal', 'a catalytic activity'), ('8b9088e4-67d0-544b-acd5-bf71bf18a504', 'DataAmount', 'Data Amount', 'bit', 'bit', 'a measure of data amount'), ('35951bef-305e-575f-bee4-5123a9e07945', 'DataRate', 'Data Rate', 'bit/s', 'bit per second', 'the speed of data-transmission'), ('c40e4f89-6131-5f6b-9782-2f7ccfa62ba1', 'Dimensionless', 'Dimensionless', '', '', 'a dimensionless quantity, can used for counting'), ('d0711ce7-62b6-5a25-a4b7-4d4adb400fb5', 'Concentration', 'Concentration', 'ppm', 'parts per million', 'a dimensionless concentration, usually of a substance'), ('2a33771c-87f1-54db-a5ae-12f80cb22081', 'Percentage', 'Percentage', '%', 'percent', 'a dimensionless number or ratio expressed as a fraction of 100'), ('b34c453b-87a0-5dfb-9bdf-07fef0938510', 'Duration', 'Duration', 's', 'second', 'a period of existence or persistence'), ('42aa76bd-909b-5bbe-a37a-29306d299cef', 'DynamicViscosity', 'Dynamic Viscosity', 'Pa·s', 'Pascal-Second', 'the dynamic viscosity'), ('763aa8a0-742b-5c31-8ca5-f618842794f4', 'ElectricCapacitance', 'Electric Capacitance', 'F', 'Farad', 'an electric capacitance'), ('834a4673-f14d-583e-b5e9-40f489e1ea56', 'ElectricCharge', 'Electric Charge', 'C', 'Coulomb', 'an electric charge'), ('be69adb5-e009-5c8d-a2ab-14c5a365db74', 'ElectricConductance', 'Electric Conductance', 'S', 'Siemens', 'an electric conductance'), ('23dcf74e-13e6-51f7-9528-c97ca6e55d3a', 'ElectricCurrent', 'Electric Current', 'A', 'Ampere', 'the amount of electric charge flowing past a specified circuit point per unit time'), ('22423730-28d4-5444-991e-53feec2f4d0e', 'ElectricInductance', 'Electric Inductance', 'H', 'Henry', 'an electric inductance'), ('d27b6f15-dcc8-5dc7-ad83-102cc1b23a53', 'ElectricPotential', 'Electric Potential', 'V', 'Volt', 'an electric potential or electromotive force'), ('57685064-16b9-5afd-9252-c1788fde84a3', 'ElectricResistance', 'Electric Resistance', 'Ω', 'Ohm', 'an electric resistance'), ('a7640aaf-5e4c-572a-94a9-468260044276', 'Energy', 'Energy', 'J', 'Joule', 'the capacity of a physical system to do work'), ('2a8726d7-dfd3-519e-80c8-6377f45740be', 'Force', 'Force', 'N', 'Newton', 'a quantity that tends to produce an acceleration of a body in the direction of its application'), ('fdca13d6-c6d5-5736-b72b-e59daba5570f', 'Frequency', 'Frequency', 'Hz', 'Hertz', 'the number of times a specified phenomenon occurs within a specified interval'), ('ba3cbc6c-37f5-5752-b4ef-9942007503eb', 'Illuminance', 'Illuminance', 'lx', 'lux', 'an illuminance'), ('8499ecf9-4527-53b1-834c-cd6260ed1555', 'KinematicViscosity', 'Kinematic Viscosity', 'm²/s', '', 'the diffusion of momentum'), ('ad7e2029-9770-5be4-9823-9f9e6063cfda', 'Length', 'Length', 'm', 'meter', 'the extent of something along its greatest dimension or the extent of space between two objects or places'), ('2cbd8cf5-2889-5f9f-a9f2-4c1323bb8757', 'LuminousFlux', 'Luminous Flux', 'lm', 'lumen', 'a luminous flux'), ('aab9d0b5-61cf-5267-bebe-680221c48b57', 'LuminousIntensity', 'Luminous Intensity', 'cd', 'candela', 'the luminous flux density per solid angle as measured in a given direction relative to the emitting source'), ('8948b53d-4a21-50de-9ea4-88f765a0fbfc', 'MagneticFlux', 'Magnetic Flux', 'Wb', 'Weber', 'a magnetic flux'), ('aa6ef888-98e4-5fc6-ab7e-159900b6278a', 'MagneticFluxDensity', 'Magnetic Flux Density', 'T', 'Tesla', 'a magnetic flux density'), ('772aa2a1-23b0-5f43-9510-d0b9f7fd26bb', 'Mass', 'Mass', 'kg', 'kilogram', 'the measure of the quantity of matter that a body or an object contains'), ('0b95e6d9-63c6-500d-90cd-5395f807396c', 'MassFlowRate', 'Mass Flow Rate', 'kg/s', 'kilogram per second', 'the movement of mass per time'), ('93c80d55-cf52-5e3e-8342-03ba6416c25a', 'Currency', 'Currency', '', '', 'something generally accepted as a medium of exchange, a measure of value, or a means of payment'), ('83100e7d-7968-532a-81bf-38d6c9afb1de', 'FuelEfficiency', 'Fuel Efficiency', 'mile/gal', 'mpg', 'the distance, measured in miles, that a car can travel per gallon of fuel'), ('a519aa01-be58-54f5-877d-aa4fdb706e60', 'Power', 'Power', 'W', 'Watt', 'the rate at which work is done'), ('d0a42857-ebf7-5420-880d-590c77a4ff75', 'Pressure', 'Pressure', 'Pa', 'Pascal', 'a force applied uniformly over a surface'), ('1922e774-28ab-5186-a10e-a5e5ae62fd5c', 'RadiationDoseAbsorbed', 'Radiation Dose Absorbed', 'Gy', 'Gray', 'the amount of energy deposited per unit of mass'), ('f3c05986-20bc-59c2-b145-d9b0d16b383d', 'RadiationDoseEffective', 'Radiation Dose Effective', 'Sv', 'Sievert', 'the effective (or "equivalent") dose of radiation received by a human or some other living organism'), ('7b4ed57d-45a6-5182-a24e-8d99d0cb31cc', 'RadioactiveActivity', 'Radioactive Activity', 'Bq', 'Becquerel', 'a radioactive activity'), ('cfe7ad3e-8dd0-5e2c-b202-7ec2a6c15cc8', 'SolidAngle', 'Solid Angle', 'sr', 'steradian', 'the angle formed by three or more planes intersecting at a common point'), ('9a4051cf-3242-5328-9d72-9687d104e9db', 'Temperature', 'Temperature', 'K', 'Kelvin', 'the degree of hotness or coldness of a body or an environment'), ('10800213-c5de-5abb-a61a-c185c2095e0c', 'Torque', 'Torque', 'N·m', 'Newton-Meter', 'the moment of a force'), ('69ba0907-347c-5705-97ee-e6c1c30c99df', 'Velocity', 'Velocity', 'm/s', 'meter per second', 'a distance traveled divided by the time of travel'), ('e7132446-2c2d-5d6a-b931-64ed0bda8a32', 'Volume', 'Volume', 'm³', 'cubic meter', 'the amount of space occupied by a three-dimensional object or region of space, expressed in cubic units'), ('27d732d7-e437-5eff-87c8-c178463174f7', 'VolumetricDensity', 'Volumetric Density', 'kg/m³', 'kilogram per cubic meter', 'a mass per unit volume of a substance under specified conditions of pressure and temperature'), ('b8c69cb1-9b13-5e43-954d-bc6db121dc1d', 'VolumetricFlowRate', 'Volumetric Flow Rate', 'm³/s', 'cubic meter per second', 'the volume of fluid passing a point in a system per unit of time');

INSERT INTO dashboard_public.units ( id, name, value, amount, quantity_id ) VALUES ('218694ca-55f8-5399-894c-22dbff0b59df', 'person', 'dimensionless', NULL, 'c40e4f89-6131-5f6b-9782-2f7ccfa62ba1'), ('dd5e5964-9353-5d08-ad2b-853ab5e2523d', 'count', 'dimensionless', NULL, 'c40e4f89-6131-5f6b-9782-2f7ccfa62ba1'), ('d498c500-35dd-592b-a3f3-b7e95b3633c6', 'dimensionless', '!dimensionless', NULL, 'c40e4f89-6131-5f6b-9782-2f7ccfa62ba1'), ('075c0354-b0a1-5c0c-8be1-8f74cd1f2dfa', 'sqft', 'ft^2', NULL, '949f4b12-723e-5e81-aaf6-ed6248d9fbaa'), ('dac9c0d5-8c1d-5f07-9138-93c132622fdc', 'kWh', 'Wh', '1000', 'a7640aaf-5e4c-572a-94a9-468260044276'), ('8e4cdd8b-210a-59c2-a611-10eb1ad13902', 'kg', '!', NULL, '772aa2a1-23b0-5f43-9510-d0b9f7fd26bb'), ('4c4130a0-3c70-5841-b075-e68e3972174a', 'kilogram', 'kg', NULL, '772aa2a1-23b0-5f43-9510-d0b9f7fd26bb'), ('2334f437-8dc3-539e-a50b-b1891e8c3341', 's', '!', NULL, 'b34c453b-87a0-5dfb-9bdf-07fef0938510'), ('1ec36597-a5b3-5ab0-8df5-811913434019', 'second', 's', NULL, 'b34c453b-87a0-5dfb-9bdf-07fef0938510'), ('570bd742-ff5c-5101-854b-447885adae36', 'm', '!', NULL, 'ad7e2029-9770-5be4-9823-9f9e6063cfda'), ('ffdf1a37-fc42-5c7a-b82e-c8d765e2002f', 'meter', 'm', NULL, 'ad7e2029-9770-5be4-9823-9f9e6063cfda'), ('f07f1719-0bdb-54f6-a765-5381c73cd770', 'A', '!', NULL, '23dcf74e-13e6-51f7-9528-c97ca6e55d3a'), ('090661af-b09b-5ead-9516-8d3017a4bdc7', 'ampere', 'A', NULL, '23dcf74e-13e6-51f7-9528-c97ca6e55d3a'), ('90663b63-9efc-5e1a-85bb-7a8fd8882c7e', 'amp', 'ampere', NULL, '23dcf74e-13e6-51f7-9528-c97ca6e55d3a'), ('7e9b477c-a4f8-5e8a-adb6-518166520874', 'cd', '!', NULL, 'aab9d0b5-61cf-5267-bebe-680221c48b57'), ('056d46ff-c222-5fc3-9c8d-0b6316b21d9d', 'candela', 'cd', NULL, 'aab9d0b5-61cf-5267-bebe-680221c48b57'), ('de42f66e-5d63-5b37-9574-4837f6ffdcef', 'mol', '!', NULL, '19dfdeec-7a3a-5779-9e14-fcddce424abb'), ('080ecddf-9fef-576a-85c6-92bef3f190ef', 'mole', 'mol', NULL, '19dfdeec-7a3a-5779-9e14-fcddce424abb'), ('bd4b2d73-1b7f-54c3-9dfa-7e79b9800413', 'K', '!', NULL, '9a4051cf-3242-5328-9d72-9687d104e9db'), ('31abd5da-7343-56da-bfcc-5e2e3ec1184b', 'kelvin', 'K', NULL, '9a4051cf-3242-5328-9d72-9687d104e9db'), ('a6a869a6-bbf2-5f9c-8501-f7a3e2ce53af', 'radian', '!dimensionless', NULL, '1aa3390a-db36-5eca-a448-fba1de72fb37'), ('79aa428e-5c55-5cca-82d8-b3fec9b179ed', 'sr', '!dimensionless', NULL, 'cfe7ad3e-8dd0-5e2c-b202-7ec2a6c15cc8'), ('50537e09-1c48-573c-bb17-2828a266bb3d', 'steradian', 'sr', NULL, 'cfe7ad3e-8dd0-5e2c-b202-7ec2a6c15cc8'), ('9f138334-af2e-5405-86fd-76c603c420de', 'B', '!', NULL, '8b9088e4-67d0-544b-acd5-bf71bf18a504'), ('c0df108a-42d0-56bd-b247-6b9819b97c46', 'byte', 'B', NULL, '8b9088e4-67d0-544b-acd5-bf71bf18a504'), ('779c8a74-fdcd-5dca-a060-f852900dda9b', 'bit', 'B', '1|8', '8b9088e4-67d0-544b-acd5-bf71bf18a504'), ('127215cb-17f3-5448-a25e-db70c961b4f1', 'yard', 'ft', '3', 'ad7e2029-9770-5be4-9823-9f9e6063cfda'), ('4e923a3c-2651-5feb-9bd9-9a911c359c6a', 'yd', 'yard', NULL, 'ad7e2029-9770-5be4-9823-9f9e6063cfda'), ('a4dbdf74-14b0-5e87-9d35-f41f5691537f', 'mile', 'ft', '5280', 'ad7e2029-9770-5be4-9823-9f9e6063cfda'), ('214ec785-e91d-5a86-8617-17121c0fcc60', 'league', 'mile', '3', 'ad7e2029-9770-5be4-9823-9f9e6063cfda'), ('24cf411e-c244-5533-9f7d-af8ce5137f29', 'USacre', 'surveychain^2', '10', '949f4b12-723e-5e81-aaf6-ed6248d9fbaa'), ('59724f76-1ada-58b6-bd1b-8b4312b61c48', 'acre', 'intacre', NULL, '949f4b12-723e-5e81-aaf6-ed6248d9fbaa'), ('0f1f6b37-08ab-500e-a14f-d0d2278be0cc', 'fathom', 'ft', '6', 'ad7e2029-9770-5be4-9823-9f9e6063cfda'), ('6f9329a2-99bf-5128-b628-78d56457a911', 'nauticalmile', 'm', '1852', 'ad7e2029-9770-5be4-9823-9f9e6063cfda'), ('1276cdcd-d74e-57ef-8279-fe36ab14dfa0', 'pound', 'kg', '0.45359237', '772aa2a1-23b0-5f43-9510-d0b9f7fd26bb'), ('9c028075-1de2-58a3-bf7c-34da90059473', 'lb', 'pound', NULL, '772aa2a1-23b0-5f43-9510-d0b9f7fd26bb'), ('230c2153-2683-5ca3-9f84-bc0de0108ad1', 'ounce', 'pound', '1|16', '772aa2a1-23b0-5f43-9510-d0b9f7fd26bb'), ('4f607183-3926-5f57-b72d-32fa56fbad9d', 'oz', 'ounce', NULL, '772aa2a1-23b0-5f43-9510-d0b9f7fd26bb'), ('61fa743c-e18d-5383-b33d-967abd65efea', 'carat', 'metriccarat', NULL, '772aa2a1-23b0-5f43-9510-d0b9f7fd26bb'), ('135cac7c-2f81-5e2a-9bd5-1994ac569d80', 'ct', 'carat', NULL, '772aa2a1-23b0-5f43-9510-d0b9f7fd26bb'), ('a521a475-e431-5511-b07a-b559073ad847', 'usgallon', 'in^3', '231', 'e7132446-2c2d-5d6a-b931-64ed0bda8a32'), ('792ac897-8915-50d6-ae5f-554d3f441c77', 'gallon', 'usgallon', NULL, 'e7132446-2c2d-5d6a-b931-64ed0bda8a32'), ('43a051a5-789a-54ad-b87b-787a19423f76', 'gal', 'gallon', NULL, 'e7132446-2c2d-5d6a-b931-64ed0bda8a32'), ('2110b7c6-aad5-57da-a956-034770b5bce9', 'quart', 'gallon', '1|4', 'e7132446-2c2d-5d6a-b931-64ed0bda8a32'), ('fdac3bab-e8fd-56d2-860f-f1e189835d9d', 'pint', 'quart', '1|2', 'e7132446-2c2d-5d6a-b931-64ed0bda8a32'), ('a52f53de-db3c-5265-9008-435f7cd1a498', 'qt', 'quart', NULL, 'e7132446-2c2d-5d6a-b931-64ed0bda8a32'), ('56f4292d-1448-5760-82a2-03b90116068a', 'pt', 'pint', NULL, 'e7132446-2c2d-5d6a-b931-64ed0bda8a32'), ('a9ad1d74-abcf-5d29-90dd-5d4583cfe886', 'year', 'tropicalyear', NULL, 'b34c453b-87a0-5dfb-9bdf-07fef0938510'), ('b3c21f9d-881c-5d85-92da-28b9f8a250fb', 'yr', 'year', NULL, 'b34c453b-87a0-5dfb-9bdf-07fef0938510'), ('4a2ed594-f1b5-5ba5-803b-e11cd9e656ea', 'month', 'year', '1|12', 'b34c453b-87a0-5dfb-9bdf-07fef0938510'), ('5b5e8876-2703-5a6f-aa04-84f9cfac94d8', 'decade', 'years', '10', 'b34c453b-87a0-5dfb-9bdf-07fef0938510'), ('d38c1139-1129-5614-aa20-90101a3caba5', 'century', 'years', '100', 'b34c453b-87a0-5dfb-9bdf-07fef0938510'), ('444345ee-caaa-5909-a127-cd712857fa91', 'millennium', 'years', '1000', 'b34c453b-87a0-5dfb-9bdf-07fef0938510'), ('35b16448-bc1e-5263-8c81-658c032a1d25', 'calendaryear', 'day', '365', 'b34c453b-87a0-5dfb-9bdf-07fef0938510'), ('13c548a1-f27d-58c8-8f55-db7bbce79459', 'leapyear', 'day', '366', 'b34c453b-87a0-5dfb-9bdf-07fef0938510'), ('20ac262c-d407-5d91-b3e6-0c2a7978becf', 'lumen', 'sr', 'cd', '2cbd8cf5-2889-5f9f-a9f2-4c1323bb8757'), ('53a32d5b-981d-5b31-bbed-9d969e650080', 'lm', 'lumen', NULL, '2cbd8cf5-2889-5f9f-a9f2-4c1323bb8757'), ('7678f447-3363-57aa-b715-36bfba5ddab0', 'inch', 'cm', '2.54', 'ad7e2029-9770-5be4-9823-9f9e6063cfda'), ('d068def1-1dac-5209-a838-62fcbbddb1ee', 'in', 'inch', NULL, 'ad7e2029-9770-5be4-9823-9f9e6063cfda'), ('97813e8a-818d-5564-b7eb-96da1315a5c6', 'foot', 'inch', '12', 'ad7e2029-9770-5be4-9823-9f9e6063cfda'), ('f10c4538-a9a1-59a3-b2eb-144fbc71014a', 'feet', 'foot', NULL, 'ad7e2029-9770-5be4-9823-9f9e6063cfda'), ('1e01bb1d-72a4-5df7-be08-c1d673c03304', 'ft', 'foot', NULL, 'ad7e2029-9770-5be4-9823-9f9e6063cfda'), ('4902fe81-3cb0-5da1-b303-67432129b208', 'N', 'newton', NULL, '2a8726d7-dfd3-519e-80c8-6377f45740be'), ('a7099818-456c-5e97-863a-2f9aa2e7d5ba', 'pascal', 'N/m^2', NULL, 'd0a42857-ebf7-5420-880d-590c77a4ff75'), ('c7cc266b-4ae9-5b38-9242-81e6063de908', 'Pa', 'pascal', NULL, 'd0a42857-ebf7-5420-880d-590c77a4ff75'), ('cc3a0147-cf3c-5b2c-8e50-c9c12113273d', 'joule', 'm', 'N', 'a7640aaf-5e4c-572a-94a9-468260044276'), ('69339523-7438-5248-a1a1-be1395c545a2', 'J', 'joule', NULL, 'a7640aaf-5e4c-572a-94a9-468260044276'), ('c7cb284b-eacb-5f24-91f0-30c533a11df5', 'watt', 'J/s', NULL, 'a519aa01-be58-54f5-877d-aa4fdb706e60'), ('156fe5c9-2ead-5699-b116-401029b502c9', 'W', 'watt', NULL, 'a519aa01-be58-54f5-877d-aa4fdb706e60'), ('52242111-218a-53fa-8122-a4566f506079', 'coulomb', 's', 'A', '834a4673-f14d-583e-b5e9-40f489e1ea56'), ('775676ff-69ac-5fe3-9a2a-476b83f854f7', 'C', 'coulomb', NULL, '834a4673-f14d-583e-b5e9-40f489e1ea56'), ('e78f37c5-98dc-57da-9a3e-acb67abbb32f', 'volt', 'W/A', NULL, 'd27b6f15-dcc8-5dc7-ad83-102cc1b23a53'), ('4987e781-d058-5434-80dc-aad6e78cab67', 'V', 'volt', NULL, '834a4673-f14d-583e-b5e9-40f489e1ea56'), ('781be428-676f-5ac8-ab8a-c05ed64b10a2', 'ohm', 'V/A', NULL, '57685064-16b9-5afd-9252-c1788fde84a3'), ('d91524fc-41f8-5c2f-ad1f-f418571f9757', 'siemens', 'A/V', NULL, 'be69adb5-e009-5c8d-a2ab-14c5a365db74'), ('d10c24d3-a57f-5a59-bedd-aa01670a5cf1', 'S', 'siemens', NULL, 'be69adb5-e009-5c8d-a2ab-14c5a365db74'), ('435ca759-695d-5c4c-8837-ae91bc1b518b', 'farad', 'C/V', NULL, '763aa8a0-742b-5c31-8ca5-f618842794f4'), ('86f36a3f-a5bb-5735-b126-c2fd577e9968', 'F', 'farad', NULL, '763aa8a0-742b-5c31-8ca5-f618842794f4'), ('ee953efe-6d71-58c9-97ee-28d47ce2ed3d', 'weber', 's', 'V', '8948b53d-4a21-50de-9ea4-88f765a0fbfc'), ('e38c2d76-bcc2-5f0a-9d1f-89b0824947a8', 'Wb', 'weber', NULL, '8948b53d-4a21-50de-9ea4-88f765a0fbfc'), ('e51d0a5c-309d-5efe-b2e5-bcfc1eeb539c', 'H', 'henry', NULL, '22423730-28d4-5444-991e-53feec2f4d0e'), ('be27bf4a-8a5e-5463-afa0-1d41c2236c5e', 'tesla', 'Wb/m^2', NULL, 'aa6ef888-98e4-5fc6-ab7e-159900b6278a'), ('f7be9821-524e-5da6-8aff-424d51bca60b', 'T', 'tesla', NULL, 'aa6ef888-98e4-5fc6-ab7e-159900b6278a'), ('64f48c1c-ef2a-5996-b5ff-50021b5e0000', 'hertz', '/s', NULL, 'fdca13d6-c6d5-5736-b72b-e59daba5570f'), ('71f8a361-c915-56b5-8b85-18fe001c14e1', 'Hz', 'hertz', NULL, 'fdca13d6-c6d5-5736-b72b-e59daba5570f'), ('4febcc1d-dedd-5eca-bf1c-7251637e28d9', 'gram', 'millikg', NULL, '772aa2a1-23b0-5f43-9510-d0b9f7fd26bb'), ('62d219dd-a242-5b3c-b411-db4ffddd59a7', 'gm', 'gram', NULL, '772aa2a1-23b0-5f43-9510-d0b9f7fd26bb'), ('1efc6bb9-fde4-5060-be20-e045207e390a', 'g', 'gram', NULL, '772aa2a1-23b0-5f43-9510-d0b9f7fd26bb'), ('ae591316-d5fc-5281-bf58-9a387c6c884f', 'tonne', 'kg', '1000', '772aa2a1-23b0-5f43-9510-d0b9f7fd26bb'), ('83280e40-de61-5c1b-8540-f859438a0ab7', 't', 'tonne', NULL, '772aa2a1-23b0-5f43-9510-d0b9f7fd26bb'), ('b5e66823-4e1c-5e72-8256-f8372515fcbe', 'metricton', 'tonne', NULL, '772aa2a1-23b0-5f43-9510-d0b9f7fd26bb'), ('d7cff018-88e1-51ef-91ee-51145237fb25', 'liter', 'cc', '1000', 'e7132446-2c2d-5d6a-b931-64ed0bda8a32'), ('5935433d-e66b-5eee-930f-28c9aff4100d', 'L', 'liter', NULL, 'e7132446-2c2d-5d6a-b931-64ed0bda8a32'), ('705956a6-1607-52aa-a4f5-feaecc2d6902', 'l', 'liter', NULL, 'e7132446-2c2d-5d6a-b931-64ed0bda8a32'), ('c2c89474-0b46-5b2b-ac8d-85c1ec6014f5', 'sec', 's', NULL, 'b34c453b-87a0-5dfb-9bdf-07fef0938510'), ('dd6f6b67-c46e-5486-9291-a20d462c9f27', 'minute', 's', '60', 'b34c453b-87a0-5dfb-9bdf-07fef0938510'), ('6bf66def-094d-5eae-8da9-be06e7a8dd38', 'min', 'minute', NULL, 'b34c453b-87a0-5dfb-9bdf-07fef0938510'), ('eea55df4-5278-50c7-a56a-55c99cc98831', 'hour', 'min', '60', 'b34c453b-87a0-5dfb-9bdf-07fef0938510'), ('a25bd5a9-799f-5bde-8498-ba28101f5eff', 'h', 'hour', NULL, 'b34c453b-87a0-5dfb-9bdf-07fef0938510'), ('50d28f9f-5ad2-5719-8456-64a652874e94', 'hr', 'hour', NULL, 'b34c453b-87a0-5dfb-9bdf-07fef0938510'), ('013ef439-3851-58a5-a3de-14a438d3c9c3', 'day', 'hr', '24', 'b34c453b-87a0-5dfb-9bdf-07fef0938510'), ('b3dc9ff0-110b-5cbd-8813-1e3fb9c855e0', 'd', 'day', NULL, 'b34c453b-87a0-5dfb-9bdf-07fef0938510'), ('5fb86bc4-0d34-5bd4-9076-0f2f34040f96', 'week', 'day', '7', 'b34c453b-87a0-5dfb-9bdf-07fef0938510'), ('e24d6883-df7e-567c-9860-2decbc3b1ac2', 'wk', 'week', NULL, 'b34c453b-87a0-5dfb-9bdf-07fef0938510'), ('d4e4b714-6262-5592-92a3-a0c6b7a085fa', 'degcelsius', 'K', NULL, '9a4051cf-3242-5328-9d72-9687d104e9db'), ('5a0b4184-355d-5acb-bb9a-72ce69e77da9', 'degC', 'K', NULL, '9a4051cf-3242-5328-9d72-9687d104e9db'), ('e6d5c80d-c12c-517b-9f31-fc2288f645a9', 'degF', 'degF', NULL, '9a4051cf-3242-5328-9d72-9687d104e9db'), ('0d8e1d44-4aa1-55c2-9884-1075476d0848', 'degK', 'K', NULL, '9a4051cf-3242-5328-9d72-9687d104e9db'), ('f960fd07-61b3-5e2d-bf34-f7215ff45272', 'degree', 'circle', '1|360', '1aa3390a-db36-5eca-a448-fba1de72fb37'), ('cc3db469-d0a5-598c-a5d0-41c0a6c85856', 'turn', 'circle', NULL, '1aa3390a-db36-5eca-a448-fba1de72fb37'), ('5c8e3616-7166-5e57-ae7a-3b8be8649634', 'revolution', 'turn', NULL, '1aa3390a-db36-5eca-a448-fba1de72fb37'), ('49deab4a-c70f-57e1-8f79-6034f995f33d', 'rev', 'turn', NULL, '1aa3390a-db36-5eca-a448-fba1de72fb37'), ('4157d80e-79ca-5fa0-b7a1-6ca3755ad8c1', 'percent', '0.01', NULL, '2a33771c-87f1-54db-a5ae-12f80cb22081'), ('5171206c-bc8e-5a5f-b8da-0484c2a094be', '%', 'percent', NULL, '2a33771c-87f1-54db-a5ae-12f80cb22081'), ('451b79f1-2a41-51da-ba86-5346f0ba5913', 'ppm', '0.000001', NULL, 'd0711ce7-62b6-5a25-a4b7-4d4adb400fb5'), ('41b70c35-12aa-52e6-ab55-5cad4a036afb', 'ppb', '0.000000001', NULL, 'd0711ce7-62b6-5a25-a4b7-4d4adb400fb5'), ('770c51aa-d39d-5390-808b-e0baff3f8859', 'ppt', '0.000000000001', NULL, 'd0711ce7-62b6-5a25-a4b7-4d4adb400fb5'), ('2a730089-fcd0-554b-92df-33d4399c14f2', 'tbsp', 'tablespoon', NULL, 'e7132446-2c2d-5d6a-b931-64ed0bda8a32'), ('52bd39f3-b767-5676-9d12-1133f53dc4a0', 'tsp', 'teaspoon', NULL, 'e7132446-2c2d-5d6a-b931-64ed0bda8a32'), ('577dd129-fef2-50d8-a2c4-b0290d820811', 'uscup', 'usfloz', '8', 'e7132446-2c2d-5d6a-b931-64ed0bda8a32'), ('6f74f09d-cc9d-51d8-8287-b6a632fa2cbb', 'ustablespoon', 'uscup', '1|16', 'e7132446-2c2d-5d6a-b931-64ed0bda8a32'), ('4e9dc4c5-16ad-5810-8b72-a55c7db70e06', 'usteaspoon', 'ustablespoon', '1|3', 'e7132446-2c2d-5d6a-b931-64ed0bda8a32'), ('afa146fa-9292-5795-a063-3c3a37c34224', 'calorie', 'cal_th', NULL, 'a7640aaf-5e4c-572a-94a9-468260044276'), ('ebaf1064-46d7-5640-a1d1-db20305a658a', 'thermcalorie', 'calorie_th', NULL, 'a7640aaf-5e4c-572a-94a9-468260044276'), ('bb9092bd-ba49-5511-a226-b3c76d4eacd2', 'Calorie', 'kilocalorie', NULL, 'a7640aaf-5e4c-572a-94a9-468260044276'), ('09750330-3eed-5be6-bc9f-b5bccced2fd9', '$', 'dollar', NULL, '93c80d55-cf52-5e3e-8342-03ba6416c25a'), ('f42877cc-baa8-5b6c-a5cf-6ac3fbabcc78', 'satoshi', 'bitcoin', '0.00000001', '93c80d55-cf52-5e3e-8342-03ba6416c25a'), ('a51dd410-1905-5987-a0a1-87f5f6506899', 'BTC', 'bitcoin', NULL, '93c80d55-cf52-5e3e-8342-03ba6416c25a'), ('86c5912b-389d-5518-9017-50a5c846e23f', 'hectare', 'hectoare', NULL, '949f4b12-723e-5e81-aaf6-ed6248d9fbaa'), ('bcec0330-0ee2-5cf5-a320-e1cc7a973045', 'mph', 'mile/hr', NULL, '69ba0907-347c-5705-97ee-e6c1c30c99df'), ('678dc535-0693-53f4-8fe4-76e0e1baa3d3', 'mpg', 'mile/gal', NULL, '83100e7d-7968-532a-81bf-38d6c9afb1de'), ('0920b764-29ea-5f6a-a333-49c681184a0a', 'kph', 'km/hr', NULL, '69ba0907-347c-5705-97ee-e6c1c30c99df'), ('0e571c07-0fcb-54bc-8f45-90b6a75428d0', 'mi', 'mile', NULL, 'ad7e2029-9770-5be4-9823-9f9e6063cfda'), ('ecd0caa1-4a6b-5299-826f-62750a2140e1', '°C', 'degC', NULL, '9a4051cf-3242-5328-9d72-9687d104e9db'), ('4bb4ccd3-897a-5f65-97fd-ac1f601bf73b', '°F', 'degF', NULL, '9a4051cf-3242-5328-9d72-9687d104e9db'), ('f66ad688-86c0-5969-8101-2243f304841c', '°K', 'K', NULL, '9a4051cf-3242-5328-9d72-9687d104e9db'), ('2718e664-c0bf-507c-80a8-2b8e4a697869', '°', 'degree', NULL, '1aa3390a-db36-5eca-a448-fba1de72fb37'), ('f8652a5f-8f89-59be-9d53-1f958224ba36', '℃', 'degC', NULL, '9a4051cf-3242-5328-9d72-9687d104e9db'), ('83c58849-92ae-5219-8327-3b0128d368c6', '℉', 'degF', NULL, '9a4051cf-3242-5328-9d72-9687d104e9db'), ('f6f8b5fa-cb95-5c47-b645-47e168389768', 'K', 'K', NULL, '9a4051cf-3242-5328-9d72-9687d104e9db'), ('d1a0bc85-f15b-55d0-becb-9afc803250fe', 'ℓ', 'liter', NULL, 'e7132446-2c2d-5d6a-b931-64ed0bda8a32');

INSERT INTO dashboard_public.object_types ( id, name, quantity_id ) VALUES ('3b71372f-777a-5d81-ac75-7ab1616c30d5', 'Tree', 'c40e4f89-6131-5f6b-9782-2f7ccfa62ba1'), ('183837e6-5ffa-5ac8-9d51-9f1b85d629c5', 'Car', 'c40e4f89-6131-5f6b-9782-2f7ccfa62ba1'), ('a0306812-62fa-5535-b34f-ed40770d2b1b', 'Water', 'e7132446-2c2d-5d6a-b931-64ed0bda8a32'), ('963b2e9b-f7e0-5a97-ab48-17ee22d4a1eb', 'Solar Panel', '949f4b12-723e-5e81-aaf6-ed6248d9fbaa'), ('50b89798-695e-555c-8193-c377ffaea766', 'Drop-A-Brick', 'c40e4f89-6131-5f6b-9782-2f7ccfa62ba1'), ('910b019b-85c0-561c-a208-69fbee5384ce', 'CO2', '772aa2a1-23b0-5f43-9510-d0b9f7fd26bb'), ('a50c7b50-0f9d-5cc3-afc1-96a0288637f6', 'Soil', '772aa2a1-23b0-5f43-9510-d0b9f7fd26bb'), ('634e09b2-2c30-53d3-94ad-f4c55e904077', 'Garden', '949f4b12-723e-5e81-aaf6-ed6248d9fbaa'), ('e0ab12ef-cb03-5f24-8090-ffaf9edbdf4e', 'Farm', '949f4b12-723e-5e81-aaf6-ed6248d9fbaa');

INSERT INTO dashboard_public.object_type_attributes ( id, object_type_id, name, type, label, attr_order, is_required, min, unit_id, quantity_id ) VALUES ('393ff77f-40d3-55de-93db-0a53969b400b', '3b71372f-777a-5d81-ac75-7ab1616c30d5', 'Species', 'text', 'Species', 1, FALSE, NULL, NULL, NULL), ('b50b96e3-90c0-5fe7-91d5-ae7cc759a8d3', 'e0ab12ef-cb03-5f24-8090-ffaf9edbdf4e', 'Area', 'numeric', 'Area', 1, FALSE, NULL, '59724f76-1ada-58b6-bd1b-8b4312b61c48', '949f4b12-723e-5e81-aaf6-ed6248d9fbaa'), ('41f9bdf8-74eb-5941-bc8f-e38ecdea2ac9', '183837e6-5ffa-5ac8-9d51-9f1b85d629c5', 'Make', 'text', 'Make', 1, FALSE, NULL, NULL, NULL), ('01f55b9a-dd35-54ab-9b7f-e83b5b3f9e7a', '183837e6-5ffa-5ac8-9d51-9f1b85d629c5', 'Year', 'numeric', 'Year', 1, FALSE, NULL, 'a9ad1d74-abcf-5d29-90dd-5d4583cfe886', '04579afd-6a5a-57e7-b2dd-26d838a0342a');

INSERT INTO dashboard_public.object_type_values ( attr_id, name, description, text, photo, value_order ) VALUES ('393ff77f-40d3-55de-93db-0a53969b400b', 'African Sumac', 'Drought tolerant evergreen offering dense shade, elegant arching branches and subtle flowers in summer. Can live 150 years.', 'African Sumac', '{"url": "https://dl.airtable.com/.attachments/52988b5e03a3181688f90ae49b6a5d0c/dce167c2/SelecTree-Rhus_lancea2.jpg", "mime": "image/jpeg", "size": 102042, "filename": "SelecTree-Rhus_lancea2.jpg"}'::jsonb, 0), ('393ff77f-40d3-55de-93db-0a53969b400b', 'Bronze Loquat', 'From Taiwan and Southern Vietnam, it has shiny bronze and green foliage with white flowers in the spring. Moderate water needs. Grows to 25 ft.', 'Bronze Loquat', '{"url": "https://dl.airtable.com/.attachments/d293abd1e9a9f62b67a318924d73aa2d/7f9ef93f/SelecTree-Eriobotrya_deflexa.jpg", "mime": "image/jpeg", "size": 75406, "filename": "SelecTree-Eriobotrya_deflexa.jpg"}'::jsonb, 0), ('393ff77f-40d3-55de-93db-0a53969b400b', 'Crape Myrtle', 'Native to China, with beautiful lavender, pink, red, rose or white flowers in summer. Blooms best in full sun, when it has moderate moisture. Drought tolerant.', 'Crape Myrtle', '{"url": "https://dl.airtable.com/.attachments/23be9677d36c9590be04ee5ef4dcd9e5/efb46585/SelecTree-Lagerstroemia_indica.jpg", "mime": "image/jpeg", "size": 221127, "filename": "SelecTree-Lagerstroemia_indica.jpg"}'::jsonb, 0), ('393ff77f-40d3-55de-93db-0a53969b400b', 'Eastern Redbud', 'Gorgeous pink or rose flowers bloom in spring and its heart shaped leaves turn lemon colored in the fall. This drought tolerant tree is native to the eastern United States.', 'Eastern Redbud', '{"url": "https://dl.airtable.com/.attachments/1a35ea4dc7a3ac2c310e18a1530a0082/6f31c7a2/SelecTree-Cercis_canadensis.jpg", "mime": "image/jpeg", "size": 276088, "filename": "SelecTree-Cercis_canadensis.jpg"}'::jsonb, 0), ('393ff77f-40d3-55de-93db-0a53969b400b', 'Fraser Photinia', 'Shiny reddish evergreen foliage with fragrant white flowers in the spring. This small drought tolerant tree fits perfectly under power lines. Native to Asia.', 'Fraser Photinia', '{"url": "https://dl.airtable.com/.attachments/0de5a63837512c585327bcaca71535a3/2740fd75/photinia--fraseri-tree.jpg", "mime": "image/jpeg", "size": 604321, "filename": "photinia-×-fraseri-tree.jpg"}'::jsonb, 0), ('393ff77f-40d3-55de-93db-0a53969b400b', 'Gold Medallion Tree', 'Elegant low arching canopy with cheerful yellow flowers in the summer. Moderate water needs. Native to Brazil.', 'Gold Medallion Tree', '{"url": "https://dl.airtable.com/.attachments/39b05049e93e041bb6aec07c49c7c429/ac4ae92f/cassia-leptophylla-tree-flowering.jpg", "mime": "image/jpeg", "size": 433441, "filename": "cassia-leptophylla-tree-flowering.jpg"}'::jsonb, 0), ('393ff77f-40d3-55de-93db-0a53969b400b', 'Purple Orchid Tree', 'Drought tolerant tree hailing from India and China. Fragrant lavender or pink flowers in spring or winter decorate a low arching canopy.', 'Purple Orchid Tree', '{"url": "https://dl.airtable.com/.attachments/9e04cbc13f5449e0207578609903286d/8971bbd6/SelecTree-Bauhinia_variegata.jpg", "mime": "image/jpeg", "size": 111012, "filename": "SelecTree-Bauhinia_variegata.jpg"}'::jsonb, 0), ('393ff77f-40d3-55de-93db-0a53969b400b', 'Australian Willow', 'Drought tolerant 35 foot tree with inconspicuous white flowers in either spring or fall.', 'Australian Willow', '{"url": "https://dl.airtable.com/.attachments/cc5dcab39df8dc890761f3f1771cf747/72866dd8/SelecTree-Geijera_parviflora2.jpg", "mime": "image/jpeg", "size": 208099, "filename": "SelecTree-Geijera_parviflora2.jpg"}'::jsonb, 0), ('393ff77f-40d3-55de-93db-0a53969b400b', 'Carolina Laurel Cherry', 'Drought tolerant wide canopy tree native to Southeastern United States with fragrant white flowers in spring or winter.', 'Carolina Laurel Cherry', '{"url": "https://dl.airtable.com/.attachments/89577fa7d66c3bff45ad1fb43adb9ddd/279ed8c0/prunus-caroliniana-tree-2.jpg", "mime": "image/jpeg", "size": 682400, "filename": "prunus-caroliniana-tree-2.jpg"}'::jsonb, 0), ('393ff77f-40d3-55de-93db-0a53969b400b', 'Chinese Flame Tree', 'Cheerful yellow flowers in summer or fall, native to Asia, and drought tolerant.', 'Chinese Flame Tree', '{"url": "https://dl.airtable.com/.attachments/e56dcac3ddf0aff7a5e9f52cf20cca80/3144aeef/SelecTree-Koelreuteria_bipinnata.jpg", "mime": "image/jpeg", "size": 113517, "filename": "SelecTree-Koelreuteria_bipinnata.jpg"}'::jsonb, 0), ('393ff77f-40d3-55de-93db-0a53969b400b', 'Chinese Pistache', 'Fragrant leaves with flowers in spring. Medium green, red, gold, orange or multicolored in fall. Offers fairly dense shade.', 'Chinese Pistache', '{"url": "https://dl.airtable.com/.attachments/924b0a39e97a7a74d3f0fa25ac96e7a8/4abbfb38/SelecTree-Pistacia_chinensis.jpg", "mime": "image/jpeg", "size": 193005, "filename": "SelecTree-Pistacia_chinensis.jpg"}'::jsonb, 0), ('393ff77f-40d3-55de-93db-0a53969b400b', 'Mesquite', 'Drought tolerant wide canopy tree with fragrant yellow flowers in the spring. Native to Southwestern United States and Northern Mexico.', 'Mesquite', '{"url": "https://dl.airtable.com/.attachments/24aecf43bb3339fab900efe7d8cac85a/c7f221ea/prosopis-glandulosa-torreyana-tree-flowering.jpg", "mime": "image/jpeg", "size": 442813, "filename": "prosopis-glandulosa-torreyana-tree-flowering.jpg"}'::jsonb, 0), ('393ff77f-40d3-55de-93db-0a53969b400b', 'Olive Tree', 'Native to the Mediterranean Region, this olive tree bears fruit in the fall and small fragrant flowers in spring. It is drought and heat tolerant, with a longevity greater than 150 years.', 'Olive Tree', '{"url": "https://dl.airtable.com/.attachments/cfa30a28acb50331949c212ecc954ab9/757bd1cf/SelecTree-Olea_europaea3.jpg", "mime": "image/jpeg", "size": 159598, "filename": "SelecTree-Olea_europaea3.jpg"}'::jsonb, 0), ('393ff77f-40d3-55de-93db-0a53969b400b', 'Peppermint Tree', 'Dark green fragrant leaves, showy white flowers in spring or summer, and fruiting in the fall, this wonderful tree is native to Western Australia.', 'Peppermint Tree', '{"url": "https://dl.airtable.com/.attachments/b02370d9d2a7c897df8f64bc54b1fa88/febbbea2/SelecTree-Agonis_flexuosa.jpg", "mime": "image/jpeg", "size": 535719, "filename": "SelecTree-Agonis_flexuosa.jpg"}'::jsonb, 0), ('393ff77f-40d3-55de-93db-0a53969b400b', 'Pink Trumpet', 'This long-lived tree is spectacular when in full bloom with pink flowers in spring or summer. Low water needs.', 'Pink Trumpet', '{"url": "https://dl.airtable.com/.attachments/56eb3d4be9957f964449488736a06512/1d686507/SelecTree-Tabebuia_heterophylla.jpg", "mime": "image/jpeg", "size": 229380, "filename": "SelecTree-Tabebuia_heterophylla.jpg"}'::jsonb, 0), ('393ff77f-40d3-55de-93db-0a53969b400b', 'Silk Tree', 'This drought tolerant tree has an elegant dome shaped crown canopy, long feathery, finely textured leaves, and delicate pink or rose flowers in spring or summer. Native to southwestern and Eastern Asia.', 'Silk Tree', '{"url": "https://dl.airtable.com/.attachments/68de0d9117a1ad64271a141d0f9c295a/928eeeef/SelecTree-Albizia_julibrissin.jpg", "mime": "image/jpeg", "size": 90523, "filename": "SelecTree-Albizia_julibrissin.jpg"}'::jsonb, 0), ('393ff77f-40d3-55de-93db-0a53969b400b', 'Sweet Bay', 'The fragrant leaves of this tree are thick, waxy and resistant to fire. The bay leaf adds great flavor in cooking, and can be dried and bunched to deter moths indoors. Green, white or yellow flowers bloom in spring. Native to mediterranean region.', 'Sweet Bay', '{"url": "https://dl.airtable.com/.attachments/025029f7a5fc7e2ca7fa021241a0c2b4/663e5ec7/SelecTree-Laurus_nobilis2-1.jpg", "mime": "image/jpeg", "size": 192589, "filename": "SelecTree-Laurus_nobilis2-1.jpg"}'::jsonb, 0), ('393ff77f-40d3-55de-93db-0a53969b400b', 'African Fern Pine', 'Drought tolerant with dense canopy, great for privacy and shade. This long living tree bears flowers in spring and cones in the fall. Native to Uganda, Ethiopia and Kenya.', 'African Fern Pine', '{"url": "https://dl.airtable.com/.attachments/4b0df1bca7509638885c56bb5d140941/a4f30da1/SelecTree-Afrocarpus_falcatus2.jpg", "mime": "image/jpeg", "size": 492785, "filename": "SelecTree-Afrocarpus_falcatus2.jpg"}'::jsonb, 0), ('393ff77f-40d3-55de-93db-0a53969b400b', 'Aleppo Pine', 'Long living pine, great for shade and drought tolerant. Brings flowers in spring and cones in fall or winter. Mediterranean native.', 'Aleppo Pine', '{"url": "https://dl.airtable.com/.attachments/99edfcf8201ab75b4551b8a84977b775/250133ed/SelecTree-Pinus_halepensis.jpg", "mime": "image/jpeg", "size": 138497, "filename": "SelecTree-Pinus_halepensis.jpg"}'::jsonb, 0), ('393ff77f-40d3-55de-93db-0a53969b400b', 'Brisbane Box', 'Drought tolerant with showy and ornate white flowers in spring. Moderately dense shading capacity. Native to Australia.', 'Brisbane Box', '{"url": "https://dl.airtable.com/.attachments/45af3496dfdd393e088cb9f09c1056de/3cb73d86/SelecTree-Lophostemon_confertus.jpg", "mime": "image/jpeg", "size": 649586, "filename": "SelecTree-Lophostemon_confertus.jpg"}'::jsonb, 0), ('393ff77f-40d3-55de-93db-0a53969b400b', 'Canary Island Pine', 'This pine has bluish or silvery green needles, grows tall and offers moderate shade. Native of the Canary Islands of Spain and drought tolerant.', 'Canary Island Pine', '{"url": "https://dl.airtable.com/.attachments/a50a639afb2d9eb0b6b5f2c96db4fba7/1ff8d6b9/SelecTree-Pinus_canariensis.jpg", "mime": "image/jpeg", "size": 148948, "filename": "SelecTree-Pinus_canariensis.jpg"}'::jsonb, 0), ('393ff77f-40d3-55de-93db-0a53969b400b', 'Coast Live Oak', 'Native to central and Southern California. Hearty, long living oak with large spreading canopy and inconspicuous flowers in the spring.', 'Coast Live Oak', '{"url": "https://dl.airtable.com/.attachments/d52fb4e921fa32bbeabe295782b0971c/6ae25dbe/SelecTree-Quercus_agrifolia3.jpg", "mime": "image/jpeg", "size": 106358, "filename": "SelecTree-Quercus_agrifolia3.jpg"}'::jsonb, 0), ('393ff77f-40d3-55de-93db-0a53969b400b', 'Deodar Cedar', 'This tall, long living, drought tolerant tree has fragrant leaves and bark, and bears tiny flowers in fall and large beautiful cones in spring. Native Eastern Afghanistan, Northern Pakistan and North-Central India.', 'Deodar Cedar', '{"url": "https://dl.airtable.com/.attachments/84d60bc2013ef1741c077786b4c60952/fa23cd26/SelecTree-Cedrus_deodara.jpg", "mime": "image/jpeg", "size": 127037, "filename": "SelecTree-Cedrus_deodara.jpg"}'::jsonb, 0), ('393ff77f-40d3-55de-93db-0a53969b400b', 'Drake Chinese Elm', 'This drought tolerant tall tree offers moderate shade and inconspicuous flowers in summer or fall.', 'Drake Chinese Elm', '{"url": "https://dl.airtable.com/.attachments/95a698b8914120b298820a5515fa6419/da79e1b0/SelecTree-Ulmus_parvifolia_Drake.jpg", "mime": "image/jpeg", "size": 173431, "filename": "SelecTree-Ulmus_parvifolia_Drake.jpg"}'::jsonb, 0), ('393ff77f-40d3-55de-93db-0a53969b400b', 'Italian Stone Pine', 'This tall and wide canopy tree bears edible pine nuts in winter with ample growing space. Native to the Mediterranean Region. Drought tolerant.', 'Italian Stone Pine', '{"url": "https://dl.airtable.com/.attachments/300aaf7115edf0643daae8cb6eff893b/f02c22a6/pinus-pinea-tree-2.jpg", "mime": "image/jpeg", "size": 425302, "filename": "pinus-pinea-tree-2.jpg"}'::jsonb, 0), ('393ff77f-40d3-55de-93db-0a53969b400b', 'Jacaranda', 'Big blue or lavender fragrant flowers in spring, summer or fall. Native to Argentina and Bolivia.', 'Jacaranda', '{"url": "https://dl.airtable.com/.attachments/8efd40f23b60335e6f7d017e072d3b1b/bd49fc40/SelecTree-Jacaranda_mimosifolia_2.jpg", "mime": "image/jpeg", "size": 130406, "filename": "SelecTree-Jacaranda_mimosifolia_2.jpg"}'::jsonb, 0), ('393ff77f-40d3-55de-93db-0a53969b400b', 'Tipu Tree', 'This tree offers wide and dense canopy and cheerful yellow or orange flowers in summer. Native to Bolivia and Southern Brazil.', 'Tipu Tree', '{"url": "https://dl.airtable.com/.attachments/d30d8e10cb9e45901f6e58a8bd94c245/ed725c54/tipuana-tipu-tree-baldwin.jpg", "mime": "image/jpeg", "size": 183042, "filename": "tipuana-tipu-tree-baldwin.jpg"}'::jsonb, 0), ('393ff77f-40d3-55de-93db-0a53969b400b', 'Other', 'Trees are key to fighting urban heat', 'Other', '{"url": "https://dl.airtable.com/.attachments/6dc994019ff52fe34a8b1658161544bc/0c9a0b8f/Group1131.jpg", "mime": "image/jpeg", "size": 183042, "filename": "tree.jpg"}'::jsonb, 0);

INSERT INTO dashboard_public.impacts ( id, name, object_type_id, type, unit_value, unit_id, net_gain, per_interval, per_value, per_unit_id, impact_object_type_id, impact_type, impact_unit_value, impact_unit_id ) VALUES ('ac2c982d-1053-5130-8324-33cd5407d48f', 'Storm Water filtered', '3b71372f-777a-5d81-ac75-7ab1616c30d5', 'Tree', 1, 'd498c500-35dd-592b-a3f3-b7e95b3633c6', TRUE, '1 year'::interval, 1, 'a9ad1d74-abcf-5d29-90dd-5d4583cfe886', 'a0306812-62fa-5535-b34f-ed40770d2b1b', 'Filtered Storm Water', 147000, '792ac897-8915-50d6-ae5f-554d3f441c77'), ('afef1e03-7f5d-5f90-a3b0-fcf918599879', 'Farm Land Sequestered Carbon', 'e0ab12ef-cb03-5f24-8090-ffaf9edbdf4e', 'Farm Land', 20, '59724f76-1ada-58b6-bd1b-8b4312b61c48', TRUE, '1 year'::interval, 1, 'a9ad1d74-abcf-5d29-90dd-5d4583cfe886', '910b019b-85c0-561c-a208-69fbee5384ce', 'CO2', 20, '8e4cdd8b-210a-59c2-a611-10eb1ad13902'), ('8fbb4beb-d57e-5802-b3fa-b52345e7a6ff', 'Carbon Dioxide Emitted', '183837e6-5ffa-5ac8-9d51-9f1b85d629c5', '', 20, 'd498c500-35dd-592b-a3f3-b7e95b3633c6', TRUE, '1 year'::interval, 1, 'a9ad1d74-abcf-5d29-90dd-5d4583cfe886', '910b019b-85c0-561c-a208-69fbee5384ce', 'CO2', 20, '8e4cdd8b-210a-59c2-a611-10eb1ad13902'), ('e754db3a-470a-5cbf-9617-b921beeaa81c', 'Save Water', '50b89798-695e-555c-8193-c377ffaea766', '', 1, 'dd5e5964-9353-5d08-ad2b-853ab5e2523d', TRUE, '1 day'::interval, 1, '218694ca-55f8-5399-894c-22dbff0b59df', 'a0306812-62fa-5535-b34f-ed40770d2b1b', 'Water', 2, '792ac897-8915-50d6-ae5f-554d3f441c77'), ('4df01b8d-1fbf-5487-b1ab-db0d405b96ec', 'Soil Generated', '634e09b2-2c30-53d3-94ad-f4c55e904077', '', 20, '59724f76-1ada-58b6-bd1b-8b4312b61c48', TRUE, '1 year'::interval, 1, 'a9ad1d74-abcf-5d29-90dd-5d4583cfe886', 'a50c7b50-0f9d-5cc3-afc1-96a0288637f6', 'Soil', 200, '8e4cdd8b-210a-59c2-a611-10eb1ad13902'), ('2667e77f-4f6d-59ba-97eb-80f280eeafcd', 'Energy Generated', '963b2e9b-f7e0-5a97-ab48-17ee22d4a1eb', '', 68.42, '075c0354-b0a1-5c0c-8be1-8f74cd1f2dfa', TRUE, '1 year'::interval, 1, 'a9ad1d74-abcf-5d29-90dd-5d4583cfe886', NULL, '', 1642, 'dac9c0d5-8c1d-5f07-9138-93c132622fdc');

INSERT INTO dashboard_public.impacts_conditions ( name, impact_id, attr_id, op, value ) VALUES ('', '8fbb4beb-d57e-5802-b3fa-b52345e7a6ff', '41f9bdf8-74eb-5941-bc8f-e38ecdea2ac9', 0, 'Honda'), ('', '8fbb4beb-d57e-5802-b3fa-b52345e7a6ff', '01f55b9a-dd35-54ab-9b7f-e83b5b3f9e7a', 1, '1990');

ALTER TABLE dashboard_public.groups ADD COLUMN  description text;

ALTER TABLE dashboard_public.impacts ADD COLUMN  icon image;

ALTER TABLE dashboard_public.impacts ADD COLUMN  image image;

ALTER TABLE dashboard_public.impacts ADD COLUMN  header_image image;

ALTER TABLE dashboard_public.impacts ADD COLUMN  description text;

ALTER TABLE dashboard_public.impacts ADD COLUMN  rich_description text;

ALTER TABLE dashboard_public.actions ADD COLUMN  verification_reward_amount numeric;

ALTER TABLE dashboard_status_public.app_levels DROP CONSTRAINT app_levels_reward_id_fkey;

ALTER TABLE dashboard_status_public.app_levels ADD CONSTRAINT app_levels_reward_id_fkey FOREIGN KEY ( reward_id ) REFERENCES dashboard_public.rewards ( id ) ON DELETE SET NULL;

ALTER TABLE dashboard_public.reward_payments DROP CONSTRAINT reward_payments_user_id_fkey;

ALTER TABLE dashboard_public.reward_payments ADD CONSTRAINT reward_payments_user_id_fkey FOREIGN KEY ( user_id ) REFERENCES dashboard_public.users ( id ) ON DELETE SET NULL;

ALTER TABLE dashboard_public.reward_payments DROP CONSTRAINT reward_payments_reward_id_fkey;

ALTER TABLE dashboard_public.reward_payments ADD CONSTRAINT reward_payments_reward_id_fkey FOREIGN KEY ( reward_id ) REFERENCES dashboard_public.rewards ( id ) ON DELETE SET NULL;

ALTER TABLE dashboard_public.reward_payments DROP CONSTRAINT reward_payments_owner_id_fkey;

ALTER TABLE dashboard_public.reward_payments ADD CONSTRAINT reward_payments_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE SET NULL;

ALTER TABLE dashboard_public.reward_payments DROP CONSTRAINT reward_payments_action_id_fkey;

ALTER TABLE dashboard_public.reward_payments ADD CONSTRAINT reward_payments_action_id_fkey FOREIGN KEY ( action_id ) REFERENCES dashboard_public.actions ( id ) ON DELETE SET NULL;

ALTER TABLE dashboard_public.messages DROP CONSTRAINT messages_sender_id_fkey;

ALTER TABLE dashboard_public.messages ADD CONSTRAINT messages_sender_id_fkey FOREIGN KEY ( sender_id ) REFERENCES dashboard_public.users ( id ) ON DELETE SET NULL;

ALTER TABLE dashboard_public.actions DROP CONSTRAINT actions_verify_reward_id_fkey;

ALTER TABLE dashboard_public.actions ADD CONSTRAINT actions_verify_reward_id_fkey FOREIGN KEY ( verify_reward_id ) REFERENCES dashboard_public.rewards ( id ) ON DELETE SET NULL;

ALTER TABLE dashboard_public.actions DROP CONSTRAINT actions_reward_id_fkey;

ALTER TABLE dashboard_public.actions ADD CONSTRAINT actions_reward_id_fkey FOREIGN KEY ( reward_id ) REFERENCES dashboard_public.rewards ( id ) ON DELETE SET NULL;

ALTER TABLE dashboard_public.actions DROP CONSTRAINT actions_minimum_group_unit_id_fkey;

ALTER TABLE dashboard_public.actions ADD CONSTRAINT actions_minimum_group_unit_id_fkey FOREIGN KEY ( minimum_group_unit_id ) REFERENCES dashboard_public.units ( id ) ON DELETE SET NULL;

ALTER TABLE dashboard_public.actions DROP CONSTRAINT actions_group_id_fkey;

ALTER TABLE dashboard_public.actions ADD CONSTRAINT actions_group_id_fkey FOREIGN KEY ( group_id ) REFERENCES dashboard_public.groups ( id ) ON DELETE SET NULL;

CREATE TABLE dashboard_public.tags (
  
);

ALTER TABLE dashboard_public.tags DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.tags ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.tags ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.tags ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.tags ADD CONSTRAINT tags_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.tags ADD COLUMN  name citext;

ALTER TABLE dashboard_public.tags ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.tags ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.tags 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.tags ( created_by );

CREATE INDEX ON dashboard_public.tags ( updated_by );

ALTER TABLE dashboard_public.tags ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.tags ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.tags ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.tags ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.tags 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.tags ( created_at );

CREATE INDEX ON dashboard_public.tags ( updated_at );

ALTER TABLE dashboard_public.tags ADD CONSTRAINT tags_name_key UNIQUE ( name );

COMMENT ON CONSTRAINT tags_name_key ON dashboard_public.tags IS NULL;

ALTER TABLE dashboard_public.tags ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.tags TO authenticated;

GRANT SELECT ON TABLE dashboard_public.tags TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.tags TO authenticated;

GRANT DELETE ON TABLE dashboard_public.tags TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.tags FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_public.tags FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE) );

CREATE POLICY auth_upd ON dashboard_public.tags FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE) );

CREATE POLICY auth_del ON dashboard_public.tags FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE) );

ALTER TABLE dashboard_public.impacts_conditions ADD COLUMN  object_value_id uuid;

ALTER TABLE dashboard_public.impacts_conditions ADD CONSTRAINT impacts_conditions_object_value_id_fkey FOREIGN KEY ( object_value_id ) REFERENCES dashboard_public.object_type_values ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT impacts_conditions_object_value_id_fkey ON dashboard_public.impacts_conditions IS E'@omit manyToMany';

CREATE INDEX impacts_conditions_object_value_id_idx ON dashboard_public.impacts_conditions ( object_value_id );

ALTER TABLE dashboard_public.location_types ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.location_types TO authenticated;

GRANT SELECT ON TABLE dashboard_public.location_types TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.location_types TO authenticated;

GRANT DELETE ON TABLE dashboard_public.location_types TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.location_types FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_upd ON dashboard_public.location_types FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_del ON dashboard_public.location_types FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_sel ON dashboard_public.location_types FOR SELECT TO authenticated USING ( TRUE );

ALTER TABLE dashboard_public.actions ADD COLUMN  data_tags citext[];

ALTER TABLE dashboard_public.impacts ADD COLUMN  data_tags citext[];

ALTER TABLE dashboard_public.users ADD COLUMN  data_tags citext[];

CREATE INDEX actions_data_tags_idx ON dashboard_public.actions USING GIN ( data_tags );

CREATE INDEX impacts_data_tags_idx ON dashboard_public.impacts USING GIN ( data_tags );

CREATE INDEX users_data_tags_idx ON dashboard_public.users USING GIN ( data_tags );

CREATE TABLE dashboard_public.data_tags (
  
);

ALTER TABLE dashboard_public.data_tags DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.data_tags ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.data_tags ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.data_tags ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.data_tags ADD CONSTRAINT data_tags_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.data_tags ADD COLUMN  name citext;

ALTER TABLE dashboard_public.data_tags ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.data_tags ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.data_tags 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.data_tags ( created_by );

CREATE INDEX ON dashboard_public.data_tags ( updated_by );

ALTER TABLE dashboard_public.data_tags ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.data_tags ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.data_tags ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.data_tags ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.data_tags 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.data_tags ( created_at );

CREATE INDEX ON dashboard_public.data_tags ( updated_at );

ALTER TABLE dashboard_public.data_tags ADD CONSTRAINT data_tags_name_key UNIQUE ( name );

COMMENT ON CONSTRAINT data_tags_name_key ON dashboard_public.data_tags IS NULL;

ALTER TABLE dashboard_public.data_tags ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.data_tags TO authenticated;

GRANT SELECT ON TABLE dashboard_public.data_tags TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.data_tags TO authenticated;

GRANT DELETE ON TABLE dashboard_public.data_tags TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.data_tags FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_public.data_tags FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE) );

CREATE POLICY auth_upd ON dashboard_public.data_tags FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE) );

CREATE POLICY auth_del ON dashboard_public.data_tags FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE) );

CREATE TABLE dashboard_public.action_language_variations (
  
);

ALTER TABLE dashboard_public.action_language_variations DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.action_language_variations ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.action_language_variations ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.action_language_variations ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.action_language_variations ADD CONSTRAINT action_language_variations_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.action_language_variations ADD COLUMN  lang_code citext;

ALTER TABLE dashboard_public.action_language_variations ADD CONSTRAINT action_language_variations_lang_code_chk CHECK ( character_length(lang_code) <= 10 );

ALTER TABLE dashboard_public.action_language_variations ADD COLUMN  title text;

ALTER TABLE dashboard_public.action_language_variations ADD COLUMN  title_object_template text;

ALTER TABLE dashboard_public.action_language_variations ADD COLUMN  description text;

ALTER TABLE dashboard_public.action_language_variations ADD COLUMN  completion_rich_text text;

ALTER TABLE dashboard_public.action_language_variations ADD COLUMN  discovery_header text;

ALTER TABLE dashboard_public.action_language_variations ADD COLUMN  discovery_description text;

ALTER TABLE dashboard_public.action_language_variations ADD COLUMN  notification_text text;

ALTER TABLE dashboard_public.action_language_variations ADD COLUMN  notification_object_template text;

ALTER TABLE dashboard_public.action_language_variations ADD COLUMN  enable_notifications_text text;

ALTER TABLE dashboard_public.action_language_variations ADD COLUMN  activity_feed_text text;

ALTER TABLE dashboard_public.action_language_variations ADD COLUMN  call_to_action text;

ALTER TABLE dashboard_public.action_language_variations ADD COLUMN  completed_action_text text;

ALTER TABLE dashboard_public.action_language_variations ADD COLUMN  already_completed_action_text text;

ALTER TABLE dashboard_public.action_language_variations ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.action_language_variations ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.action_language_variations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.action_language_variations ( created_by );

CREATE INDEX ON dashboard_public.action_language_variations ( updated_by );

ALTER TABLE dashboard_public.action_language_variations ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.action_language_variations ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.action_language_variations ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.action_language_variations ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.action_language_variations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.action_language_variations ( created_at );

CREATE INDEX ON dashboard_public.action_language_variations ( updated_at );

COMMENT ON TABLE dashboard_public.actions IS E'@i18n action_language_variations';

ALTER TABLE dashboard_public.action_language_variations ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.action_language_variations ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.action_language_variations ADD CONSTRAINT action_language_variations_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT action_language_variations_owner_id_fkey ON dashboard_public.action_language_variations IS E'@omit manyToMany';

CREATE INDEX action_language_variations_owner_id_idx ON dashboard_public.action_language_variations ( owner_id );

CREATE TRIGGER action_language_variations_owner_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.action_language_variations 
 FOR EACH ROW
 WHEN ( old.owner_id IS DISTINCT FROM new.owner_id AND old.owner_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','owner_id' );

ALTER TABLE dashboard_public.action_language_variations ADD COLUMN  action_id uuid;

ALTER TABLE dashboard_public.action_language_variations ALTER COLUMN action_id SET NOT NULL;

ALTER TABLE dashboard_public.action_language_variations ADD CONSTRAINT action_language_variations_action_id_fkey FOREIGN KEY ( action_id ) REFERENCES dashboard_public.actions ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT action_language_variations_action_id_fkey ON dashboard_public.action_language_variations IS E'@omit manyToMany';

CREATE INDEX action_language_variations_action_id_idx ON dashboard_public.action_language_variations ( action_id );

CREATE TRIGGER action_language_variations_action_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.action_language_variations 
 FOR EACH ROW
 WHEN ( old.action_id IS DISTINCT FROM new.action_id AND old.action_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','action_id' );

ALTER TABLE dashboard_public.action_language_variations ALTER COLUMN owner_id SET DEFAULT uuid_nil();

CREATE FUNCTION dashboard_private.action_language_variations_denorm_action_id (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  SELECT ref.owner_id FROM "dashboard_public".actions AS ref WHERE ref.id = new.action_id
  INTO new.owner_id;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_action_id 
 BEFORE INSERT ON dashboard_public.action_language_variations 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. action_language_variations_denorm_action_id (  );

CREATE TRIGGER _000000000_ensure_update_action_id 
 BEFORE UPDATE ON dashboard_public.action_language_variations 
 FOR EACH ROW
 WHEN ( old.action_id IS DISTINCT FROM new.action_id OR old.owner_id IS DISTINCT FROM new.owner_id ) 
 EXECUTE PROCEDURE dashboard_private. action_language_variations_denorm_action_id (  );

ALTER TABLE dashboard_public.action_language_variations ADD CONSTRAINT action_language_variations_lang_code_action_id_key UNIQUE ( lang_code, action_id );

COMMENT ON CONSTRAINT action_language_variations_lang_code_action_id_key ON dashboard_public.action_language_variations IS NULL;

CREATE FUNCTION dashboard_private.action_language_variations_slg_lang_code (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  new.lang_code = inflection.slugify(new.lang_code);
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER insert_slg_lang_code 
 BEFORE INSERT ON dashboard_public.action_language_variations 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. action_language_variations_slg_lang_code (  );

CREATE TRIGGER update_slg_lang_code 
 BEFORE UPDATE ON dashboard_public.action_language_variations 
 FOR EACH ROW
 WHEN ( OLD.lang_code IS DISTINCT FROM NEW.lang_code ) 
 EXECUTE PROCEDURE dashboard_private. action_language_variations_slg_lang_code (  );

CREATE INDEX action_language_variations_lang_code_idx ON dashboard_public.action_language_variations ( lang_code );

ALTER TABLE dashboard_public.action_language_variations ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.action_language_variations TO authenticated;

GRANT SELECT ON TABLE dashboard_public.action_language_variations TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.action_language_variations TO authenticated;

GRANT DELETE ON TABLE dashboard_public.action_language_variations TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.action_language_variations FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_public.action_language_variations FOR INSERT TO authenticated WITH CHECK ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE POLICY auth_upd ON dashboard_public.action_language_variations FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE POLICY auth_del ON dashboard_public.action_language_variations FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

ALTER TABLE dashboard_public.actions ADD COLUMN  completion_rich_text text;

ALTER TABLE dashboard_public.actions ADD COLUMN  completion_image image;

ALTER TABLE dashboard_public.user_settings ADD COLUMN  lang_code text;

CREATE FUNCTION dashboard_private.user_settings_slg_lang_code (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  new.lang_code = inflection.slugify(new.lang_code);
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER insert_slg_lang_code 
 BEFORE INSERT ON dashboard_public.user_settings 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. user_settings_slg_lang_code (  );

CREATE TRIGGER update_slg_lang_code 
 BEFORE UPDATE ON dashboard_public.user_settings 
 FOR EACH ROW
 WHEN ( OLD.lang_code IS DISTINCT FROM NEW.lang_code ) 
 EXECUTE PROCEDURE dashboard_private. user_settings_slg_lang_code (  );

CREATE TABLE dashboard_public.global_languages (
  
);

ALTER TABLE dashboard_public.global_languages DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.global_languages ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.global_languages ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.global_languages ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.global_languages ADD CONSTRAINT global_languages_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.global_languages ADD COLUMN  lang_code citext;

ALTER TABLE dashboard_public.global_languages ADD CONSTRAINT global_languages_lang_code_chk CHECK ( character_length(lang_code) <= 10 );

ALTER TABLE dashboard_public.global_languages ADD COLUMN  name text;

ALTER TABLE dashboard_public.global_languages ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.global_languages ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.global_languages 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.global_languages ( created_by );

CREATE INDEX ON dashboard_public.global_languages ( updated_by );

ALTER TABLE dashboard_public.global_languages ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.global_languages ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.global_languages ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.global_languages ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.global_languages 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.global_languages ( created_at );

CREATE INDEX ON dashboard_public.global_languages ( updated_at );

CREATE TRIGGER global_languages_lang_code_immutable_tg 
 BEFORE UPDATE ON dashboard_public.global_languages 
 FOR EACH ROW
 WHEN ( old.lang_code IS DISTINCT FROM new.lang_code AND old.lang_code IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','lang_code' );

ALTER TABLE dashboard_public.global_languages ADD CONSTRAINT global_languages_lang_code_key UNIQUE ( lang_code );

COMMENT ON CONSTRAINT global_languages_lang_code_key ON dashboard_public.global_languages IS NULL;

CREATE FUNCTION dashboard_private.global_languages_slg_lang_code (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  new.lang_code = inflection.slugify(new.lang_code);
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER insert_slg_lang_code 
 BEFORE INSERT ON dashboard_public.global_languages 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. global_languages_slg_lang_code (  );

CREATE TRIGGER update_slg_lang_code 
 BEFORE UPDATE ON dashboard_public.global_languages 
 FOR EACH ROW
 WHEN ( OLD.lang_code IS DISTINCT FROM NEW.lang_code ) 
 EXECUTE PROCEDURE dashboard_private. global_languages_slg_lang_code (  );

ALTER TABLE dashboard_public.global_languages ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.global_languages TO authenticated;

GRANT SELECT ON TABLE dashboard_public.global_languages TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.global_languages TO authenticated;

GRANT DELETE ON TABLE dashboard_public.global_languages TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.global_languages FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_public.global_languages FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE) );

CREATE POLICY auth_upd ON dashboard_public.global_languages FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE) );

CREATE POLICY auth_del ON dashboard_public.global_languages FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE) );

INSERT INTO dashboard_public.global_languages ( lang_code, name ) VALUES ('af', 'Afrikaans'), ('sq', 'Albanian'), ('ar', 'Arabic (Standard)'), ('ar-dz', 'Arabic (Algeria)'), ('ar-bh', 'Arabic (Bahrain)'), ('ar-eg', 'Arabic (Egypt)'), ('ar-iq', 'Arabic (Iraq)'), ('ar-jo', 'Arabic (Jordan)'), ('ar-kw', 'Arabic (Kuwait)'), ('ar-lb', 'Arabic (Lebanon)'), ('ar-ly', 'Arabic (Libya)'), ('ar-ma', 'Arabic (Morocco)'), ('ar-om', 'Arabic (Oman)'), ('ar-qa', 'Arabic (Qatar)'), ('ar-sa', 'Arabic (Saudi Arabia)'), ('ar-sy', 'Arabic (Syria)'), ('ar-tn', 'Arabic (Tunisia)'), ('ar-ae', 'Arabic (U.A.E.)'), ('ar-ye', 'Arabic (Yemen)'), ('an', 'Aragonese'), ('hy', 'Armenian'), ('as', 'Assamese'), ('ast', 'Asturian'), ('az', 'Azerbaijani'), ('eu', 'Basque'), ('be', 'Belarusian'), ('bn', 'Bengali'), ('bs', 'Bosnian'), ('br', 'Breton'), ('bg', 'Bulgarian'), ('my', 'Burmese'), ('ca', 'Catalan'), ('ch', 'Chamorro'), ('ce', 'Chechen'), ('zh', 'Chinese'), ('zh-hk', 'Chinese (Hong Kong)'), ('zh-cn', 'Chinese (PRC)'), ('zh-sg', 'Chinese (Singapore)'), ('zh-tw', 'Chinese (Taiwan)'), ('cv', 'Chuvash'), ('co', 'Corsican'), ('cr', 'Cree'), ('hr', 'Croatian'), ('cs', 'Czech'), ('da', 'Danish'), ('nl', 'Dutch (Standard)'), ('nl-be', 'Dutch (Belgian)'), ('en', 'English'), ('en-au', 'English (Australia)'), ('en-bz', 'English (Belize)'), ('en-ca', 'English (Canada)'), ('en-ie', 'English (Ireland)'), ('en-jm', 'English (Jamaica)'), ('en-nz', 'English (New Zealand)'), ('en-ph', 'English (Philippines)'), ('en-za', 'English (South Africa)'), ('en-tt', 'English (Trinidad & Tobago)'), ('en-gb', 'English (United Kingdom)'), ('en-us', 'English (United States)'), ('en-zw', 'English (Zimbabwe)'), ('eo', 'Esperanto'), ('et', 'Estonian'), ('fo', 'Faeroese'), ('fa', 'Farsi'), ('fj', 'Fijian'), ('fi', 'Finnish'), ('fr', 'French (Standard)'), ('fr-be', 'French (Belgium)'), ('fr-ca', 'French (Canada)'), ('fr-fr', 'French (France)'), ('fr-lu', 'French (Luxembourg)'), ('fr-mc', 'French (Monaco)'), ('fr-ch', 'French (Switzerland)'), ('fy', 'Frisian'), ('fur', 'Friulian'), ('gd', 'Gaelic (Scots)'), ('gd-ie', 'Gaelic (Irish)'), ('gl', 'Galacian'), ('ka', 'Georgian'), ('de', 'German (Standard)'), ('de-at', 'German (Austria)'), ('de-de', 'German (Germany)'), ('de-li', 'German (Liechtenstein)'), ('de-lu', 'German (Luxembourg)'), ('de-ch', 'German (Switzerland)'), ('el', 'Greek'), ('gu', 'Gujurati'), ('ht', 'Haitian'), ('he', 'Hebrew'), ('hi', 'Hindi'), ('hu', 'Hungarian'), ('is', 'Icelandic'), ('id', 'Indonesian'), ('iu', 'Inuktitut'), ('ga', 'Irish'), ('it', 'Italian (Standard)'), ('it-ch', 'Italian (Switzerland)'), ('ja', 'Japanese'), ('kn', 'Kannada'), ('ks', 'Kashmiri'), ('kk', 'Kazakh'), ('km', 'Khmer'), ('ky', 'Kirghiz'), ('tlh', 'Klingon'), ('ko', 'Korean'), ('ko-kp', 'Korean (North Korea)'), ('ko-kr', 'Korean (South Korea)'), ('la', 'Latin'), ('lv', 'Latvian'), ('lt', 'Lithuanian'), ('lb', 'Luxembourgish'), ('mk', 'FYRO Macedonian'), ('ms', 'Malay'), ('ml', 'Malayalam'), ('mt', 'Maltese'), ('mi', 'Maori'), ('mr', 'Marathi'), ('mo', 'Moldavian'), ('nv', 'Navajo'), ('ng', 'Ndonga'), ('ne', 'Nepali'), ('no', 'Norwegian'), ('nb', 'Norwegian (Bokmal)'), ('nn', 'Norwegian (Nynorsk)'), ('oc', 'Occitan'), ('or', 'Oriya'), ('om', 'Oromo'), ('fa-ir', 'Persian/Iran'), ('pl', 'Polish'), ('pt', 'Portuguese'), ('pt-br', 'Portuguese (Brazil)'), ('pa', 'Punjabi'), ('pa-in', 'Punjabi (India)'), ('pa-pk', 'Punjabi (Pakistan)'), ('qu', 'Quechua'), ('rm', 'Rhaeto-Romanic'), ('ro', 'Romanian'), ('ro-mo', 'Romanian (Moldavia)'), ('ru', 'Russian'), ('ru-mo', 'Russian (Moldavia)'), ('sz', 'Sami (Lappish)'), ('sg', 'Sango'), ('sa', 'Sanskrit'), ('sc', 'Sardinian'), ('sd', 'Sindhi'), ('si', 'Singhalese'), ('sr', 'Serbian'), ('sk', 'Slovak'), ('sl', 'Slovenian'), ('so', 'Somani'), ('sb', 'Sorbian'), ('es', 'Spanish'), ('es-ar', 'Spanish (Argentina)'), ('es-bo', 'Spanish (Bolivia)'), ('es-cl', 'Spanish (Chile)'), ('es-co', 'Spanish (Colombia)'), ('es-cr', 'Spanish (Costa Rica)'), ('es-do', 'Spanish (Dominican Republic)'), ('es-ec', 'Spanish (Ecuador)'), ('es-sv', 'Spanish (El Salvador)'), ('es-gt', 'Spanish (Guatemala)'), ('es-hn', 'Spanish (Honduras)'), ('es-mx', 'Spanish (Mexico)'), ('es-ni', 'Spanish (Nicaragua)'), ('es-pa', 'Spanish (Panama)'), ('es-py', 'Spanish (Paraguay)'), ('es-pe', 'Spanish (Peru)'), ('es-pr', 'Spanish (Puerto Rico)'), ('es-es', 'Spanish (Spain)'), ('es-uy', 'Spanish (Uruguay)'), ('es-ve', 'Spanish (Venezuela)'), ('sx', 'Sutu'), ('sw', 'Swahili'), ('sv', 'Swedish'), ('sv-fi', 'Swedish (Finland)'), ('sv-sv', 'Swedish (Sweden)'), ('ta', 'Tamil'), ('tt', 'Tatar'), ('te', 'Teluga'), ('th', 'Thai'), ('tig', 'Tigre'), ('ts', 'Tsonga'), ('tn', 'Tswana'), ('tr', 'Turkish'), ('tk', 'Turkmen'), ('uk', 'Ukrainian'), ('hsb', 'Upper Sorbian'), ('ur', 'Urdu'), ('ve', 'Venda'), ('vi', 'Vietnamese'), ('vo', 'Volapuk'), ('wa', 'Walloon'), ('cy', 'Welsh'), ('xh', 'Xhosa'), ('ji', 'Yiddish'), ('zu', 'Zulu');

CREATE TABLE dashboard_public.language_dictionary (
  
);

ALTER TABLE dashboard_public.language_dictionary DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.language_dictionary ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.language_dictionary ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.language_dictionary ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.language_dictionary ADD CONSTRAINT language_dictionaries_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.language_dictionary ADD COLUMN  lang_code citext;

ALTER TABLE dashboard_public.language_dictionary ADD CONSTRAINT language_dictionaries_lang_code_chk CHECK ( character_length(lang_code) <= 10 );

ALTER TABLE dashboard_public.language_dictionary ADD COLUMN  name text;

ALTER TABLE dashboard_public.language_dictionary ADD COLUMN  translated text;

ALTER TABLE dashboard_public.language_dictionary ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.language_dictionary ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.language_dictionary 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.language_dictionary ( created_by );

CREATE INDEX ON dashboard_public.language_dictionary ( updated_by );

ALTER TABLE dashboard_public.language_dictionary ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.language_dictionary ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.language_dictionary ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.language_dictionary ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.language_dictionary 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.language_dictionary ( created_at );

CREATE INDEX ON dashboard_public.language_dictionary ( updated_at );

ALTER TABLE dashboard_public.language_dictionary ADD CONSTRAINT language_dictionaries_lang_code_name_key UNIQUE ( lang_code, name );

COMMENT ON CONSTRAINT language_dictionaries_lang_code_name_key ON dashboard_public.language_dictionary IS NULL;

CREATE FUNCTION dashboard_private.language_dictionary_slg_lang_code (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  new.lang_code = inflection.slugify(new.lang_code);
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER insert_slg_lang_code 
 BEFORE INSERT ON dashboard_public.language_dictionary 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. language_dictionary_slg_lang_code (  );

CREATE TRIGGER update_slg_lang_code 
 BEFORE UPDATE ON dashboard_public.language_dictionary 
 FOR EACH ROW
 WHEN ( OLD.lang_code IS DISTINCT FROM NEW.lang_code ) 
 EXECUTE PROCEDURE dashboard_private. language_dictionary_slg_lang_code (  );

ALTER TABLE dashboard_public.language_dictionary ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.language_dictionary TO authenticated;

GRANT SELECT ON TABLE dashboard_public.language_dictionary TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.language_dictionary TO authenticated;

GRANT DELETE ON TABLE dashboard_public.language_dictionary TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.language_dictionary FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_public.language_dictionary FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE) );

CREATE POLICY auth_upd ON dashboard_public.language_dictionary FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE) );

CREATE POLICY auth_del ON dashboard_public.language_dictionary FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE) );

INSERT INTO dashboard_public.language_dictionary ( lang_code, name, translated ) VALUES ('en', 'Submit', 'Submit'), ('es', 'Submit', 'Enviar'), ('ja', 'Submit', '送信'), ('fr', 'Submit', 'Soumettre'), ('vi', 'Submit', 'Xác nhận'), ('de', 'Submit', 'Einreichen'), ('pt', 'Submit', 'Enviar'), ('sv', 'Submit', 'Lämna'), ('ko', 'Submit', '제출'), ('ru', 'Submit', 'Отправить'), ('af', 'Submit', 'Indien'), ('tr', 'Submit', 'Gönder'), ('it', 'Submit', 'Sottoscrivi'), ('ar', 'Submit', 'تقديم'), ('nl', 'Submit', 'Verzenden'), ('zh', 'Submit', '提交'), ('en', 'Sign Up', 'Sign Up'), ('es', 'Sign Up', 'Registrate'), ('ja', 'Sign Up', '新規登録'), ('fr', 'Sign Up', 'S''inscrire'), ('vi', 'Sign Up', 'Đăng ký'), ('de', 'Sign Up', 'Anmelden'), ('pt', 'Sign Up', 'Registrar'), ('sv', 'Sign Up', 'Registrera'), ('ko', 'Sign Up', '가입하기'), ('ru', 'Sign Up', 'Регистрация'), ('af', 'Sign Up', 'Teken aan'), ('tr', 'Sign Up', 'Kayıt Ol'), ('it', 'Sign Up', 'Registrarsi'), ('ar', 'Sign Up', 'تسجيل'), ('nl', 'Sign Up', 'Aanmelden'), ('zh', 'Sign Up', '注册'), ('en', 'Confirm Password', 'Confirm Password'), ('es', 'Confirm Password', 'Confirmar Contraseña'), ('ja', 'Confirm Password', 'パスワードを認証する'), ('fr', 'Confirm Password', 'Confirmation du mot de passe'), ('vi', 'Confirm Password', 'Xác nhận mật khẩu'), ('de', 'Confirm Password', 'Passwort Bestätigen'), ('pt', 'Confirm Password', 'Confirmar Senha'), ('sv', 'Confirm Password', 'Bekräfta lösenord'), ('ko', 'Confirm Password', '비밀번호 확인'), ('ru', 'Confirm Password', 'Подтвердите Пароль'), ('af', 'Confirm Password', 'Bevestig Wagwoord'), ('tr', 'Confirm Password', 'Şifreyi Doğrula'), ('it', 'Confirm Password', 'Confermare password'), ('ar', 'Confirm Password', ' تأكيد كلمة السر'), ('nl', 'Confirm Password', 'Wachtwoord bevestigen'), ('zh', 'Confirm Password', '确认密码'), ('en', 'Username', 'Username'), ('es', 'Username', 'Usuario'), ('ja', 'Username', 'ユーザー名'), ('fr', 'Username', 'Nom d''utilisateur'), ('vi', 'Username', 'Tên đăng nhập'), ('de', 'Username', 'Benutzername'), ('pt', 'Username', 'Nome de usuário'), ('sv', 'Username', 'Användarnamn'), ('ko', 'Username', '사용자 이름'), ('ru', 'Username', 'имя пользователя'), ('af', 'Username', 'Gebruikersnaam'), ('tr', 'Username', 'Kullanıcı Adı'), ('it', 'Username', 'Nome utente'), ('ar', 'Username', 'اسم المستخدم'), ('nl', 'Username', 'Gebruikersnaam'), ('zh', 'Username', '用户名'), ('en', 'Account-related information', 'Account-related information'), ('es', 'Account-related information', 'Información relacionada con la cuenta'), ('ja', 'Account-related information', 'アカウント情報'), ('fr', 'Account-related information', 'Informations concernant le compte '), ('vi', 'Account-related information', 'Thông tin liên quan đến tài khoản'), ('de', 'Account-related information', 'Kontobezogene Informationen'), ('pt', 'Account-related information', 'Informações relacionadas à conta'), ('sv', 'Account-related information', 'Konto-relaterad information'), ('ko', 'Account-related information', '계정 관련 정보'), ('ru', 'Account-related information', 'Информация об аккаунте'), ('af', 'Account-related information', 'Rekeningverwante inligting'), ('tr', 'Account-related information', 'Hesapla İlgili Bilgiler'), ('it', 'Account-related information', 'Impostazioni utilizzatore'), ('ar', 'Account-related information', 'المعلومات المتعلقة بالحساب'), ('nl', 'Account-related information', 'Account gerelateerde informatie'), ('zh', 'Account-related information', '账户信息'), ('en', 'Account', 'Account'), ('es', 'Account', 'Cuenta'), ('ja', 'Account', 'アカウント'), ('fr', 'Account', 'Compte'), ('vi', 'Account', 'Tài khoản'), ('de', 'Account', 'Konto'), ('pt', 'Account', 'Conta'), ('sv', 'Account', 'Konto'), ('ko', 'Account', '계정'), ('ru', 'Account', 'Аккаунт'), ('af', 'Account', 'Rekening'), ('tr', 'Account', 'Hesap'), ('it', 'Account', 'Account'), ('ar', 'Account', 'الحساب'), ('nl', 'Account', 'Account'), ('zh', 'Account', '账户'), ('en', 'Add Address', 'Add Address'), ('es', 'Add Address', 'Añadir Dirección'), ('ja', 'Add Address', 'アドレスを追加'), ('fr', 'Add Address', 'Ajoutez l''adresse'), ('vi', 'Add Address', 'Thêm địa chỉ'), ('de', 'Add Address', 'Adresse hinzufügen'), ('pt', 'Add Address', 'Adicionar Endereço'), ('sv', 'Add Address', 'Lägg till adress'), ('ko', 'Add Address', '주소 추가'), ('ru', 'Add Address', 'Добавить адрес'), ('af', 'Add Address', 'Voeg adres by'), ('tr', 'Add Address', 'Adres Ekle'), ('it', 'Add Address', 'Aggiungere indirizzo'), ('ar', 'Add Address', 'إضافة عنوان'), ('nl', 'Add Address', 'Adres toevoegen'), ('zh', 'Add Address', '添加地址'), ('en', 'address', 'address'), ('es', 'address', 'dirección'), ('ja', 'address', 'アドレス'), ('fr', 'address', 'adresse'), ('vi', 'address', 'địa chỉ'), ('de', 'address', 'Adresse'), ('pt', 'address', 'endereço'), ('sv', 'address', 'adress'), ('ko', 'address', '주소'), ('ru', 'address', 'адрес'), ('af', 'address', 'adres'), ('tr', 'address', 'adres'), ('it', 'address', 'indirizzo'), ('ar', 'address', 'عنوان'), ('nl', 'address', 'adres'), ('zh', 'address', '地址'), ('en', 'Amount', 'Amount'), ('es', 'Amount', 'Cantidad'), ('ja', 'Amount', '数量'), ('fr', 'Amount', 'Montant'), ('vi', 'Amount', 'Số tiền'), ('de', 'Amount', 'Betrag'), ('pt', 'Amount', 'Quantidade'), ('sv', 'Amount', 'Antal'), ('ko', 'Amount', '총액'), ('ru', 'Amount', 'Количество'), ('af', 'Amount', 'Bedrag'), ('tr', 'Amount', 'Miktar'), ('it', 'Amount', 'Quantitá'), ('ar', 'Amount', 'كمية'), ('nl', 'Amount', 'Hoeveelheid'), ('zh', 'Amount', '数量'), ('en', 'Close', 'Close'), ('es', 'Close', 'Cierralo'), ('ja', 'Close', '閉じる'), ('fr', 'Close', 'Fermer'), ('vi', 'Close', 'Đóng'), ('de', 'Close', 'schließen'), ('pt', 'Close', 'Fechar'), ('sv', 'Close', 'Stäng'), ('ko', 'Close', '닫기'), ('ru', 'Close', 'Закрыть'), ('af', 'Close', 'Maak toe'), ('tr', 'Close', 'Kapat'), ('it', 'Close', 'Chiudere'), ('ar', 'Close', 'إغلاق'), ('nl', 'Close', 'Sluit'), ('zh', 'Close', '关闭'), ('en', 'Create Account', 'Create Account'), ('es', 'Create Account', 'Crear Cuenta.'), ('ja', 'Create Account', 'アカウントを作成'), ('fr', 'Create Account', 'Créer un compte'), ('vi', 'Create Account', 'Tạo tài khoản'), ('de', 'Create Account', 'Konto erstellen'), ('pt', 'Create Account', 'Criar conta'), ('sv', 'Create Account', 'Skapa Konto'), ('ko', 'Create Account', '계정 생성'), ('ru', 'Create Account', 'Создать аккаунт'), ('af', 'Create Account', 'Skep rekening'), ('tr', 'Create Account', 'Hesap Oluştur'), ('it', 'Create Account', ''), ('ar', 'Create Account', 'إنشاء حساب'), ('nl', 'Create Account', 'Maak een Account'), ('zh', 'Create Account', '创建账户'), ('en', 'Disclaimer', 'Disclaimer'), ('es', 'Disclaimer', 'Renuncia'), ('ja', 'Disclaimer', '警告'), ('fr', 'Disclaimer', 'Avertissement'), ('vi', 'Disclaimer', 'Thông báo miễn trừ trách nhiệm'), ('de', 'Disclaimer', 'Hauftungsausschluss'), ('pt', 'Disclaimer', 'Aviso'), ('sv', 'Disclaimer', 'Friskrivningsklausul'), ('ko', 'Disclaimer', '경고 문구'), ('ru', 'Disclaimer', 'Предупреждение'), ('af', 'Disclaimer', 'Vrywaring'), ('tr', 'Disclaimer', 'Sorumluluk Reddi'), ('it', 'Disclaimer', ''), ('ar', 'Disclaimer', 'تنصل'), ('nl', 'Disclaimer', 'Vrijwaring'), ('zh', 'Disclaimer', '免责声明'), ('en', 'Donate', 'Donate'), ('es', 'Donate', 'Donar'), ('ja', 'Donate', '寄付'), ('fr', 'Donate', 'Faire un don'), ('vi', 'Donate', 'Tặng'), ('de', 'Donate', 'spenden'), ('pt', 'Donate', 'Doar'), ('sv', 'Donate', 'Bidra'), ('ko', 'Donate', '기부하기'), ('ru', 'Donate', 'Пожертвовать'), ('af', 'Donate', 'Skenk'), ('tr', 'Donate', 'Bağış Yap'), ('it', 'Donate', ''), ('ar', 'Donate', 'تبرع'), ('nl', 'Donate', 'Doneer'), ('zh', 'Donate', '捐赠'), ('en', 'Home', 'Home'), ('es', 'Home', 'Inicio'), ('ja', 'Home', 'ホーム'), ('fr', 'Home', 'Page d''accueil'), ('vi', 'Home', 'Trang chủ'), ('de', 'Home', 'Start'), ('pt', 'Home', 'Inicio'), ('sv', 'Home', 'Hem'), ('ko', 'Home', '처음으로'), ('ru', 'Home', 'Домой'), ('af', 'Home', 'Tuis'), ('tr', 'Home', 'Anasayfa'), ('it', 'Home', ''), ('ar', 'Home', 'الصفحة الرئيسية'), ('nl', 'Home', 'Home'), ('zh', 'Home', '主页'), ('en', 'Login', 'Login'), ('es', 'Login', 'Iniciar sesión'), ('ja', 'Login', 'ログイン'), ('fr', 'Login', 'Se connecter'), ('vi', 'Login', 'Đăng nhập'), ('de', 'Login', 'Anmeldung'), ('pt', 'Login', 'Logar'), ('sv', 'Login', 'Logga in'), ('ko', 'Login', '로그인'), ('ru', 'Login', 'Вход'), ('af', 'Login', 'Teken aan'), ('tr', 'Login', 'Giriş'), ('it', 'Login', ''), ('ar', 'Login', 'تسجيل الدخول'), ('nl', 'Login', 'Inloggen'), ('zh', 'Login', '登陆'), ('en', 'Logout', 'Logout'), ('es', 'Logout', 'Cerrar sesión'), ('ja', 'Logout', 'ログアウト'), ('fr', 'Logout', 'Se déconnecter'), ('vi', 'Logout', 'Đăng xuất'), ('de', 'Logout', 'Abmeldung'), ('pt', 'Logout', 'Sair'), ('sv', 'Logout', 'Logga ut'), ('ko', 'Logout', '로그아웃'), ('ru', 'Logout', 'Выход'), ('af', 'Logout', 'Teken uit'), ('tr', 'Logout', 'Çıkış'), ('it', 'Logout', ''), ('ar', 'Logout', 'تسجيل الخروج'), ('nl', 'Logout', 'Uitloggen'), ('zh', 'Logout', '退出'), ('en', 'Next', 'Next'), ('es', 'Next', 'Próximo'), ('ja', 'Next', '次'), ('fr', 'Next', 'Suivant'), ('vi', 'Next', 'Kế tiếp'), ('de', 'Next', 'nächste'), ('pt', 'Next', 'Próximo'), ('sv', 'Next', 'Nästa'), ('ko', 'Next', '다음'), ('ru', 'Next', 'Следующий'), ('af', 'Next', 'Volgende'), ('tr', 'Next', 'Sonraki'), ('it', 'Next', ''), ('ar', 'Next', 'التالي'), ('nl', 'Next', 'Volgende'), ('zh', 'Next', '下一步'), ('en', 'Password', 'Password'), ('es', 'Password', 'Contraseña'), ('ja', 'Password', 'パスワード'), ('fr', 'Password', 'Mot de passe'), ('vi', 'Password', 'Mật khẩu'), ('de', 'Password', 'Passwort'), ('pt', 'Password', 'Senha'), ('sv', 'Password', 'Lösenord'), ('ko', 'Password', '암호'), ('ru', 'Password', 'Пароль'), ('af', 'Password', 'Wagwoord'), ('tr', 'Password', 'Şifre'), ('it', 'Password', ''), ('ar', 'Password', 'كلمة السر'), ('nl', 'Password', 'Wachtwoord'), ('zh', 'Password', '密码'), ('en', 'Previous', 'Previous'), ('es', 'Previous', 'Anterior'), ('ja', 'Previous', '前'), ('fr', 'Previous', 'Précédent'), ('vi', 'Previous', 'Trước'), ('de', 'Previous', 'vorherige'), ('pt', 'Previous', 'Anterior'), ('sv', 'Previous', 'Föregående'), ('ko', 'Previous', '이전'), ('ru', 'Previous', 'Предыдущий'), ('af', 'Previous', 'Vorige'), ('tr', 'Previous', 'Önceki'), ('it', 'Previous', ''), ('ar', 'Previous', 'سابق'), ('nl', 'Previous', 'Vorige'), ('zh', 'Previous', '上一步'), ('en', 'Support Us', 'Support Us'), ('es', 'Support Us', 'Apoyanos'), ('ja', 'Support Us', '支援する'), ('fr', 'Support Us', 'Soutenez-nous'), ('vi', 'Support Us', 'Hỗ trợ'), ('de', 'Support Us', 'unterstütze uns'), ('pt', 'Support Us', 'Ajude nós'), ('sv', 'Support Us', 'Hjälp oss'), ('ko', 'Support Us', '후원하기'), ('ru', 'Support Us', 'Поддержите нас'), ('af', 'Support Us', 'Ondersteun ons'), ('tr', 'Support Us', 'Bize Destek Olun'), ('it', 'Support Us', ''), ('ar', 'Support Us', 'إدعمنا'), ('nl', 'Support Us', 'Ondersteun ons'), ('zh', 'Support Us', '支持我们');

CREATE TABLE dashboard_public.question_types (
  
);

ALTER TABLE dashboard_public.question_types DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.question_types ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.question_types ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.question_types ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.question_types ADD CONSTRAINT question_types_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.question_types ADD COLUMN  name text;

ALTER TABLE dashboard_public.question_types ADD COLUMN  description text;

ALTER TABLE dashboard_public.question_types ADD COLUMN  slug citext;

ALTER TABLE dashboard_public.question_types ADD CONSTRAINT question_types_slug_chk CHECK ( character_length(slug) <= 2048 );

ALTER TABLE dashboard_public.question_types ADD COLUMN  ref_num serial;

ALTER TABLE dashboard_public.question_types ADD COLUMN  field_type text;

COMMENT ON COLUMN dashboard_public.question_types.field_type IS E'e.g. text, numeric, location, etc.';

ALTER TABLE dashboard_public.question_types ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.question_types ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.question_types 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.question_types ( created_by );

CREATE INDEX ON dashboard_public.question_types ( updated_by );

ALTER TABLE dashboard_public.question_types ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.question_types ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.question_types ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.question_types ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.question_types 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.question_types ( created_at );

CREATE INDEX ON dashboard_public.question_types ( updated_at );

CREATE FUNCTION dashboard_private.question_types_slg_slug (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  new.slug = inflection.slugify(new.slug);
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER insert_slg_slug 
 BEFORE INSERT ON dashboard_public.question_types 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. question_types_slg_slug (  );

CREATE TRIGGER update_slg_slug 
 BEFORE UPDATE ON dashboard_public.question_types 
 FOR EACH ROW
 WHEN ( OLD.slug IS DISTINCT FROM NEW.slug ) 
 EXECUTE PROCEDURE dashboard_private. question_types_slg_slug (  );

CREATE TRIGGER question_types_slug_immutable_tg 
 BEFORE UPDATE ON dashboard_public.question_types 
 FOR EACH ROW
 WHEN ( old.slug IS DISTINCT FROM new.slug AND old.slug IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','slug' );

CREATE TRIGGER question_types_ref_num_immutable_tg 
 BEFORE UPDATE ON dashboard_public.question_types 
 FOR EACH ROW
 WHEN ( old.ref_num IS DISTINCT FROM new.ref_num AND old.ref_num IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','ref_num' );

CREATE INDEX question_types_ref_num_idx ON dashboard_public.question_types ( ref_num );

CREATE INDEX question_types_slug_idx ON dashboard_public.question_types ( slug );

ALTER TABLE dashboard_public.question_types ADD CONSTRAINT question_types_slug_key UNIQUE ( slug );

COMMENT ON CONSTRAINT question_types_slug_key ON dashboard_public.question_types IS E'@omit';

ALTER TABLE dashboard_public.question_types ADD CONSTRAINT question_types_ref_num_key UNIQUE ( ref_num );

COMMENT ON CONSTRAINT question_types_ref_num_key ON dashboard_public.question_types IS E'@omit';

ALTER TABLE dashboard_public.question_types ADD CONSTRAINT question_types_name_key UNIQUE ( name );

COMMENT ON CONSTRAINT question_types_name_key ON dashboard_public.question_types IS E'@omit';

ALTER TABLE dashboard_public.question_types ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.question_types TO authenticated;

GRANT SELECT ON TABLE dashboard_public.question_types TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.question_types TO authenticated;

GRANT DELETE ON TABLE dashboard_public.question_types TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.question_types FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_public.question_types FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000100000000000000000') = '00000000000000100000000000000000') );

CREATE POLICY auth_upd ON dashboard_public.question_types FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000100000000000000000') = '00000000000000100000000000000000') );

CREATE POLICY auth_del ON dashboard_public.question_types FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000100000000000000000') = '00000000000000100000000000000000') );

CREATE TABLE dashboard_public.form_types (
  
);

ALTER TABLE dashboard_public.form_types DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.form_types ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.form_types ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.form_types ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.form_types ADD CONSTRAINT form_types_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.form_types ADD COLUMN  name text;

ALTER TABLE dashboard_public.form_types ADD COLUMN  description text;

ALTER TABLE dashboard_public.form_types ADD COLUMN  slug citext;

ALTER TABLE dashboard_public.form_types ADD CONSTRAINT form_types_slug_chk CHECK ( character_length(slug) <= 2048 );

ALTER TABLE dashboard_public.form_types ADD COLUMN  ref_num serial;

ALTER TABLE dashboard_public.form_types ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.form_types ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.form_types 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.form_types ( created_by );

CREATE INDEX ON dashboard_public.form_types ( updated_by );

ALTER TABLE dashboard_public.form_types ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.form_types ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.form_types ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.form_types ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.form_types 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.form_types ( created_at );

CREATE INDEX ON dashboard_public.form_types ( updated_at );

CREATE FUNCTION dashboard_private.form_types_slg_slug (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  new.slug = inflection.slugify(new.slug);
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER insert_slg_slug 
 BEFORE INSERT ON dashboard_public.form_types 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. form_types_slg_slug (  );

CREATE TRIGGER update_slg_slug 
 BEFORE UPDATE ON dashboard_public.form_types 
 FOR EACH ROW
 WHEN ( OLD.slug IS DISTINCT FROM NEW.slug ) 
 EXECUTE PROCEDURE dashboard_private. form_types_slg_slug (  );

CREATE TRIGGER form_types_slug_immutable_tg 
 BEFORE UPDATE ON dashboard_public.form_types 
 FOR EACH ROW
 WHEN ( old.slug IS DISTINCT FROM new.slug AND old.slug IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','slug' );

CREATE TRIGGER form_types_ref_num_immutable_tg 
 BEFORE UPDATE ON dashboard_public.form_types 
 FOR EACH ROW
 WHEN ( old.ref_num IS DISTINCT FROM new.ref_num AND old.ref_num IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','ref_num' );

ALTER TABLE dashboard_public.form_types ADD CONSTRAINT form_types_slug_key UNIQUE ( slug );

COMMENT ON CONSTRAINT form_types_slug_key ON dashboard_public.form_types IS E'@omit';

ALTER TABLE dashboard_public.form_types ADD CONSTRAINT form_types_ref_num_key UNIQUE ( ref_num );

COMMENT ON CONSTRAINT form_types_ref_num_key ON dashboard_public.form_types IS E'@omit';

ALTER TABLE dashboard_public.form_types ADD CONSTRAINT form_types_name_key UNIQUE ( name );

COMMENT ON CONSTRAINT form_types_name_key ON dashboard_public.form_types IS E'@omit';

CREATE INDEX form_types_ref_num_idx ON dashboard_public.form_types ( ref_num );

CREATE INDEX form_types_slug_idx ON dashboard_public.form_types ( slug );

ALTER TABLE dashboard_public.form_types ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.form_types TO authenticated;

GRANT SELECT ON TABLE dashboard_public.form_types TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.form_types TO authenticated;

GRANT DELETE ON TABLE dashboard_public.form_types TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.form_types FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_public.form_types FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000100000000000000000') = '00000000000000100000000000000000') );

CREATE POLICY auth_upd ON dashboard_public.form_types FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000100000000000000000') = '00000000000000100000000000000000') );

CREATE POLICY auth_del ON dashboard_public.form_types FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000100000000000000000') = '00000000000000100000000000000000') );

ALTER TABLE dashboard_public.question_templates DROP COLUMN question_type;

ALTER TABLE dashboard_public.user_questions DROP COLUMN question_type;

ALTER TABLE dashboard_public.user_questions ADD COLUMN  question_type_id uuid;

ALTER TABLE dashboard_public.user_questions ALTER COLUMN question_type_id SET NOT NULL;

ALTER TABLE dashboard_public.user_questions ADD CONSTRAINT user_questions_question_type_id_fkey FOREIGN KEY ( question_type_id ) REFERENCES dashboard_public.question_types ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_questions_question_type_id_fkey ON dashboard_public.user_questions IS E'@omit manyToMany';

CREATE INDEX user_questions_question_type_id_idx ON dashboard_public.user_questions ( question_type_id );

ALTER TABLE dashboard_public.question_templates ADD COLUMN  question_type_id uuid;

ALTER TABLE dashboard_public.question_templates ALTER COLUMN question_type_id SET NOT NULL;

ALTER TABLE dashboard_public.question_templates ADD CONSTRAINT question_templates_question_type_id_fkey FOREIGN KEY ( question_type_id ) REFERENCES dashboard_public.question_types ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT question_templates_question_type_id_fkey ON dashboard_public.question_templates IS E'@omit manyToMany';

CREATE INDEX question_templates_question_type_id_idx ON dashboard_public.question_templates ( question_type_id );

CREATE TABLE dashboard_public.question_values (
  
);

ALTER TABLE dashboard_public.question_values DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.question_values ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.question_values ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.question_values ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.question_values ADD CONSTRAINT question_values_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.question_values ADD COLUMN  name text;

ALTER TABLE dashboard_public.question_values ADD COLUMN  description text;

ALTER TABLE dashboard_public.question_values ADD COLUMN  rich_description text;

ALTER TABLE dashboard_public.question_values ADD COLUMN  value_order int;

ALTER TABLE dashboard_public.question_values ADD COLUMN  location geometry(point, 4326);

ALTER TABLE dashboard_public.question_values ADD COLUMN  text text;

ALTER TABLE dashboard_public.question_values ADD COLUMN  numeric numeric;

ALTER TABLE dashboard_public.question_values ADD COLUMN  checkbox boolean;

ALTER TABLE dashboard_public.question_values ADD COLUMN  image image;

ALTER TABLE dashboard_public.question_values ADD COLUMN  data jsonb;

ALTER TABLE dashboard_public.question_values ADD COLUMN  is_other boolean;

ALTER TABLE dashboard_public.question_values ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.question_values ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.question_values 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.question_values ( created_by );

CREATE INDEX ON dashboard_public.question_values ( updated_by );

ALTER TABLE dashboard_public.question_values ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.question_values ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.question_values ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.question_values ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.question_values 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.question_values ( created_at );

CREATE INDEX ON dashboard_public.question_values ( updated_at );

ALTER TABLE dashboard_public.question_values ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.question_values ADD CONSTRAINT question_values_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT question_values_owner_id_fkey ON dashboard_public.question_values IS E'@omit manyToMany';

CREATE INDEX question_values_owner_id_idx ON dashboard_public.question_values ( owner_id );

ALTER TABLE dashboard_public.question_values ADD COLUMN  template_id uuid;

ALTER TABLE dashboard_public.question_values ADD CONSTRAINT question_values_template_id_fkey FOREIGN KEY ( template_id ) REFERENCES dashboard_public.question_templates ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT question_values_template_id_fkey ON dashboard_public.question_values IS E'@omit manyToMany';

CREATE INDEX question_values_template_id_idx ON dashboard_public.question_values ( template_id );

ALTER TABLE dashboard_public.question_values ADD COLUMN  question_id uuid;

ALTER TABLE dashboard_public.question_values ADD CONSTRAINT question_values_question_id_fkey FOREIGN KEY ( question_id ) REFERENCES dashboard_public.user_questions ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT question_values_question_id_fkey ON dashboard_public.question_values IS E'@omit manyToMany';

CREATE INDEX question_values_question_id_idx ON dashboard_public.question_values ( question_id );

ALTER TABLE dashboard_public.question_values ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.question_values TO authenticated;

GRANT SELECT ON TABLE dashboard_public.question_values TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.question_values TO authenticated;

GRANT DELETE ON TABLE dashboard_public.question_values TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.question_values FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_public.question_values FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000100000000000000000') = '00000000000000100000000000000000')) OR (owner_id IN (SELECT acl.actor_id FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE (acl.actor_id = owner_id AND (acl.permissions & '00000000000000100000000000000000') = '00000000000000100000000000000000')) AND owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000100000000000000000000') = '00000000000100000000000000000000'))) );

CREATE POLICY auth_upd ON dashboard_public.question_values FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000100000000000000000000') = '00000000000100000000000000000000')) OR EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000100000000000000000') = '00000000000000100000000000000000')) );

CREATE POLICY auth_del ON dashboard_public.question_values FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000100000000000000000000') = '00000000000100000000000000000000')) OR EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000100000000000000000') = '00000000000000100000000000000000')) );

ALTER TABLE dashboard_public.question_templates ADD COLUMN  description text;

ALTER TABLE dashboard_public.question_templates ADD COLUMN  rich_description text;

ALTER TABLE dashboard_public.question_templates ADD COLUMN  image image;

ALTER TABLE dashboard_public.question_templates ADD COLUMN  label text;

ALTER TABLE dashboard_public.question_templates ADD COLUMN  help_text text;

ALTER TABLE dashboard_public.question_templates ADD COLUMN  placeholder text;

ALTER TABLE dashboard_public.question_templates ADD COLUMN  is_reusable boolean;

ALTER TABLE dashboard_public.user_questions ADD COLUMN  description text;

ALTER TABLE dashboard_public.user_questions ADD COLUMN  rich_description text;

ALTER TABLE dashboard_public.user_questions ADD COLUMN  image image;

ALTER TABLE dashboard_public.user_questions ADD COLUMN  label text;

ALTER TABLE dashboard_public.user_questions ADD COLUMN  default_value jsonb;

ALTER TABLE dashboard_public.user_questions ADD COLUMN  help_text text;

ALTER TABLE dashboard_public.user_questions ADD COLUMN  placeholder text;

ALTER TABLE dashboard_public.user_questions ADD COLUMN  is_reusable boolean;

CREATE TABLE dashboard_public.forms (
  
);

ALTER TABLE dashboard_public.forms DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.forms ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.forms ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.forms ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.forms ADD CONSTRAINT forms_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.forms ADD COLUMN  name text;

ALTER TABLE dashboard_public.forms ADD COLUMN  description text;

ALTER TABLE dashboard_public.forms ADD COLUMN  image image;

ALTER TABLE dashboard_public.forms ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.forms ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.forms 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.forms ( created_by );

CREATE INDEX ON dashboard_public.forms ( updated_by );

ALTER TABLE dashboard_public.forms ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.forms ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.forms ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.forms ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.forms 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.forms ( created_at );

CREATE INDEX ON dashboard_public.forms ( updated_at );

ALTER TABLE dashboard_public.forms ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.forms ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.forms ADD CONSTRAINT forms_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT forms_owner_id_fkey ON dashboard_public.forms IS E'@omit manyToMany';

CREATE INDEX forms_owner_id_idx ON dashboard_public.forms ( owner_id );

ALTER TABLE dashboard_public.forms ADD COLUMN  type_id uuid;

ALTER TABLE dashboard_public.forms ALTER COLUMN type_id SET NOT NULL;

ALTER TABLE dashboard_public.forms ADD CONSTRAINT forms_type_id_fkey FOREIGN KEY ( type_id ) REFERENCES dashboard_public.form_types ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT forms_type_id_fkey ON dashboard_public.forms IS E'@omit manyToMany';

CREATE INDEX forms_type_id_idx ON dashboard_public.forms ( type_id );

ALTER TABLE dashboard_public.forms ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.forms TO authenticated;

GRANT SELECT ON TABLE dashboard_public.forms TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.forms TO authenticated;

GRANT DELETE ON TABLE dashboard_public.forms TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.forms FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_public.forms FOR INSERT TO authenticated WITH CHECK ( owner_id IN (SELECT acl.actor_id FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE (acl.actor_id = owner_id AND (acl.permissions & '00000000000000100000000000000000') = '00000000000000100000000000000000')) AND owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000100000000000000000000') = '00000000000100000000000000000000')) );

CREATE POLICY auth_upd ON dashboard_public.forms FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000100000000000000000000') = '00000000000100000000000000000000') );

CREATE POLICY auth_del ON dashboard_public.forms FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000100000000000000000000') = '00000000000100000000000000000000') );

CREATE TABLE dashboard_public.user_forms (
  
);

ALTER TABLE dashboard_public.user_forms DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.user_forms ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.user_forms ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.user_forms ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.user_forms ADD CONSTRAINT user_forms_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.user_forms ADD COLUMN  user_id uuid;

ALTER TABLE dashboard_public.user_forms ALTER COLUMN user_id SET NOT NULL;

ALTER TABLE dashboard_public.user_forms ALTER COLUMN user_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_public.user_forms ADD COLUMN  complete boolean;

ALTER TABLE dashboard_public.user_forms ALTER COLUMN complete SET DEFAULT FALSE;

ALTER TABLE dashboard_public.user_forms ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.user_forms ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_forms 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.user_forms ( created_by );

CREATE INDEX ON dashboard_public.user_forms ( updated_by );

ALTER TABLE dashboard_public.user_forms ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.user_forms ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.user_forms ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.user_forms ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_forms 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.user_forms ( created_at );

CREATE INDEX ON dashboard_public.user_forms ( updated_at );

ALTER TABLE dashboard_public.user_forms ADD CONSTRAINT user_forms_user_id_fkey FOREIGN KEY ( user_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_forms_user_id_fkey ON dashboard_public.user_forms IS E'@omit manyToMany';

CREATE INDEX user_forms_user_id_idx ON dashboard_public.user_forms ( user_id );

ALTER TABLE dashboard_public.user_forms ADD COLUMN  form_id uuid;

ALTER TABLE dashboard_public.user_forms ALTER COLUMN form_id SET NOT NULL;

ALTER TABLE dashboard_public.user_forms ADD CONSTRAINT user_forms_form_id_fkey FOREIGN KEY ( form_id ) REFERENCES dashboard_public.forms ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_forms_form_id_fkey ON dashboard_public.user_forms IS E'@omit manyToMany';

CREATE INDEX user_forms_form_id_idx ON dashboard_public.user_forms ( form_id );

ALTER TABLE dashboard_public.user_forms ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.user_forms ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.user_forms ADD CONSTRAINT user_forms_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_forms_owner_id_fkey ON dashboard_public.user_forms IS E'@omit manyToMany';

CREATE INDEX user_forms_owner_id_idx ON dashboard_public.user_forms ( owner_id );

ALTER TABLE dashboard_public.user_forms ALTER COLUMN owner_id SET DEFAULT uuid_nil();

CREATE FUNCTION dashboard_private.user_forms_denorm_form_id (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  SELECT ref.owner_id FROM "dashboard_public".forms AS ref WHERE ref.id = new.form_id
  INTO new.owner_id;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_form_id 
 BEFORE INSERT ON dashboard_public.user_forms 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. user_forms_denorm_form_id (  );

CREATE TRIGGER _000000000_ensure_update_form_id 
 BEFORE UPDATE ON dashboard_public.user_forms 
 FOR EACH ROW
 WHEN ( old.form_id IS DISTINCT FROM new.form_id OR old.owner_id IS DISTINCT FROM new.owner_id ) 
 EXECUTE PROCEDURE dashboard_private. user_forms_denorm_form_id (  );

ALTER TABLE dashboard_public.user_forms ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.user_forms TO authenticated;

GRANT SELECT ON TABLE dashboard_public.user_forms TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.user_forms TO authenticated;

GRANT DELETE ON TABLE dashboard_public.user_forms TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.user_forms FOR INSERT TO authenticated WITH CHECK ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_sel ON dashboard_public.user_forms FOR SELECT TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_upd ON dashboard_public.user_forms FOR UPDATE TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_del ON dashboard_public.user_forms FOR DELETE TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_sel_admin ON dashboard_public.user_forms FOR SELECT TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000100000000000000000000') = '00000000000100000000000000000000') );

ALTER TABLE dashboard_public.user_questions ADD COLUMN  is_private boolean;

ALTER TABLE dashboard_public.user_answers ADD COLUMN  is_private boolean;

CREATE FUNCTION dashboard_private.user_answers_denorm_private (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  SELECT ref.is_private FROM "dashboard_public".user_questions AS ref WHERE ref.id = new.question_id
  INTO new.is_private;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_private 
 BEFORE INSERT ON dashboard_public.user_answers 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. user_answers_denorm_private (  );

CREATE TRIGGER _000000000_ensure_update_private 
 BEFORE UPDATE ON dashboard_public.user_answers 
 FOR EACH ROW
 WHEN ( old.question_id IS DISTINCT FROM new.question_id OR old.is_private IS DISTINCT FROM new.is_private ) 
 EXECUTE PROCEDURE dashboard_private. user_answers_denorm_private (  );

ALTER TABLE dashboard_public.question_templates ADD COLUMN  is_private boolean;

ALTER POLICY auth_sel_admin ON dashboard_public.user_answers TO authenticated USING ( (owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000100000000000000000000') = '00000000000100000000000000000000')) AND is_private <> FALSE) OR EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000010000000000') = '00000000000000000000010000000000')) );

ALTER TABLE dashboard_public.forms ADD COLUMN  action_id uuid;

ALTER TABLE dashboard_public.forms ADD CONSTRAINT forms_action_id_fkey FOREIGN KEY ( action_id ) REFERENCES dashboard_public.actions ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT forms_action_id_fkey ON dashboard_public.forms IS E'@omit manyToMany';

CREATE INDEX forms_action_id_idx ON dashboard_public.forms ( action_id );

ALTER TABLE dashboard_public.user_forms ADD COLUMN  user_action_id uuid;

ALTER TABLE dashboard_public.user_forms ADD CONSTRAINT user_forms_user_action_id_fkey FOREIGN KEY ( user_action_id ) REFERENCES dashboard_public.user_actions ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_forms_user_action_id_fkey ON dashboard_public.user_forms IS E'@omit manyToMany';

CREATE INDEX user_forms_user_action_id_idx ON dashboard_public.user_forms ( user_action_id );

ALTER TABLE dashboard_public.forms ADD COLUMN  action_item_id uuid;

ALTER TABLE dashboard_public.forms ADD CONSTRAINT forms_action_item_id_fkey FOREIGN KEY ( action_item_id ) REFERENCES dashboard_public.action_items ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT forms_action_item_id_fkey ON dashboard_public.forms IS E'@omit manyToMany';

CREATE INDEX forms_action_item_id_idx ON dashboard_public.forms ( action_item_id );

ALTER TABLE dashboard_public.user_forms ADD COLUMN  user_action_item_id uuid;

ALTER TABLE dashboard_public.user_forms ADD CONSTRAINT user_forms_user_action_item_id_fkey FOREIGN KEY ( user_action_item_id ) REFERENCES dashboard_public.user_action_items ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_forms_user_action_item_id_fkey ON dashboard_public.user_forms IS E'@omit manyToMany';

CREATE INDEX user_forms_user_action_item_id_idx ON dashboard_public.user_forms ( user_action_item_id );

ALTER TABLE dashboard_public.user_answers ADD COLUMN  checkbox boolean;

ALTER TABLE dashboard_public.user_answers ADD COLUMN  media upload;

ALTER TABLE dashboard_public.user_action_items ADD COLUMN  checkbox boolean;

ALTER TABLE dashboard_public.user_action_items ADD COLUMN  image image;

ALTER TABLE dashboard_public.user_action_items ADD COLUMN  numeric numeric;

ALTER TABLE dashboard_public.user_answers ADD COLUMN  complete boolean;

ALTER TABLE dashboard_public.user_answers ADD COLUMN  question_value_id uuid;

ALTER TABLE dashboard_public.user_answers ADD CONSTRAINT user_answers_question_value_id_fkey FOREIGN KEY ( question_value_id ) REFERENCES dashboard_public.question_values ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_answers_question_value_id_fkey ON dashboard_public.user_answers IS E'@omit manyToMany';

CREATE INDEX user_answers_question_value_id_idx ON dashboard_public.user_answers ( question_value_id );

CREATE TABLE dashboard_public.form_questions (
  
);

ALTER TABLE dashboard_public.form_questions DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.form_questions ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.form_questions ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.form_questions ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.form_questions ADD CONSTRAINT form_questions_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.form_questions ADD COLUMN  question_prompt text;

COMMENT ON COLUMN dashboard_public.form_questions.question_prompt IS E'optional prompt override';

ALTER TABLE dashboard_public.form_questions ADD COLUMN  question_order int;

ALTER TABLE dashboard_public.form_questions ALTER COLUMN question_order SET DEFAULT 0;

ALTER TABLE dashboard_public.form_questions ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.form_questions ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.form_questions 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.form_questions ( created_by );

CREATE INDEX ON dashboard_public.form_questions ( updated_by );

ALTER TABLE dashboard_public.form_questions ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.form_questions ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.form_questions ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.form_questions ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.form_questions 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.form_questions ( created_at );

CREATE INDEX ON dashboard_public.form_questions ( updated_at );

ALTER TABLE dashboard_public.form_questions ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.form_questions ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.form_questions ADD CONSTRAINT form_questions_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT form_questions_owner_id_fkey ON dashboard_public.form_questions IS E'@omit manyToMany';

CREATE INDEX form_questions_owner_id_idx ON dashboard_public.form_questions ( owner_id );

ALTER TABLE dashboard_public.form_questions ADD COLUMN  form_id uuid;

ALTER TABLE dashboard_public.form_questions ALTER COLUMN form_id SET NOT NULL;

ALTER TABLE dashboard_public.form_questions ADD CONSTRAINT form_questions_form_id_fkey FOREIGN KEY ( form_id ) REFERENCES dashboard_public.forms ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT form_questions_form_id_fkey ON dashboard_public.form_questions IS E'@manyToManyFieldName forms';

CREATE INDEX form_questions_form_id_idx ON dashboard_public.form_questions ( form_id );

ALTER TABLE dashboard_public.form_questions ADD COLUMN  question_id uuid;

ALTER TABLE dashboard_public.form_questions ALTER COLUMN question_id SET NOT NULL;

ALTER TABLE dashboard_public.form_questions ADD CONSTRAINT form_questions_question_id_fkey FOREIGN KEY ( question_id ) REFERENCES dashboard_public.user_questions ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT form_questions_question_id_fkey ON dashboard_public.form_questions IS E'@manyToManyFieldName questions';

CREATE INDEX form_questions_question_id_idx ON dashboard_public.form_questions ( question_id );

ALTER TABLE dashboard_public.form_questions ADD CONSTRAINT form_questions_form_id_question_id_key UNIQUE ( form_id, question_id );

CREATE INDEX form_questions_question_order_idx ON dashboard_public.form_questions ( question_order );

CREATE TRIGGER form_questions_form_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.form_questions 
 FOR EACH ROW
 WHEN ( old.form_id IS DISTINCT FROM new.form_id AND old.form_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','form_id' );

CREATE TRIGGER form_questions_question_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.form_questions 
 FOR EACH ROW
 WHEN ( old.question_id IS DISTINCT FROM new.question_id AND old.question_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','question_id' );

ALTER TABLE dashboard_public.form_questions ALTER COLUMN owner_id SET DEFAULT uuid_nil();

CREATE FUNCTION dashboard_private.form_questions_denorm_form_id (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  SELECT ref.owner_id FROM "dashboard_public".forms AS ref WHERE ref.id = new.form_id
  INTO new.owner_id;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_form_id 
 BEFORE INSERT ON dashboard_public.form_questions 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. form_questions_denorm_form_id (  );

CREATE TRIGGER _000000000_ensure_update_form_id 
 BEFORE UPDATE ON dashboard_public.form_questions 
 FOR EACH ROW
 WHEN ( old.form_id IS DISTINCT FROM new.form_id OR old.owner_id IS DISTINCT FROM new.owner_id ) 
 EXECUTE PROCEDURE dashboard_private. form_questions_denorm_form_id (  );

ALTER TABLE dashboard_public.form_questions ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.form_questions TO authenticated;

GRANT SELECT ON TABLE dashboard_public.form_questions TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.form_questions TO authenticated;

GRANT DELETE ON TABLE dashboard_public.form_questions TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.form_questions FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_public.form_questions FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000100000000000000000') = '00000000000000100000000000000000')) OR (owner_id IN (SELECT acl.actor_id FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE (acl.actor_id = owner_id AND (acl.permissions & '00000000000000100000000000000000') = '00000000000000100000000000000000')) AND owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000100000000000000000000') = '00000000000100000000000000000000'))) );

CREATE POLICY auth_upd ON dashboard_public.form_questions FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000100000000000000000000') = '00000000000100000000000000000000')) OR EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000100000000000000000') = '00000000000000100000000000000000')) );

CREATE POLICY auth_del ON dashboard_public.form_questions FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000100000000000000000000') = '00000000000100000000000000000000')) OR EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000100000000000000000') = '00000000000000100000000000000000')) );

DROP TABLE IF EXISTS dashboard_public.action_questions CASCADE;

DROP TABLE IF EXISTS dashboard_public.onboarding_questions CASCADE;

ALTER TABLE dashboard_public.user_answers ADD COLUMN  form_id uuid;

ALTER TABLE dashboard_public.user_answers ALTER COLUMN form_id SET NOT NULL;

ALTER TABLE dashboard_public.user_answers ADD CONSTRAINT user_answers_form_id_fkey FOREIGN KEY ( form_id ) REFERENCES dashboard_public.forms ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_answers_form_id_fkey ON dashboard_public.user_answers IS E'@omit manyToMany';

CREATE INDEX user_answers_form_id_idx ON dashboard_public.user_answers ( form_id );

ALTER TABLE dashboard_public.user_answers ADD COLUMN  user_form_id uuid;

ALTER TABLE dashboard_public.user_answers ALTER COLUMN user_form_id SET NOT NULL;

ALTER TABLE dashboard_public.user_answers ADD CONSTRAINT user_answers_user_form_id_fkey FOREIGN KEY ( user_form_id ) REFERENCES dashboard_public.user_forms ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_answers_user_form_id_fkey ON dashboard_public.user_answers IS E'@omit manyToMany';

CREATE INDEX user_answers_user_form_id_idx ON dashboard_public.user_answers ( user_form_id );

ALTER TABLE dashboard_public.user_answers ALTER COLUMN form_id SET DEFAULT uuid_nil();

CREATE FUNCTION dashboard_private.user_answers_denorm_forms (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  SELECT ref.form_id FROM "dashboard_public".user_forms AS ref WHERE ref.id = new.user_form_id
  INTO new.form_id;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_forms 
 BEFORE INSERT ON dashboard_public.user_answers 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. user_answers_denorm_forms (  );

CREATE TRIGGER _000000000_ensure_update_forms 
 BEFORE UPDATE ON dashboard_public.user_answers 
 FOR EACH ROW
 WHEN ( old.user_form_id IS DISTINCT FROM new.user_form_id OR old.form_id IS DISTINCT FROM new.form_id ) 
 EXECUTE PROCEDURE dashboard_private. user_answers_denorm_forms (  );

ALTER TABLE dashboard_public.action_item_types ADD COLUMN  slug citext;

ALTER TABLE dashboard_public.action_item_types ADD COLUMN  field_type text;

ALTER TABLE dashboard_public.action_item_types ADD COLUMN  ref_num serial;

CREATE FUNCTION dashboard_private.action_item_types_slg_slug (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  new.slug = inflection.slugify(new.slug);
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER insert_slg_slug 
 BEFORE INSERT ON dashboard_public.action_item_types 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. action_item_types_slg_slug (  );

CREATE TRIGGER update_slg_slug 
 BEFORE UPDATE ON dashboard_public.action_item_types 
 FOR EACH ROW
 WHEN ( OLD.slug IS DISTINCT FROM NEW.slug ) 
 EXECUTE PROCEDURE dashboard_private. action_item_types_slg_slug (  );

CREATE TRIGGER action_item_types_slug_immutable_tg 
 BEFORE UPDATE ON dashboard_public.action_item_types 
 FOR EACH ROW
 WHEN ( old.slug IS DISTINCT FROM new.slug AND old.slug IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','slug' );

CREATE TRIGGER action_item_types_ref_num_immutable_tg 
 BEFORE UPDATE ON dashboard_public.action_item_types 
 FOR EACH ROW
 WHEN ( old.ref_num IS DISTINCT FROM new.ref_num AND old.ref_num IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','ref_num' );

ALTER TABLE dashboard_public.action_item_types ADD CONSTRAINT action_item_types_slug_key UNIQUE ( slug );

COMMENT ON CONSTRAINT action_item_types_slug_key ON dashboard_public.action_item_types IS E'@omit';

ALTER TABLE dashboard_public.action_item_types ADD CONSTRAINT action_item_types_ref_num_key UNIQUE ( ref_num );

COMMENT ON CONSTRAINT action_item_types_ref_num_key ON dashboard_public.action_item_types IS E'@omit';

CREATE INDEX action_item_types_ref_num_idx ON dashboard_public.action_item_types ( ref_num );

CREATE INDEX action_item_types_slug_idx ON dashboard_public.action_item_types ( slug );

ALTER TABLE dashboard_public.user_actions ADD COLUMN  items_updated timestamptz;

CREATE POLICY anon_sel ON dashboard_public.global_languages FOR SELECT TO anonymous USING ( TRUE );

CREATE POLICY anon_sel ON dashboard_public.language_dictionary FOR SELECT TO anonymous USING ( TRUE );

ALTER TABLE dashboard_public.action_items ADD COLUMN  call_to_action text;

ALTER TABLE dashboard_public.action_items ADD COLUMN  completed_button_text text;

ALTER TABLE dashboard_public.action_items ADD COLUMN  rich_description text;

ALTER TABLE dashboard_public.action_items ADD COLUMN  rich_completion_confirmation text;

ALTER TABLE dashboard_public.action_items ADD COLUMN  image image;

ALTER TABLE dashboard_public.action_items ADD COLUMN  start_date timestamptz;

ALTER TABLE dashboard_public.action_items ADD COLUMN  end_date timestamptz;

ALTER TABLE dashboard_public.form_questions ADD COLUMN  is_required boolean;

ALTER TABLE dashboard_public.user_questions ADD COLUMN  is_required boolean;

ALTER TABLE dashboard_public.user_questions ALTER COLUMN is_required SET DEFAULT FALSE;

UPDATE dashboard_public.user_questions SET is_required = FALSE WHERE is_required IS NULL;

ALTER TABLE dashboard_public.user_questions ALTER COLUMN is_required SET NOT NULL;

ALTER TABLE dashboard_public.user_questions ADD COLUMN  min numeric;

ALTER TABLE dashboard_public.user_questions ADD COLUMN  max numeric;

ALTER TABLE dashboard_public.user_questions ADD COLUMN  pattern text;

ALTER TABLE dashboard_public.question_templates ADD COLUMN  is_required boolean;

ALTER TABLE dashboard_public.question_templates ALTER COLUMN is_required SET DEFAULT FALSE;

UPDATE dashboard_public.question_templates SET is_required = FALSE WHERE is_required IS NULL;

ALTER TABLE dashboard_public.question_templates ALTER COLUMN is_required SET NOT NULL;

ALTER TABLE dashboard_public.question_templates ADD COLUMN  min numeric;

ALTER TABLE dashboard_public.question_templates ADD COLUMN  max numeric;

ALTER TABLE dashboard_public.question_templates ADD COLUMN  pattern text;

ALTER TABLE dashboard_public.user_settings ALTER COLUMN lang_code SET DEFAULT 'en';

UPDATE dashboard_public.user_settings SET lang_code = 'en' WHERE lang_code IS NULL;

ALTER TABLE dashboard_public.user_settings ALTER COLUMN lang_code SET NOT NULL;

ALTER TABLE dashboard_public.question_templates ALTER COLUMN is_reusable SET DEFAULT FALSE;

COMMENT ON COLUMN dashboard_public.question_templates.is_reusable IS E'for recurring if value can be re-used';

ALTER TABLE dashboard_public.question_templates ALTER COLUMN is_private SET DEFAULT FALSE;

ALTER TABLE dashboard_public.user_questions ALTER COLUMN is_reusable SET DEFAULT FALSE;

COMMENT ON COLUMN dashboard_public.user_questions.is_reusable IS E'for recurring if value can be re-used';

ALTER TABLE dashboard_public.user_questions ALTER COLUMN is_private SET DEFAULT FALSE;

ALTER TABLE dashboard_public.user_answers ALTER COLUMN is_private SET DEFAULT FALSE;

ALTER TABLE dashboard_public.user_answers ALTER COLUMN complete SET DEFAULT FALSE;

COMMENT ON COLUMN dashboard_public.action_item_types.field_type IS E'e.g. text, numeric, location, etc.';

CREATE TABLE dashboard_public.app_constants (
  
);

ALTER TABLE dashboard_public.app_constants DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.app_constants ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.app_constants ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.app_constants ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.app_constants ADD CONSTRAINT app_constants_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.app_constants ADD COLUMN  name citext;

ALTER TABLE dashboard_public.app_constants ADD COLUMN  value json;

ALTER TABLE dashboard_public.app_constants ADD COLUMN  ref_num serial;

ALTER TABLE dashboard_public.app_constants ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.app_constants ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.app_constants 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.app_constants ( created_by );

CREATE INDEX ON dashboard_public.app_constants ( updated_by );

ALTER TABLE dashboard_public.app_constants ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.app_constants ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.app_constants ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.app_constants ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.app_constants 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.app_constants ( created_at );

CREATE INDEX ON dashboard_public.app_constants ( updated_at );

ALTER TABLE dashboard_public.app_constants ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.app_constants TO authenticated;

GRANT SELECT ON TABLE dashboard_public.app_constants TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.app_constants TO authenticated;

GRANT DELETE ON TABLE dashboard_public.app_constants TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.app_constants FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_upd ON dashboard_public.app_constants FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_del ON dashboard_public.app_constants FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_sel ON dashboard_public.app_constants FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY anon_sel ON dashboard_public.app_constants FOR SELECT TO anonymous USING ( TRUE );

CREATE FUNCTION dashboard_private.app_constants_slg_name (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  new.name = inflection.slugify(new.name);
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER insert_slg_name 
 BEFORE INSERT ON dashboard_public.app_constants 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. app_constants_slg_name (  );

CREATE TRIGGER update_slg_name 
 BEFORE UPDATE ON dashboard_public.app_constants 
 FOR EACH ROW
 WHEN ( OLD.name IS DISTINCT FROM NEW.name ) 
 EXECUTE PROCEDURE dashboard_private. app_constants_slg_name (  );

ALTER TABLE dashboard_public.app_constants ADD CONSTRAINT app_constants_name_key UNIQUE ( name );

COMMENT ON CONSTRAINT app_constants_name_key ON dashboard_public.app_constants IS E'@omit';

CREATE TRIGGER app_constants_ref_num_immutable_tg 
 BEFORE UPDATE ON dashboard_public.app_constants 
 FOR EACH ROW
 WHEN ( old.ref_num IS DISTINCT FROM new.ref_num AND old.ref_num IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','ref_num' );

ALTER TABLE dashboard_public.app_constants ADD CONSTRAINT app_constants_ref_num_key UNIQUE ( ref_num );

COMMENT ON CONSTRAINT app_constants_ref_num_key ON dashboard_public.app_constants IS E'@omit';

INSERT INTO dashboard_public.app_constants ( name, value ) VALUES ('ios-version', '{"version":"v1.0.0"}'::json), ('android-version', '{"version":"v1.0.0"}'::json);

ALTER TABLE dashboard_public.question_types ADD COLUMN  ui_hint text;

CREATE FUNCTION dashboard_private.question_types_slg_ui_hint (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  new.ui_hint = inflection.slugify(new.ui_hint);
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER insert_slg_ui_hint 
 BEFORE INSERT ON dashboard_public.question_types 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. question_types_slg_ui_hint (  );

CREATE TRIGGER update_slg_ui_hint 
 BEFORE UPDATE ON dashboard_public.question_types 
 FOR EACH ROW
 WHEN ( OLD.ui_hint IS DISTINCT FROM NEW.ui_hint ) 
 EXECUTE PROCEDURE dashboard_private. question_types_slg_ui_hint (  );

CREATE INDEX action_items_start_date_idx ON dashboard_public.action_items ( start_date );

CREATE INDEX action_items_end_date_idx ON dashboard_public.action_items ( end_date );

CREATE INDEX action_items_start_date_end_date_idx ON dashboard_public.action_items ( start_date, end_date );

ALTER TABLE dashboard_public.action_items ADD COLUMN  unit_id uuid;

ALTER TABLE dashboard_public.action_items ADD CONSTRAINT action_items_unit_id_fkey FOREIGN KEY ( unit_id ) REFERENCES dashboard_public.units ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT action_items_unit_id_fkey ON dashboard_public.action_items IS E'@omit manyToMany';

CREATE INDEX action_items_unit_id_idx ON dashboard_public.action_items ( unit_id );

ALTER TABLE dashboard_public.user_action_items ADD COLUMN  datetime timestamptz;

ALTER TABLE dashboard_public.user_action_items ADD COLUMN  unit_id uuid;

ALTER TABLE dashboard_public.user_action_items ADD CONSTRAINT user_action_items_unit_id_fkey FOREIGN KEY ( unit_id ) REFERENCES dashboard_public.units ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_action_items_unit_id_fkey ON dashboard_public.user_action_items IS E'@omit manyToMany';

CREATE INDEX user_action_items_unit_id_idx ON dashboard_public.user_action_items ( unit_id );

CREATE INDEX user_action_items_action_id_unit_id_idx ON dashboard_public.user_action_items ( action_id, unit_id );

ALTER TABLE dashboard_public.user_action_items ALTER COLUMN unit_id SET DEFAULT uuid_nil();

CREATE FUNCTION dashboard_private.user_action_items_denorm_action_item_id (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  IF (NEW.action_item_id IS NOT NULL) THEN
   SELECT ref.unit_id FROM "dashboard_public".action_items AS ref WHERE ref.id = new.action_item_id
   INTO new.unit_id;
  END IF;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000001_ensure_insert_action_item_id 
 BEFORE INSERT ON dashboard_public.user_action_items 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. user_action_items_denorm_action_item_id (  );

CREATE TRIGGER _000000001_ensure_update_action_item_id 
 BEFORE UPDATE ON dashboard_public.user_action_items 
 FOR EACH ROW
 WHEN ( old.action_item_id IS DISTINCT FROM new.action_item_id OR old.unit_id IS DISTINCT FROM new.unit_id ) 
 EXECUTE PROCEDURE dashboard_private. user_action_items_denorm_action_item_id (  );

GRANT INSERT ( user_id, action_id, object_id, user_rating, action_started, complete, location ) ON TABLE dashboard_public.user_actions TO authenticated;

GRANT UPDATE ( object_id, user_rating, rejected, user_rating, action_started, items_updated, complete, location ) ON TABLE dashboard_public.user_actions TO authenticated;

ALTER TABLE dashboard_public.user_answers ADD COLUMN  boolean boolean;

ALTER TABLE dashboard_public.user_action_items ADD COLUMN  boolean boolean;

ALTER TABLE dashboard_public.question_values ADD COLUMN  boolean boolean;

ALTER TABLE dashboard_public.tracks ADD COLUMN  data_tags citext[];

CREATE INDEX tracks_data_tags_idx ON dashboard_public.tracks USING GIN ( data_tags );

CREATE TABLE dashboard_public.organization_profile_variations (
  
);

ALTER TABLE dashboard_public.organization_profile_variations DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.organization_profile_variations ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.organization_profile_variations ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.organization_profile_variations ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.organization_profile_variations ADD CONSTRAINT organization_profile_variations_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.organization_profile_variations ADD COLUMN  lang_code citext;

ALTER TABLE dashboard_public.organization_profile_variations ADD CONSTRAINT organization_profile_variations_lang_code_chk CHECK ( character_length(lang_code) <= 10 );

ALTER TABLE dashboard_public.organization_profile_variations ADD COLUMN  name text;

ALTER TABLE dashboard_public.organization_profile_variations ADD COLUMN  description text;

ALTER TABLE dashboard_public.organization_profile_variations ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.organization_profile_variations ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.organization_profile_variations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.organization_profile_variations ( created_by );

CREATE INDEX ON dashboard_public.organization_profile_variations ( updated_by );

ALTER TABLE dashboard_public.organization_profile_variations ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.organization_profile_variations ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.organization_profile_variations ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.organization_profile_variations ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.organization_profile_variations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.organization_profile_variations ( created_at );

CREATE INDEX ON dashboard_public.organization_profile_variations ( updated_at );

COMMENT ON TABLE dashboard_public.organization_profiles IS E'@i18n organization_profile_variations';

ALTER TABLE dashboard_public.organization_profile_variations ADD COLUMN  organization_id uuid;

ALTER TABLE dashboard_public.organization_profile_variations ALTER COLUMN organization_id SET NOT NULL;

ALTER TABLE dashboard_public.organization_profile_variations ADD CONSTRAINT organization_profile_variations_organization_id_fkey FOREIGN KEY ( organization_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT organization_profile_variations_organization_id_fkey ON dashboard_public.organization_profile_variations IS E'@omit manyToMany';

CREATE INDEX organization_profile_variations_organization_id_idx ON dashboard_public.organization_profile_variations ( organization_id );

CREATE TRIGGER organization_profile_variations_organization_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.organization_profile_variations 
 FOR EACH ROW
 WHEN ( old.organization_id IS DISTINCT FROM new.organization_id AND old.organization_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','organization_id' );

ALTER TABLE dashboard_public.organization_profile_variations ADD COLUMN  organization_profile_id uuid;

ALTER TABLE dashboard_public.organization_profile_variations ALTER COLUMN organization_profile_id SET NOT NULL;

ALTER TABLE dashboard_public.organization_profile_variations ADD CONSTRAINT organization_profile_variations_organization_profile_id_fkey FOREIGN KEY ( organization_profile_id ) REFERENCES dashboard_public.organization_profiles ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT organization_profile_variations_organization_profile_id_fkey ON dashboard_public.organization_profile_variations IS E'@omit manyToMany';

CREATE INDEX organization_profile_variations_organization_profile_id_idx ON dashboard_public.organization_profile_variations ( organization_profile_id );

CREATE TRIGGER organization_profile_variations_organization_profile_id_immutab 
 BEFORE UPDATE ON dashboard_public.organization_profile_variations 
 FOR EACH ROW
 WHEN ( old.organization_profile_id IS DISTINCT FROM new.organization_profile_id AND old.organization_profile_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','organization_profile_id' );

ALTER TABLE dashboard_public.organization_profile_variations ALTER COLUMN organization_id SET DEFAULT uuid_nil();

CREATE FUNCTION dashboard_private.organization_profile_variations_denorm_organization_profile_id (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  IF (NEW.organization_profile_id IS NOT NULL) THEN
   SELECT ref.organization_id FROM "dashboard_public".organization_profiles AS ref WHERE ref.id = new.organization_profile_id
   INTO new.organization_id;
  END IF;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_organization_profile_id 
 BEFORE INSERT ON dashboard_public.organization_profile_variations 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. organization_profile_variations_denorm_organization_profile_id (  );

CREATE TRIGGER _000000000_ensure_update_organization_profile_id 
 BEFORE UPDATE ON dashboard_public.organization_profile_variations 
 FOR EACH ROW
 WHEN ( old.organization_profile_id IS DISTINCT FROM new.organization_profile_id OR old.organization_id IS DISTINCT FROM new.organization_id ) 
 EXECUTE PROCEDURE dashboard_private. organization_profile_variations_denorm_organization_profile_id (  );

ALTER TABLE dashboard_public.organization_profile_variations ADD CONSTRAINT organization_profile_variations_lang_code_organization_profile_ UNIQUE ( lang_code, organization_profile_id );

COMMENT ON CONSTRAINT organization_profile_variations_lang_code_organization_profile_ ON dashboard_public.organization_profile_variations IS NULL;

CREATE FUNCTION dashboard_private.organization_profile_variations_slg_lang_code (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  new.lang_code = inflection.slugify(new.lang_code);
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER insert_slg_lang_code 
 BEFORE INSERT ON dashboard_public.organization_profile_variations 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. organization_profile_variations_slg_lang_code (  );

CREATE TRIGGER update_slg_lang_code 
 BEFORE UPDATE ON dashboard_public.organization_profile_variations 
 FOR EACH ROW
 WHEN ( OLD.lang_code IS DISTINCT FROM NEW.lang_code ) 
 EXECUTE PROCEDURE dashboard_private. organization_profile_variations_slg_lang_code (  );

CREATE INDEX organization_profile_variations_lang_code_idx ON dashboard_public.organization_profile_variations ( lang_code );

ALTER TABLE dashboard_public.organization_profile_variations ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.organization_profile_variations TO authenticated;

GRANT SELECT ON TABLE dashboard_public.organization_profile_variations TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.organization_profile_variations TO authenticated;

GRANT DELETE ON TABLE dashboard_public.organization_profile_variations TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.organization_profile_variations FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_public.organization_profile_variations FOR INSERT TO authenticated WITH CHECK ( organization_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000001000000000000') = '00000000000000000001000000000000') );

CREATE POLICY auth_upd ON dashboard_public.organization_profile_variations FOR UPDATE TO authenticated USING ( organization_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000001000000000000') = '00000000000000000001000000000000') );

CREATE POLICY auth_del ON dashboard_public.organization_profile_variations FOR DELETE TO authenticated USING ( organization_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000001000000000000') = '00000000000000000001000000000000') );

CREATE TABLE dashboard_public.action_item_language_variations (
  
);

ALTER TABLE dashboard_public.action_item_language_variations DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.action_item_language_variations ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.action_item_language_variations ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.action_item_language_variations ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.action_item_language_variations ADD CONSTRAINT action_item_language_variations_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.action_item_language_variations ADD COLUMN  lang_code citext;

ALTER TABLE dashboard_public.action_item_language_variations ADD CONSTRAINT action_item_language_variations_lang_code_chk CHECK ( character_length(lang_code) <= 10 );

ALTER TABLE dashboard_public.action_item_language_variations ADD COLUMN  name text;

ALTER TABLE dashboard_public.action_item_language_variations ADD COLUMN  description text;

ALTER TABLE dashboard_public.action_item_language_variations ADD COLUMN  notification_text text;

ALTER TABLE dashboard_public.action_item_language_variations ADD COLUMN  call_to_action text;

ALTER TABLE dashboard_public.action_item_language_variations ADD COLUMN  completed_button_text text;

ALTER TABLE dashboard_public.action_item_language_variations ADD COLUMN  rich_description text;

ALTER TABLE dashboard_public.action_item_language_variations ADD COLUMN  rich_completion_confirmation text;

ALTER TABLE dashboard_public.action_item_language_variations ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.action_item_language_variations ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.action_item_language_variations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.action_item_language_variations ( created_by );

CREATE INDEX ON dashboard_public.action_item_language_variations ( updated_by );

ALTER TABLE dashboard_public.action_item_language_variations ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.action_item_language_variations ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.action_item_language_variations ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.action_item_language_variations ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.action_item_language_variations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.action_item_language_variations ( created_at );

CREATE INDEX ON dashboard_public.action_item_language_variations ( updated_at );

COMMENT ON TABLE dashboard_public.action_items IS E'@i18n action_item_language_variations';

ALTER TABLE dashboard_public.action_item_language_variations ADD COLUMN  action_item_id uuid;

ALTER TABLE dashboard_public.action_item_language_variations ALTER COLUMN action_item_id SET NOT NULL;

ALTER TABLE dashboard_public.action_item_language_variations ADD CONSTRAINT action_item_language_variations_action_item_id_fkey FOREIGN KEY ( action_item_id ) REFERENCES dashboard_public.action_items ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT action_item_language_variations_action_item_id_fkey ON dashboard_public.action_item_language_variations IS E'@omit manyToMany';

CREATE INDEX action_item_language_variations_action_item_id_idx ON dashboard_public.action_item_language_variations ( action_item_id );

ALTER TABLE dashboard_public.action_item_language_variations ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.action_item_language_variations ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.action_item_language_variations ADD CONSTRAINT action_item_language_variations_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT action_item_language_variations_owner_id_fkey ON dashboard_public.action_item_language_variations IS E'@omit manyToMany';

CREATE INDEX action_item_language_variations_owner_id_idx ON dashboard_public.action_item_language_variations ( owner_id );

ALTER TABLE dashboard_public.action_item_language_variations ADD CONSTRAINT action_item_language_variations_action_item_id_lang_code_key UNIQUE ( action_item_id, lang_code );

COMMENT ON CONSTRAINT action_item_language_variations_action_item_id_lang_code_key ON dashboard_public.action_item_language_variations IS E'@omit';

CREATE INDEX action_item_language_variations_lang_code_idx ON dashboard_public.action_item_language_variations ( lang_code );

CREATE TRIGGER action_item_language_variations_owner_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.action_item_language_variations 
 FOR EACH ROW
 WHEN ( old.owner_id IS DISTINCT FROM new.owner_id AND old.owner_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','owner_id' );

ALTER TABLE dashboard_public.action_item_language_variations ALTER COLUMN owner_id SET DEFAULT uuid_nil();

CREATE FUNCTION dashboard_private.action_item_language_variations_denorm_action_item_id (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  IF (NEW.action_item_id IS NOT NULL) THEN
   SELECT ref.owner_id FROM "dashboard_public".action_items AS ref WHERE ref.id = new.action_item_id
   INTO new.owner_id;
  END IF;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_action_item_id 
 BEFORE INSERT ON dashboard_public.action_item_language_variations 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. action_item_language_variations_denorm_action_item_id (  );

CREATE TRIGGER _000000000_ensure_update_action_item_id 
 BEFORE UPDATE ON dashboard_public.action_item_language_variations 
 FOR EACH ROW
 WHEN ( old.action_item_id IS DISTINCT FROM new.action_item_id OR old.owner_id IS DISTINCT FROM new.owner_id ) 
 EXECUTE PROCEDURE dashboard_private. action_item_language_variations_denorm_action_item_id (  );

ALTER TABLE dashboard_public.action_item_language_variations ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.action_item_language_variations TO authenticated;

GRANT SELECT ON TABLE dashboard_public.action_item_language_variations TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.action_item_language_variations TO authenticated;

GRANT DELETE ON TABLE dashboard_public.action_item_language_variations TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.action_item_language_variations FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_public.action_item_language_variations FOR INSERT TO authenticated WITH CHECK ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE POLICY auth_upd ON dashboard_public.action_item_language_variations FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE POLICY auth_del ON dashboard_public.action_item_language_variations FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE TABLE dashboard_public.track_language_variations (
  
);

ALTER TABLE dashboard_public.track_language_variations DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.track_language_variations ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.track_language_variations ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.track_language_variations ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.track_language_variations ADD CONSTRAINT track_language_variations_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.track_language_variations ADD COLUMN  lang_code citext;

ALTER TABLE dashboard_public.track_language_variations ADD CONSTRAINT track_language_variations_lang_code_chk CHECK ( character_length(lang_code) <= 10 );

ALTER TABLE dashboard_public.track_language_variations ADD COLUMN  name text;

ALTER TABLE dashboard_public.track_language_variations ADD COLUMN  description text;

ALTER TABLE dashboard_public.track_language_variations ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.track_language_variations ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.track_language_variations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.track_language_variations ( created_by );

CREATE INDEX ON dashboard_public.track_language_variations ( updated_by );

ALTER TABLE dashboard_public.track_language_variations ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.track_language_variations ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.track_language_variations ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.track_language_variations ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.track_language_variations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.track_language_variations ( created_at );

CREATE INDEX ON dashboard_public.track_language_variations ( updated_at );

COMMENT ON TABLE dashboard_public.tracks IS E'@i18n track_language_variations';

ALTER TABLE dashboard_public.track_language_variations ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.track_language_variations ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.track_language_variations ADD CONSTRAINT track_language_variations_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT track_language_variations_owner_id_fkey ON dashboard_public.track_language_variations IS E'@omit manyToMany';

CREATE INDEX track_language_variations_owner_id_idx ON dashboard_public.track_language_variations ( owner_id );

ALTER TABLE dashboard_public.track_language_variations ADD COLUMN  track_id uuid;

ALTER TABLE dashboard_public.track_language_variations ALTER COLUMN track_id SET NOT NULL;

ALTER TABLE dashboard_public.track_language_variations ADD CONSTRAINT track_language_variations_track_id_fkey FOREIGN KEY ( track_id ) REFERENCES dashboard_public.tracks ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT track_language_variations_track_id_fkey ON dashboard_public.track_language_variations IS E'@omit manyToMany';

CREATE INDEX track_language_variations_track_id_idx ON dashboard_public.track_language_variations ( track_id );

ALTER TABLE dashboard_public.track_language_variations ALTER COLUMN owner_id SET DEFAULT uuid_nil();

CREATE FUNCTION dashboard_private.track_language_variations_denorm_track_id (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  IF (NEW.track_id IS NOT NULL) THEN
   SELECT ref.owner_id FROM "dashboard_public".tracks AS ref WHERE ref.id = new.track_id
   INTO new.owner_id;
  END IF;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_track_id 
 BEFORE INSERT ON dashboard_public.track_language_variations 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. track_language_variations_denorm_track_id (  );

CREATE TRIGGER _000000000_ensure_update_track_id 
 BEFORE UPDATE ON dashboard_public.track_language_variations 
 FOR EACH ROW
 WHEN ( old.track_id IS DISTINCT FROM new.track_id OR old.owner_id IS DISTINCT FROM new.owner_id ) 
 EXECUTE PROCEDURE dashboard_private. track_language_variations_denorm_track_id (  );

ALTER TABLE dashboard_public.track_language_variations ADD CONSTRAINT track_language_variations_track_id_lang_code_key UNIQUE ( track_id, lang_code );

COMMENT ON CONSTRAINT track_language_variations_track_id_lang_code_key ON dashboard_public.track_language_variations IS E'@omit';

CREATE INDEX track_language_variations_name_idx ON dashboard_public.track_language_variations ( name );

ALTER TABLE dashboard_public.track_language_variations ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.track_language_variations TO authenticated;

GRANT SELECT ON TABLE dashboard_public.track_language_variations TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.track_language_variations TO authenticated;

GRANT DELETE ON TABLE dashboard_public.track_language_variations TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.track_language_variations FOR INSERT TO authenticated WITH CHECK ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE POLICY auth_upd ON dashboard_public.track_language_variations FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE POLICY auth_del ON dashboard_public.track_language_variations FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE POLICY auth_sel ON dashboard_public.track_language_variations FOR SELECT TO authenticated USING ( TRUE );

CREATE TABLE dashboard_public.user_question_language_variations (
  
);

ALTER TABLE dashboard_public.user_question_language_variations DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.user_question_language_variations ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.user_question_language_variations ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.user_question_language_variations ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.user_question_language_variations ADD CONSTRAINT user_question_language_variations_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.user_question_language_variations ADD COLUMN  lang_code citext;

ALTER TABLE dashboard_public.user_question_language_variations ADD CONSTRAINT user_question_language_variations_lang_code_chk CHECK ( character_length(lang_code) <= 10 );

ALTER TABLE dashboard_public.user_question_language_variations ADD COLUMN  question_prompt text;

ALTER TABLE dashboard_public.user_question_language_variations ADD COLUMN  description text;

ALTER TABLE dashboard_public.user_question_language_variations ADD COLUMN  rich_description text;

ALTER TABLE dashboard_public.user_question_language_variations ADD COLUMN  label text;

ALTER TABLE dashboard_public.user_question_language_variations ADD COLUMN  help_text text;

ALTER TABLE dashboard_public.user_question_language_variations ADD COLUMN  placeholder text;

ALTER TABLE dashboard_public.user_question_language_variations ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.user_question_language_variations ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_question_language_variations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.user_question_language_variations ( created_by );

CREATE INDEX ON dashboard_public.user_question_language_variations ( updated_by );

ALTER TABLE dashboard_public.user_question_language_variations ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.user_question_language_variations ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.user_question_language_variations ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.user_question_language_variations ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_question_language_variations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.user_question_language_variations ( created_at );

CREATE INDEX ON dashboard_public.user_question_language_variations ( updated_at );

COMMENT ON TABLE dashboard_public.user_questions IS E'@i18n user_question_language_variations';

ALTER TABLE dashboard_public.user_question_language_variations ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.user_question_language_variations ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.user_question_language_variations ADD CONSTRAINT user_question_language_variations_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_question_language_variations_owner_id_fkey ON dashboard_public.user_question_language_variations IS E'@omit manyToMany';

CREATE INDEX user_question_language_variations_owner_id_idx ON dashboard_public.user_question_language_variations ( owner_id );

ALTER TABLE dashboard_public.user_question_language_variations ADD COLUMN  user_question_id uuid;

ALTER TABLE dashboard_public.user_question_language_variations ALTER COLUMN user_question_id SET NOT NULL;

ALTER TABLE dashboard_public.user_question_language_variations ADD CONSTRAINT user_question_language_variations_user_question_id_fkey FOREIGN KEY ( user_question_id ) REFERENCES dashboard_public.user_questions ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_question_language_variations_user_question_id_fkey ON dashboard_public.user_question_language_variations IS E'@omit manyToMany';

CREATE INDEX user_question_language_variations_user_question_id_idx ON dashboard_public.user_question_language_variations ( user_question_id );

ALTER TABLE dashboard_public.user_question_language_variations ALTER COLUMN owner_id SET DEFAULT uuid_nil();

CREATE FUNCTION dashboard_private.user_question_language_variations_denorm_user_question_id (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  IF (NEW.user_question_id IS NOT NULL) THEN
   SELECT ref.owner_id FROM "dashboard_public".user_questions AS ref WHERE ref.id = new.user_question_id
   INTO new.owner_id;
  END IF;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_user_question_id 
 BEFORE INSERT ON dashboard_public.user_question_language_variations 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. user_question_language_variations_denorm_user_question_id (  );

CREATE TRIGGER _000000000_ensure_update_user_question_id 
 BEFORE UPDATE ON dashboard_public.user_question_language_variations 
 FOR EACH ROW
 WHEN ( old.user_question_id IS DISTINCT FROM new.user_question_id OR old.owner_id IS DISTINCT FROM new.owner_id ) 
 EXECUTE PROCEDURE dashboard_private. user_question_language_variations_denorm_user_question_id (  );

ALTER TABLE dashboard_public.user_question_language_variations ADD CONSTRAINT user_question_language_variations_user_question_id_lang_code_ke UNIQUE ( user_question_id, lang_code );

COMMENT ON CONSTRAINT user_question_language_variations_user_question_id_lang_code_ke ON dashboard_public.user_question_language_variations IS E'@omit';

ALTER TABLE dashboard_public.user_question_language_variations ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.user_question_language_variations TO authenticated;

GRANT SELECT ON TABLE dashboard_public.user_question_language_variations TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.user_question_language_variations TO authenticated;

GRANT DELETE ON TABLE dashboard_public.user_question_language_variations TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.user_question_language_variations FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_public.user_question_language_variations FOR INSERT TO authenticated WITH CHECK ( owner_id IN (SELECT acl.actor_id FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE (acl.actor_id = owner_id AND (acl.permissions & '00000000000000100000000000000000') = '00000000000000100000000000000000')) AND owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000100000000000000000000') = '00000000000100000000000000000000')) );

CREATE POLICY auth_upd ON dashboard_public.user_question_language_variations FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000100000000000000000000') = '00000000000100000000000000000000') );

CREATE POLICY auth_del ON dashboard_public.user_question_language_variations FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000100000000000000000000') = '00000000000100000000000000000000') );

CREATE TABLE dashboard_public.question_value_language_variations (
  
);

ALTER TABLE dashboard_public.question_value_language_variations DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.question_value_language_variations ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.question_value_language_variations ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.question_value_language_variations ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.question_value_language_variations ADD CONSTRAINT question_value_language_variations_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.question_value_language_variations ADD COLUMN  lang_code citext;

ALTER TABLE dashboard_public.question_value_language_variations ADD CONSTRAINT question_value_language_variations_lang_code_chk CHECK ( character_length(lang_code) <= 10 );

ALTER TABLE dashboard_public.question_value_language_variations ADD COLUMN  name text;

ALTER TABLE dashboard_public.question_value_language_variations ADD COLUMN  description text;

ALTER TABLE dashboard_public.question_value_language_variations ADD COLUMN  rich_description text;

ALTER TABLE dashboard_public.question_value_language_variations ADD COLUMN  text text;

ALTER TABLE dashboard_public.question_value_language_variations ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.question_value_language_variations ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.question_value_language_variations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.question_value_language_variations ( created_by );

CREATE INDEX ON dashboard_public.question_value_language_variations ( updated_by );

ALTER TABLE dashboard_public.question_value_language_variations ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.question_value_language_variations ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.question_value_language_variations ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.question_value_language_variations ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.question_value_language_variations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.question_value_language_variations ( created_at );

CREATE INDEX ON dashboard_public.question_value_language_variations ( updated_at );

COMMENT ON TABLE dashboard_public.question_values IS E'@i18n question_value_language_variations';

ALTER TABLE dashboard_public.question_value_language_variations ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.question_value_language_variations ADD CONSTRAINT question_value_language_variations_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT question_value_language_variations_owner_id_fkey ON dashboard_public.question_value_language_variations IS E'@omit manyToMany';

CREATE INDEX question_value_language_variations_owner_id_idx ON dashboard_public.question_value_language_variations ( owner_id );

ALTER TABLE dashboard_public.question_value_language_variations ADD COLUMN  question_value_id uuid;

ALTER TABLE dashboard_public.question_value_language_variations ALTER COLUMN question_value_id SET NOT NULL;

ALTER TABLE dashboard_public.question_value_language_variations ADD CONSTRAINT question_value_language_variations_question_value_id_fkey FOREIGN KEY ( question_value_id ) REFERENCES dashboard_public.question_values ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT question_value_language_variations_question_value_id_fkey ON dashboard_public.question_value_language_variations IS E'@omit manyToMany';

CREATE INDEX question_value_language_variations_question_value_id_idx ON dashboard_public.question_value_language_variations ( question_value_id );

ALTER TABLE dashboard_public.question_value_language_variations ALTER COLUMN owner_id SET DEFAULT uuid_nil();

CREATE FUNCTION dashboard_private.question_value_language_variations_denorm_question_value_id (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  IF (NEW.question_value_id IS NOT NULL) THEN
   SELECT ref.owner_id FROM "dashboard_public".question_values AS ref WHERE ref.id = new.question_value_id
   INTO new.owner_id;
  END IF;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_question_value_id 
 BEFORE INSERT ON dashboard_public.question_value_language_variations 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. question_value_language_variations_denorm_question_value_id (  );

CREATE TRIGGER _000000000_ensure_update_question_value_id 
 BEFORE UPDATE ON dashboard_public.question_value_language_variations 
 FOR EACH ROW
 WHEN ( old.question_value_id IS DISTINCT FROM new.question_value_id OR old.owner_id IS DISTINCT FROM new.owner_id ) 
 EXECUTE PROCEDURE dashboard_private. question_value_language_variations_denorm_question_value_id (  );

ALTER TABLE dashboard_public.question_value_language_variations ADD CONSTRAINT question_value_language_variations_question_value_id_lang_code_ UNIQUE ( question_value_id, lang_code );

COMMENT ON CONSTRAINT question_value_language_variations_question_value_id_lang_code_ ON dashboard_public.question_value_language_variations IS E'@omit';

ALTER TABLE dashboard_public.question_value_language_variations ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.question_value_language_variations TO authenticated;

GRANT SELECT ON TABLE dashboard_public.question_value_language_variations TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.question_value_language_variations TO authenticated;

GRANT DELETE ON TABLE dashboard_public.question_value_language_variations TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.question_value_language_variations FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_public.question_value_language_variations FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000100000000000000000') = '00000000000000100000000000000000')) OR (owner_id IN (SELECT acl.actor_id FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE (acl.actor_id = owner_id AND (acl.permissions & '00000000000000100000000000000000') = '00000000000000100000000000000000')) AND owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000100000000000000000000') = '00000000000100000000000000000000'))) );

CREATE POLICY auth_upd ON dashboard_public.question_value_language_variations FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000100000000000000000000') = '00000000000100000000000000000000')) OR EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000100000000000000000') = '00000000000000100000000000000000')) );

CREATE POLICY auth_del ON dashboard_public.question_value_language_variations FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000100000000000000000000') = '00000000000100000000000000000000')) OR EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000100000000000000000') = '00000000000000100000000000000000')) );

CREATE TABLE dashboard_public.question_template_language_variations (
  
);

ALTER TABLE dashboard_public.question_template_language_variations DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.question_template_language_variations ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.question_template_language_variations ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.question_template_language_variations ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.question_template_language_variations ADD CONSTRAINT question_template_language_variations_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.question_template_language_variations ADD COLUMN  lang_code citext;

ALTER TABLE dashboard_public.question_template_language_variations ADD CONSTRAINT question_template_language_variations_lang_code_chk CHECK ( character_length(lang_code) <= 10 );

ALTER TABLE dashboard_public.question_template_language_variations ADD COLUMN  question_prompt text;

ALTER TABLE dashboard_public.question_template_language_variations ADD COLUMN  description text;

ALTER TABLE dashboard_public.question_template_language_variations ADD COLUMN  rich_description text;

ALTER TABLE dashboard_public.question_template_language_variations ADD COLUMN  label text;

ALTER TABLE dashboard_public.question_template_language_variations ADD COLUMN  help_text text;

ALTER TABLE dashboard_public.question_template_language_variations ADD COLUMN  placeholder text;

ALTER TABLE dashboard_public.question_template_language_variations ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.question_template_language_variations ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.question_template_language_variations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.question_template_language_variations ( created_by );

CREATE INDEX ON dashboard_public.question_template_language_variations ( updated_by );

ALTER TABLE dashboard_public.question_template_language_variations ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.question_template_language_variations ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.question_template_language_variations ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.question_template_language_variations ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.question_template_language_variations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.question_template_language_variations ( created_at );

CREATE INDEX ON dashboard_public.question_template_language_variations ( updated_at );

COMMENT ON TABLE dashboard_public.question_templates IS E'@i18n question_template_language_variations';

ALTER TABLE dashboard_public.question_template_language_variations ADD COLUMN  question_template_id uuid;

ALTER TABLE dashboard_public.question_template_language_variations ALTER COLUMN question_template_id SET NOT NULL;

ALTER TABLE dashboard_public.question_template_language_variations ADD CONSTRAINT question_template_language_variations_question_template_id_fkey FOREIGN KEY ( question_template_id ) REFERENCES dashboard_public.question_templates ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT question_template_language_variations_question_template_id_fkey ON dashboard_public.question_template_language_variations IS E'@omit manyToMany';

CREATE INDEX question_template_language_variations_question_template_id_idx ON dashboard_public.question_template_language_variations ( question_template_id );

ALTER TABLE dashboard_public.question_template_language_variations ADD CONSTRAINT question_template_language_variations_question_template_id_lang UNIQUE ( question_template_id, lang_code );

COMMENT ON CONSTRAINT question_template_language_variations_question_template_id_lang ON dashboard_public.question_template_language_variations IS E'@omit';

ALTER TABLE dashboard_public.question_template_language_variations ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.question_template_language_variations TO authenticated;

GRANT SELECT ON TABLE dashboard_public.question_template_language_variations TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.question_template_language_variations TO authenticated;

GRANT DELETE ON TABLE dashboard_public.question_template_language_variations TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.question_template_language_variations FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_public.question_template_language_variations FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000100000000000000000') = '00000000000000100000000000000000') );

CREATE POLICY auth_upd ON dashboard_public.question_template_language_variations FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000100000000000000000') = '00000000000000100000000000000000') );

CREATE POLICY auth_del ON dashboard_public.question_template_language_variations FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000100000000000000000') = '00000000000000100000000000000000') );

CREATE TABLE dashboard_public.impact_language_variations (
  
);

ALTER TABLE dashboard_public.impact_language_variations DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.impact_language_variations ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.impact_language_variations ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.impact_language_variations ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.impact_language_variations ADD CONSTRAINT impact_language_variations_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.impact_language_variations ADD COLUMN  lang_code citext;

ALTER TABLE dashboard_public.impact_language_variations ADD CONSTRAINT impact_language_variations_lang_code_chk CHECK ( character_length(lang_code) <= 10 );

ALTER TABLE dashboard_public.impact_language_variations ADD COLUMN  description text;

ALTER TABLE dashboard_public.impact_language_variations ADD COLUMN  rich_description text;

ALTER TABLE dashboard_public.impact_language_variations ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.impact_language_variations ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.impact_language_variations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.impact_language_variations ( created_by );

CREATE INDEX ON dashboard_public.impact_language_variations ( updated_by );

ALTER TABLE dashboard_public.impact_language_variations ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.impact_language_variations ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.impact_language_variations ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.impact_language_variations ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.impact_language_variations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.impact_language_variations ( created_at );

CREATE INDEX ON dashboard_public.impact_language_variations ( updated_at );

COMMENT ON TABLE dashboard_public.impacts IS E'@i18n impact_language_variations';

ALTER TABLE dashboard_public.impact_language_variations ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.impact_language_variations ADD CONSTRAINT impact_language_variations_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT impact_language_variations_owner_id_fkey ON dashboard_public.impact_language_variations IS E'@omit manyToMany';

CREATE INDEX impact_language_variations_owner_id_idx ON dashboard_public.impact_language_variations ( owner_id );

ALTER TABLE dashboard_public.impact_language_variations ADD COLUMN  impact_id uuid;

ALTER TABLE dashboard_public.impact_language_variations ALTER COLUMN impact_id SET NOT NULL;

ALTER TABLE dashboard_public.impact_language_variations ADD CONSTRAINT impact_language_variations_impact_id_fkey FOREIGN KEY ( impact_id ) REFERENCES dashboard_public.impacts ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT impact_language_variations_impact_id_fkey ON dashboard_public.impact_language_variations IS E'@omit manyToMany';

CREATE INDEX impact_language_variations_impact_id_idx ON dashboard_public.impact_language_variations ( impact_id );

ALTER TABLE dashboard_public.impact_language_variations ALTER COLUMN owner_id SET DEFAULT uuid_nil();

CREATE FUNCTION dashboard_private.impact_language_variations_denorm_impact_id (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  IF (NEW.impact_id IS NOT NULL) THEN
   SELECT ref.owner_id FROM "dashboard_public".impacts AS ref WHERE ref.id = new.impact_id
   INTO new.owner_id;
  END IF;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_impact_id 
 BEFORE INSERT ON dashboard_public.impact_language_variations 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. impact_language_variations_denorm_impact_id (  );

CREATE TRIGGER _000000000_ensure_update_impact_id 
 BEFORE UPDATE ON dashboard_public.impact_language_variations 
 FOR EACH ROW
 WHEN ( old.impact_id IS DISTINCT FROM new.impact_id OR old.owner_id IS DISTINCT FROM new.owner_id ) 
 EXECUTE PROCEDURE dashboard_private. impact_language_variations_denorm_impact_id (  );

ALTER TABLE dashboard_public.impact_language_variations ADD CONSTRAINT impact_language_variations_impact_id_lang_code_key UNIQUE ( impact_id, lang_code );

COMMENT ON CONSTRAINT impact_language_variations_impact_id_lang_code_key ON dashboard_public.impact_language_variations IS E'@omit';

ALTER TABLE dashboard_public.impact_language_variations ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.impact_language_variations TO authenticated;

GRANT SELECT ON TABLE dashboard_public.impact_language_variations TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.impact_language_variations TO authenticated;

GRANT DELETE ON TABLE dashboard_public.impact_language_variations TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.impact_language_variations FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_public.impact_language_variations FOR INSERT TO authenticated WITH CHECK ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000010000000000000') = '00000000000000000010000000000000')) AND owner_id IN (SELECT acl.actor_id FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE (acl.actor_id = owner_id AND (acl.permissions & '00000000000000000000100000000000') = '00000000000000000000100000000000')) );

CREATE POLICY auth_upd ON dashboard_public.impact_language_variations FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000')) OR EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE)) );

CREATE POLICY auth_del ON dashboard_public.impact_language_variations FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000')) OR EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND acl.is_admin IS TRUE)) );

CREATE TABLE dashboard_public.object_type_value_language_variations (
  
);

ALTER TABLE dashboard_public.object_type_value_language_variations DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.object_type_value_language_variations ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.object_type_value_language_variations ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.object_type_value_language_variations ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.object_type_value_language_variations ADD CONSTRAINT object_type_value_language_variations_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.object_type_value_language_variations ADD COLUMN  lang_code citext;

ALTER TABLE dashboard_public.object_type_value_language_variations ADD CONSTRAINT object_type_value_language_variations_lang_code_chk CHECK ( character_length(lang_code) <= 10 );

ALTER TABLE dashboard_public.object_type_value_language_variations ADD COLUMN  name citext;

ALTER TABLE dashboard_public.object_type_value_language_variations ADD COLUMN  description text;

ALTER TABLE dashboard_public.object_type_value_language_variations ADD COLUMN  text text;

ALTER TABLE dashboard_public.object_type_value_language_variations ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.object_type_value_language_variations ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.object_type_value_language_variations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.object_type_value_language_variations ( created_by );

CREATE INDEX ON dashboard_public.object_type_value_language_variations ( updated_by );

ALTER TABLE dashboard_public.object_type_value_language_variations ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.object_type_value_language_variations ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.object_type_value_language_variations ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.object_type_value_language_variations ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.object_type_value_language_variations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.object_type_value_language_variations ( created_at );

CREATE INDEX ON dashboard_public.object_type_value_language_variations ( updated_at );

COMMENT ON TABLE dashboard_public.object_type_values IS E'@i18n object_type_value_language_variations';

ALTER TABLE dashboard_public.object_type_value_language_variations ADD COLUMN  object_type_value_id uuid;

ALTER TABLE dashboard_public.object_type_value_language_variations ALTER COLUMN object_type_value_id SET NOT NULL;

ALTER TABLE dashboard_public.object_type_value_language_variations ADD CONSTRAINT object_type_value_language_variations_object_type_value_id_fkey FOREIGN KEY ( object_type_value_id ) REFERENCES dashboard_public.object_type_values ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT object_type_value_language_variations_object_type_value_id_fkey ON dashboard_public.object_type_value_language_variations IS E'@omit manyToMany';

CREATE INDEX object_type_value_language_variations_object_type_value_id_idx ON dashboard_public.object_type_value_language_variations ( object_type_value_id );

ALTER TABLE dashboard_public.object_type_value_language_variations ADD CONSTRAINT object_type_value_language_variations_object_type_value_id_lang UNIQUE ( object_type_value_id, lang_code );

COMMENT ON CONSTRAINT object_type_value_language_variations_object_type_value_id_lang ON dashboard_public.object_type_value_language_variations IS E'@omit';

ALTER TABLE dashboard_public.object_type_value_language_variations ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.object_type_value_language_variations TO authenticated;

GRANT SELECT ON TABLE dashboard_public.object_type_value_language_variations TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.object_type_value_language_variations TO authenticated;

GRANT DELETE ON TABLE dashboard_public.object_type_value_language_variations TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.object_type_value_language_variations FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_public.object_type_value_language_variations FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_upd ON dashboard_public.object_type_value_language_variations FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_del ON dashboard_public.object_type_value_language_variations FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE TABLE dashboard_public.object_type_language_variations (
  
);

ALTER TABLE dashboard_public.object_type_language_variations DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.object_type_language_variations ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.object_type_language_variations ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.object_type_language_variations ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.object_type_language_variations ADD CONSTRAINT object_type_language_variations_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.object_type_language_variations ADD COLUMN  lang_code citext;

ALTER TABLE dashboard_public.object_type_language_variations ADD CONSTRAINT object_type_language_variations_lang_code_chk CHECK ( character_length(lang_code) <= 10 );

ALTER TABLE dashboard_public.object_type_language_variations ADD COLUMN  name citext;

ALTER TABLE dashboard_public.object_type_language_variations ADD COLUMN  description text;

ALTER TABLE dashboard_public.object_type_language_variations ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.object_type_language_variations ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.object_type_language_variations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.object_type_language_variations ( created_by );

CREATE INDEX ON dashboard_public.object_type_language_variations ( updated_by );

ALTER TABLE dashboard_public.object_type_language_variations ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.object_type_language_variations ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.object_type_language_variations ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.object_type_language_variations ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.object_type_language_variations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.object_type_language_variations ( created_at );

CREATE INDEX ON dashboard_public.object_type_language_variations ( updated_at );

COMMENT ON TABLE dashboard_public.object_types IS E'@i18n object_type_language_variations';

ALTER TABLE dashboard_public.object_type_language_variations ADD COLUMN  object_type_id uuid;

ALTER TABLE dashboard_public.object_type_language_variations ALTER COLUMN object_type_id SET NOT NULL;

ALTER TABLE dashboard_public.object_type_language_variations ADD CONSTRAINT object_type_language_variations_object_type_id_fkey FOREIGN KEY ( object_type_id ) REFERENCES dashboard_public.object_types ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT object_type_language_variations_object_type_id_fkey ON dashboard_public.object_type_language_variations IS E'@omit manyToMany';

CREATE INDEX object_type_language_variations_object_type_id_idx ON dashboard_public.object_type_language_variations ( object_type_id );

ALTER TABLE dashboard_public.object_type_language_variations ADD CONSTRAINT object_type_language_variations_object_type_id_lang_code_key UNIQUE ( object_type_id, lang_code );

COMMENT ON CONSTRAINT object_type_language_variations_object_type_id_lang_code_key ON dashboard_public.object_type_language_variations IS E'@omit';

ALTER TABLE dashboard_public.object_type_language_variations ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.object_type_language_variations TO authenticated;

GRANT SELECT ON TABLE dashboard_public.object_type_language_variations TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.object_type_language_variations TO authenticated;

GRANT DELETE ON TABLE dashboard_public.object_type_language_variations TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.object_type_language_variations FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_public.object_type_language_variations FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_upd ON dashboard_public.object_type_language_variations FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_del ON dashboard_public.object_type_language_variations FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE FUNCTION inflection.upper ( str text ) RETURNS text AS $EOFCODE$
BEGIN
  return upper(str);
END;
$EOFCODE$ LANGUAGE plpgsql STABLE;

CREATE FUNCTION inflection.lower ( str text ) RETURNS text AS $EOFCODE$
BEGIN
  return lower(str);
END;
$EOFCODE$ LANGUAGE plpgsql STABLE;

CREATE FUNCTION dashboard_private.language_dictionary_inf_name (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  new.name = inflection.upper(inflection.underscore(new.name));
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER insert_inf_name 
 BEFORE INSERT ON dashboard_public.language_dictionary 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. language_dictionary_inf_name (  );

CREATE TRIGGER update_inf_name 
 BEFORE UPDATE ON dashboard_public.language_dictionary 
 FOR EACH ROW
 WHEN ( OLD.name IS DISTINCT FROM NEW.name ) 
 EXECUTE PROCEDURE dashboard_private. language_dictionary_inf_name (  );

DROP TABLE IF EXISTS dashboard_public.user_locations CASCADE;

DROP TABLE IF EXISTS dashboard_public.location_types CASCADE;

DROP TABLE IF EXISTS dashboard_public.locations CASCADE;

CREATE TABLE dashboard_public.location_types (
  
);

ALTER TABLE dashboard_public.location_types DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.location_types ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.location_types ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.location_types ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.location_types ADD CONSTRAINT location_types_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.location_types ADD COLUMN  name text;

COMMENT ON COLUMN dashboard_public.location_types.name IS E'e.g. neighborhood, postalcode, locality, venue, etc';

ALTER TABLE dashboard_public.location_types ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.location_types ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.location_types 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.location_types ( created_by );

CREATE INDEX ON dashboard_public.location_types ( updated_by );

ALTER TABLE dashboard_public.location_types ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.location_types ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.location_types ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.location_types ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.location_types 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.location_types ( created_at );

CREATE INDEX ON dashboard_public.location_types ( updated_at );

ALTER TABLE dashboard_public.location_types ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.location_types TO authenticated;

GRANT SELECT ON TABLE dashboard_public.location_types TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.location_types TO authenticated;

GRANT DELETE ON TABLE dashboard_public.location_types TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.location_types FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_upd ON dashboard_public.location_types FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_del ON dashboard_public.location_types FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_sel ON dashboard_public.location_types FOR SELECT TO authenticated USING ( TRUE );

CREATE TABLE dashboard_public.locations (
  
);

ALTER TABLE dashboard_public.locations DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.locations ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.locations ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.locations ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.locations ADD CONSTRAINT locations_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.locations ADD COLUMN  name text;

ALTER TABLE dashboard_public.locations ADD COLUMN  coords geometry(point, 4326);

ALTER TABLE dashboard_public.locations ADD COLUMN  poly geometry(polygon, 4326);

ALTER TABLE dashboard_public.locations ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.locations ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.locations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.locations ( created_by );

CREATE INDEX ON dashboard_public.locations ( updated_by );

ALTER TABLE dashboard_public.locations ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.locations ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.locations ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.locations ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.locations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.locations ( created_at );

CREATE INDEX ON dashboard_public.locations ( updated_at );

ALTER TABLE dashboard_public.locations ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.locations ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.locations ADD CONSTRAINT locations_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT locations_owner_id_fkey ON dashboard_public.locations IS E'@omit manyToMany';

CREATE INDEX locations_owner_id_idx ON dashboard_public.locations ( owner_id );

ALTER TABLE dashboard_public.locations ADD COLUMN  type_id uuid;

ALTER TABLE dashboard_public.locations ALTER COLUMN type_id SET NOT NULL;

ALTER TABLE dashboard_public.locations ADD CONSTRAINT locations_type_id_fkey FOREIGN KEY ( type_id ) REFERENCES dashboard_public.location_types ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT locations_type_id_fkey ON dashboard_public.locations IS E'@omit manyToMany';

CREATE INDEX locations_type_id_idx ON dashboard_public.locations ( type_id );

CREATE INDEX locations_coords_idx ON dashboard_public.locations USING GIST ( coords );

CREATE INDEX locations_poly_idx ON dashboard_public.locations USING GIST ( poly );

ALTER TABLE dashboard_public.locations ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.locations TO authenticated;

GRANT SELECT ON TABLE dashboard_public.locations TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.locations TO authenticated;

GRANT DELETE ON TABLE dashboard_public.locations TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.locations FOR INSERT TO authenticated WITH CHECK ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_upd ON dashboard_public.locations FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_del ON dashboard_public.locations FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_ins_admin ON dashboard_public.locations FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_upd_admin ON dashboard_public.locations FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_del_admin ON dashboard_public.locations FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_sel ON dashboard_public.locations FOR SELECT TO authenticated USING ( TRUE );

CREATE TABLE dashboard_public.user_locations (
  
);

ALTER TABLE dashboard_public.user_locations DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.user_locations ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.user_locations ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.user_locations ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.user_locations ADD CONSTRAINT user_locations_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.user_locations ADD COLUMN  user_id uuid;

ALTER TABLE dashboard_public.user_locations ALTER COLUMN user_id SET NOT NULL;

ALTER TABLE dashboard_public.user_locations ALTER COLUMN user_id SET DEFAULT jwt_public.current_user_id();

ALTER TABLE dashboard_public.user_locations ADD COLUMN  name text;

ALTER TABLE dashboard_public.user_locations ADD COLUMN  description text;

ALTER TABLE dashboard_public.user_locations ADD COLUMN  coords geometry(point, 4326);

ALTER TABLE dashboard_public.user_locations ADD COLUMN  poly geometry(polygon, 4326);

ALTER TABLE dashboard_public.user_locations ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.user_locations ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_locations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.user_locations ( created_by );

CREATE INDEX ON dashboard_public.user_locations ( updated_by );

ALTER TABLE dashboard_public.user_locations ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.user_locations ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.user_locations ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.user_locations ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_locations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.user_locations ( created_at );

CREATE INDEX ON dashboard_public.user_locations ( updated_at );

CREATE INDEX user_locations_coords_idx ON dashboard_public.user_locations USING GIST ( coords );

CREATE INDEX user_locations_poly_idx ON dashboard_public.user_locations USING GIST ( poly );

ALTER TABLE dashboard_public.user_locations ADD CONSTRAINT user_locations_user_id_fkey FOREIGN KEY ( user_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_locations_user_id_fkey ON dashboard_public.user_locations IS E'@omit manyToMany';

CREATE INDEX user_locations_user_id_idx ON dashboard_public.user_locations ( user_id );

ALTER TABLE dashboard_public.user_locations ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.user_locations TO authenticated;

GRANT SELECT ON TABLE dashboard_public.user_locations TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.user_locations TO authenticated;

GRANT DELETE ON TABLE dashboard_public.user_locations TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.user_locations FOR INSERT TO authenticated WITH CHECK ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_sel ON dashboard_public.user_locations FOR SELECT TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_upd ON dashboard_public.user_locations FOR UPDATE TO authenticated USING ( user_id = jwt_public.current_user_id() );

CREATE POLICY auth_del ON dashboard_public.user_locations FOR DELETE TO authenticated USING ( user_id = jwt_public.current_user_id() );

ALTER TABLE dashboard_public.location_types ADD COLUMN  ref text;

ALTER TABLE dashboard_public.location_types ADD CONSTRAINT location_types_ref_chk CHECK ( character_length(ref) <= 2048 );

ALTER TABLE dashboard_public.location_types ADD COLUMN  description text;

CREATE FUNCTION dashboard_private.location_types_inf_ref (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  new.ref = inflection.upper(inflection.underscore(new.ref));
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER insert_inf_ref 
 BEFORE INSERT ON dashboard_public.location_types 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. location_types_inf_ref (  );

CREATE TRIGGER update_inf_ref 
 BEFORE UPDATE ON dashboard_public.location_types 
 FOR EACH ROW
 WHEN ( OLD.ref IS DISTINCT FROM NEW.ref ) 
 EXECUTE PROCEDURE dashboard_private. location_types_inf_ref (  );

ALTER TABLE dashboard_public.location_types ADD CONSTRAINT location_types_ref_key UNIQUE ( ref );

COMMENT ON CONSTRAINT location_types_ref_key ON dashboard_public.location_types IS NULL;

INSERT INTO dashboard_public.location_types ( name, ref, description ) VALUES ('venue', 'venue', 'venue'), ('locality', 'locality', 'locality'), ('postalcode', 'postalcode', 'postalcode'), ('neighborhood', 'neighborhood', 'neighborhood'), ('localadmin', 'localadmin', 'localadmin'), ('county', 'county', 'county'), ('campus', 'campus', 'campus'), ('constituency', 'constituency', 'constituency'), ('region', 'region', 'region'), ('intersection', 'intersection', 'intersection'), ('microhood', 'microhood', 'microhood'), ('macrohood', 'macrohood', 'macrohood'), ('macrocounty', 'macrocounty', 'macrocounty'), ('timezone', 'timezone', 'timezone'), ('borough', 'borough', 'borough'), ('marinearea', 'marinearea', 'marinearea'), ('country', 'country', 'country'), ('marketarea', 'marketarea', 'marketarea'), ('macroregion', 'macroregion', 'macroregion'), ('disputed', 'disputed', 'disputed'), ('dependency', 'dependency', 'dependency'), ('empire', 'empire', 'empire'), ('continent', 'continent', 'continent');

CREATE TABLE dashboard_public.user_location_types (
  
);

ALTER TABLE dashboard_public.user_location_types DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.user_location_types ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.user_location_types ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.user_location_types ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.user_location_types ADD CONSTRAINT user_location_types_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.user_location_types ADD COLUMN  name text;

ALTER TABLE dashboard_public.user_location_types ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.user_location_types ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_location_types 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.user_location_types ( created_by );

CREATE INDEX ON dashboard_public.user_location_types ( updated_by );

ALTER TABLE dashboard_public.user_location_types ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.user_location_types ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.user_location_types ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.user_location_types ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.user_location_types 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.user_location_types ( created_at );

CREATE INDEX ON dashboard_public.user_location_types ( updated_at );

ALTER TABLE dashboard_public.user_location_types ADD COLUMN  ref text;

ALTER TABLE dashboard_public.user_location_types ADD CONSTRAINT user_location_types_ref_chk CHECK ( character_length(ref) <= 2048 );

ALTER TABLE dashboard_public.user_location_types ADD COLUMN  description text;

CREATE FUNCTION dashboard_private.user_location_types_inf_ref (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  new.ref = inflection.upper(inflection.underscore(new.ref));
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER insert_inf_ref 
 BEFORE INSERT ON dashboard_public.user_location_types 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. user_location_types_inf_ref (  );

CREATE TRIGGER update_inf_ref 
 BEFORE UPDATE ON dashboard_public.user_location_types 
 FOR EACH ROW
 WHEN ( OLD.ref IS DISTINCT FROM NEW.ref ) 
 EXECUTE PROCEDURE dashboard_private. user_location_types_inf_ref (  );

ALTER TABLE dashboard_public.user_location_types ADD CONSTRAINT user_location_types_ref_key UNIQUE ( ref );

COMMENT ON CONSTRAINT user_location_types_ref_key ON dashboard_public.user_location_types IS E'@omit';

ALTER TABLE dashboard_public.user_location_types ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.user_location_types TO authenticated;

GRANT SELECT ON TABLE dashboard_public.user_location_types TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.user_location_types TO authenticated;

GRANT DELETE ON TABLE dashboard_public.user_location_types TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.user_location_types FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_upd ON dashboard_public.user_location_types FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_del ON dashboard_public.user_location_types FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_sel ON dashboard_public.user_location_types FOR SELECT TO authenticated USING ( TRUE );

INSERT INTO dashboard_public.user_location_types ( name, ref, description ) VALUES ('home', 'home', 'home'), ('work', 'work', 'work'), ('exercise', 'exercise', 'exercise'), ('neighborhood', 'neighborhood', 'neighborhood');

ALTER TABLE dashboard_public.user_locations ADD COLUMN  type_id uuid;

ALTER TABLE dashboard_public.user_locations ALTER COLUMN type_id SET NOT NULL;

ALTER TABLE dashboard_public.user_locations ADD CONSTRAINT user_locations_type_id_fkey FOREIGN KEY ( type_id ) REFERENCES dashboard_public.user_location_types ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_locations_type_id_fkey ON dashboard_public.user_locations IS E'@omit manyToMany';

CREATE INDEX user_locations_type_id_idx ON dashboard_public.user_locations ( type_id );

ALTER TABLE dashboard_public.user_locations ADD COLUMN  ref_location_id uuid;

ALTER TABLE dashboard_public.user_locations ADD CONSTRAINT user_locations_ref_location_id_fkey FOREIGN KEY ( ref_location_id ) REFERENCES dashboard_public.locations ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_locations_ref_location_id_fkey ON dashboard_public.user_locations IS E'@omit manyToMany';

CREATE INDEX user_locations_ref_location_id_idx ON dashboard_public.user_locations ( ref_location_id );

DROP TABLE IF EXISTS dashboard_public.group_locations CASCADE;

CREATE TABLE dashboard_public.group_locations (
  
);

ALTER TABLE dashboard_public.group_locations DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.group_locations ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.group_locations ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.group_locations ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.group_locations ADD CONSTRAINT group_locations_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.group_locations ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.group_locations ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.group_locations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.group_locations ( created_by );

CREATE INDEX ON dashboard_public.group_locations ( updated_by );

ALTER TABLE dashboard_public.group_locations ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.group_locations ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.group_locations ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.group_locations ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.group_locations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.group_locations ( created_at );

CREATE INDEX ON dashboard_public.group_locations ( updated_at );

ALTER TABLE dashboard_public.group_locations ADD COLUMN  group_id uuid;

ALTER TABLE dashboard_public.group_locations ALTER COLUMN group_id SET NOT NULL;

ALTER TABLE dashboard_public.group_locations ADD CONSTRAINT group_locations_group_id_fkey FOREIGN KEY ( group_id ) REFERENCES dashboard_public.groups ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT group_locations_group_id_fkey ON dashboard_public.group_locations IS E'@omit manyToMany';

CREATE INDEX group_locations_group_id_idx ON dashboard_public.group_locations ( group_id );

ALTER TABLE dashboard_public.group_locations ADD COLUMN  location_id uuid;

ALTER TABLE dashboard_public.group_locations ALTER COLUMN location_id SET NOT NULL;

ALTER TABLE dashboard_public.group_locations ADD CONSTRAINT group_locations_location_id_fkey FOREIGN KEY ( location_id ) REFERENCES dashboard_public.locations ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT group_locations_location_id_fkey ON dashboard_public.group_locations IS E'@omit manyToMany';

CREATE INDEX group_locations_location_id_idx ON dashboard_public.group_locations ( location_id );

CREATE TRIGGER group_locations_group_id_immutable_tg 
 BEFORE UPDATE ON dashboard_public.group_locations 
 FOR EACH ROW
 WHEN ( old.group_id IS DISTINCT FROM new.group_id AND old.group_id IS NOT NULL ) 
 EXECUTE PROCEDURE utils. throw ( 'IMMUTABLE_PROPERTY','group_id' );

ALTER TABLE dashboard_public.group_locations ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.group_locations TO authenticated;

GRANT SELECT ON TABLE dashboard_public.group_locations TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.group_locations TO authenticated;

GRANT DELETE ON TABLE dashboard_public.group_locations TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.group_locations FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_public.group_locations FOR INSERT TO authenticated WITH CHECK ( group_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000010000000') = '00000000000000000000000010000000') );

CREATE POLICY auth_upd ON dashboard_public.group_locations FOR UPDATE TO authenticated USING ( group_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000010000000') = '00000000000000000000000010000000') );

CREATE POLICY auth_del ON dashboard_public.group_locations FOR DELETE TO authenticated USING ( group_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000010000000') = '00000000000000000000000010000000') );

ALTER TABLE dashboard_public.user_action_items ADD COLUMN  object_id uuid;

ALTER TABLE dashboard_public.user_action_items ADD CONSTRAINT user_action_items_object_id_fkey FOREIGN KEY ( object_id ) REFERENCES dashboard_public.objects ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_action_items_object_id_fkey ON dashboard_public.user_action_items IS E'@omit manyToMany';

CREATE INDEX user_action_items_object_id_idx ON dashboard_public.user_action_items ( object_id );

ALTER TABLE dashboard_public.action_items ADD COLUMN  poly geometry(polygon, 4326);

CREATE INDEX action_items_poly_idx ON dashboard_public.action_items USING GIST ( poly );

ALTER TABLE dashboard_public.action_items ADD COLUMN  coords geometry(point, 4326);

CREATE INDEX action_items_coords_idx ON dashboard_public.action_items USING GIST ( coords );

CREATE TABLE dashboard_public.action_item_locations (
  
);

ALTER TABLE dashboard_public.action_item_locations DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.action_item_locations ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.action_item_locations ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.action_item_locations ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.action_item_locations ADD CONSTRAINT action_item_locations_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.action_item_locations ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.action_item_locations ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.action_item_locations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.action_item_locations ( created_by );

CREATE INDEX ON dashboard_public.action_item_locations ( updated_by );

ALTER TABLE dashboard_public.action_item_locations ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.action_item_locations ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.action_item_locations ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.action_item_locations ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.action_item_locations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.action_item_locations ( created_at );

CREATE INDEX ON dashboard_public.action_item_locations ( updated_at );

ALTER TABLE dashboard_public.action_item_locations ADD COLUMN  coords geometry(point, 4326);

CREATE INDEX action_item_locations_coords_idx ON dashboard_public.action_item_locations USING GIST ( coords );

ALTER TABLE dashboard_public.action_item_locations ADD COLUMN  poly geometry(polygon, 4326);

CREATE INDEX action_item_locations_poly_idx ON dashboard_public.action_item_locations USING GIST ( poly );

ALTER TABLE dashboard_public.action_item_locations ADD COLUMN  action_item_id uuid;

ALTER TABLE dashboard_public.action_item_locations ALTER COLUMN action_item_id SET NOT NULL;

ALTER TABLE dashboard_public.action_item_locations ADD CONSTRAINT action_item_locations_action_item_id_fkey FOREIGN KEY ( action_item_id ) REFERENCES dashboard_public.action_items ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT action_item_locations_action_item_id_fkey ON dashboard_public.action_item_locations IS E'@omit manyToMany';

CREATE INDEX action_item_locations_action_item_id_idx ON dashboard_public.action_item_locations ( action_item_id );

ALTER TABLE dashboard_public.action_item_locations ADD COLUMN  location_id uuid;

ALTER TABLE dashboard_public.action_item_locations ADD CONSTRAINT action_item_locations_location_id_fkey FOREIGN KEY ( location_id ) REFERENCES dashboard_public.locations ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT action_item_locations_location_id_fkey ON dashboard_public.action_item_locations IS E'@omit manyToMany';

CREATE INDEX action_item_locations_location_id_idx ON dashboard_public.action_item_locations ( location_id );

ALTER TABLE dashboard_public.action_item_locations ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.action_item_locations ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.action_item_locations ADD CONSTRAINT action_item_locations_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT action_item_locations_owner_id_fkey ON dashboard_public.action_item_locations IS E'@omit manyToMany';

CREATE INDEX action_item_locations_owner_id_idx ON dashboard_public.action_item_locations ( owner_id );

ALTER TABLE dashboard_public.action_item_locations ADD COLUMN  action_id uuid;

ALTER TABLE dashboard_public.action_item_locations ALTER COLUMN action_id SET NOT NULL;

ALTER TABLE dashboard_public.action_item_locations ADD CONSTRAINT action_item_locations_action_id_fkey FOREIGN KEY ( action_id ) REFERENCES dashboard_public.actions ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT action_item_locations_action_id_fkey ON dashboard_public.action_item_locations IS E'@omit manyToMany';

CREATE INDEX action_item_locations_action_id_idx ON dashboard_public.action_item_locations ( action_id );

ALTER TABLE dashboard_public.action_item_locations ALTER COLUMN owner_id SET DEFAULT uuid_nil();

ALTER TABLE dashboard_public.action_item_locations ALTER COLUMN action_id SET DEFAULT uuid_nil();

CREATE FUNCTION dashboard_private.action_item_locations_denorm_action_item_id (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  IF (NEW.action_item_id IS NOT NULL) THEN
   SELECT ref.owner_id,
ref.action_id FROM "dashboard_public".action_items AS ref WHERE ref.id = new.action_item_id
   INTO new.owner_id,
new.action_id;
  END IF;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_action_item_id 
 BEFORE INSERT ON dashboard_public.action_item_locations 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. action_item_locations_denorm_action_item_id (  );

CREATE TRIGGER _000000000_ensure_update_action_item_id 
 BEFORE UPDATE ON dashboard_public.action_item_locations 
 FOR EACH ROW
 WHEN ( old.action_item_id IS DISTINCT FROM new.action_item_id OR old.owner_id IS DISTINCT FROM new.owner_id OR old.action_id IS DISTINCT FROM new.action_id ) 
 EXECUTE PROCEDURE dashboard_private. action_item_locations_denorm_action_item_id (  );

ALTER TABLE dashboard_public.action_item_locations ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.action_item_locations TO authenticated;

GRANT SELECT ON TABLE dashboard_public.action_item_locations TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.action_item_locations TO authenticated;

GRANT DELETE ON TABLE dashboard_public.action_item_locations TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.action_item_locations FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_public.action_item_locations FOR INSERT TO authenticated WITH CHECK ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE POLICY auth_upd ON dashboard_public.action_item_locations FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE POLICY auth_del ON dashboard_public.action_item_locations FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

ALTER TABLE dashboard_public.action_items ADD COLUMN  bounds geometry(geometrycollection, 4326);

CREATE INDEX action_items_bounds_idx ON dashboard_public.action_items USING GIST ( bounds );

ALTER TABLE dashboard_public.user_settings DROP COLUMN bounds;

ALTER TABLE dashboard_public.user_settings ADD COLUMN  bounds geometry(geometrycollection, 4326);

COMMENT ON COLUMN dashboard_public.user_settings.bounds IS E'user home locations combined using ST_Collect for search optimization';

ALTER TABLE dashboard_public.user_settings ADD COLUMN  close_bounds geometry(geometrycollection, 4326);

COMMENT ON COLUMN dashboard_public.user_settings.close_bounds IS E'user home, work, and other "close" locations combined using ST_Collect for search optimization';

CREATE INDEX user_settings_close_bounds_idx ON dashboard_public.user_settings USING GIST ( close_bounds );

ALTER TABLE dashboard_public.user_settings ADD COLUMN  extended_bounds geometry(geometrycollection, 4326);

COMMENT ON COLUMN dashboard_public.user_settings.extended_bounds IS E'all of the users locations combined using ST_Collect for search optimization';

CREATE INDEX user_settings_extended_bounds_idx ON dashboard_public.user_settings USING GIST ( extended_bounds );

ALTER TABLE dashboard_public.user_settings ADD COLUMN  temporary_bounds geometry(geometrycollection, 4326);

COMMENT ON COLUMN dashboard_public.user_settings.temporary_bounds IS E'all of the users temporary locations combined using ST_Collect for search optimization';

CREATE INDEX user_settings_temporary_bounds_idx ON dashboard_public.user_settings USING GIST ( temporary_bounds );

ALTER TABLE dashboard_public.user_locations DROP COLUMN ref_location_id;

ALTER TABLE dashboard_public.group_locations ADD COLUMN  coords geometry(point, 4326);

CREATE INDEX group_locations_coords_idx ON dashboard_public.group_locations USING GIST ( coords );

ALTER TABLE dashboard_public.group_locations ADD COLUMN  poly geometry(polygon, 4326);

CREATE INDEX group_locations_poly_idx ON dashboard_public.group_locations USING GIST ( poly );

ALTER TABLE dashboard_public.action_locations ADD COLUMN  coords geometry(point, 4326);

CREATE INDEX action_locations_coords_idx ON dashboard_public.action_locations USING GIST ( coords );

ALTER TABLE dashboard_public.action_locations ADD COLUMN  poly geometry(polygon, 4326);

CREATE INDEX action_locations_poly_idx ON dashboard_public.action_locations USING GIST ( poly );

ALTER TABLE dashboard_public.user_locations ADD COLUMN  location_id uuid;

ALTER TABLE dashboard_public.user_locations ADD CONSTRAINT user_locations_location_id_fkey FOREIGN KEY ( location_id ) REFERENCES dashboard_public.locations ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_locations_location_id_fkey ON dashboard_public.user_locations IS E'@omit manyToMany';

CREATE INDEX user_locations_location_id_idx ON dashboard_public.user_locations ( location_id );

GRANT SELECT ON TABLE dashboard_public.language_dictionary TO anonymous;

GRANT SELECT ON TABLE dashboard_public.global_languages TO anonymous;

CREATE TABLE dashboard_public.track_locations (
  
);

ALTER TABLE dashboard_public.track_locations DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.track_locations ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.track_locations ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.track_locations ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.track_locations ADD CONSTRAINT track_locations_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.track_locations ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.track_locations ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.track_locations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.track_locations ( created_by );

CREATE INDEX ON dashboard_public.track_locations ( updated_by );

ALTER TABLE dashboard_public.track_locations ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.track_locations ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.track_locations ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.track_locations ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.track_locations 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.track_locations ( created_at );

CREATE INDEX ON dashboard_public.track_locations ( updated_at );

ALTER TABLE dashboard_public.track_locations ADD COLUMN  coords geometry(point, 4326);

CREATE INDEX track_locations_coords_idx ON dashboard_public.track_locations USING GIST ( coords );

ALTER TABLE dashboard_public.track_locations ADD COLUMN  poly geometry(polygon, 4326);

CREATE INDEX track_locations_poly_idx ON dashboard_public.track_locations USING GIST ( poly );

ALTER TABLE dashboard_public.track_locations ADD COLUMN  track_id uuid;

ALTER TABLE dashboard_public.track_locations ALTER COLUMN track_id SET NOT NULL;

ALTER TABLE dashboard_public.track_locations ADD CONSTRAINT track_locations_track_id_fkey FOREIGN KEY ( track_id ) REFERENCES dashboard_public.tracks ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT track_locations_track_id_fkey ON dashboard_public.track_locations IS E'@omit manyToMany';

CREATE INDEX track_locations_track_id_idx ON dashboard_public.track_locations ( track_id );

ALTER TABLE dashboard_public.track_locations ADD COLUMN  location_id uuid;

ALTER TABLE dashboard_public.track_locations ADD CONSTRAINT track_locations_location_id_fkey FOREIGN KEY ( location_id ) REFERENCES dashboard_public.locations ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT track_locations_location_id_fkey ON dashboard_public.track_locations IS E'@omit manyToMany';

CREATE INDEX track_locations_location_id_idx ON dashboard_public.track_locations ( location_id );

ALTER TABLE dashboard_public.track_locations ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.track_locations ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.track_locations ADD CONSTRAINT track_locations_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT track_locations_owner_id_fkey ON dashboard_public.track_locations IS E'@omit manyToMany';

CREATE INDEX track_locations_owner_id_idx ON dashboard_public.track_locations ( owner_id );

ALTER TABLE dashboard_public.track_locations ALTER COLUMN owner_id SET DEFAULT uuid_nil();

CREATE FUNCTION dashboard_private.track_locations_denorm_track_id (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  IF (NEW.track_id IS NOT NULL) THEN
   SELECT ref.owner_id FROM "dashboard_public".tracks AS ref WHERE ref.id = new.track_id
   INTO new.owner_id;
  END IF;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_track_id 
 BEFORE INSERT ON dashboard_public.track_locations 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. track_locations_denorm_track_id (  );

CREATE TRIGGER _000000000_ensure_update_track_id 
 BEFORE UPDATE ON dashboard_public.track_locations 
 FOR EACH ROW
 WHEN ( old.track_id IS DISTINCT FROM new.track_id OR old.owner_id IS DISTINCT FROM new.owner_id ) 
 EXECUTE PROCEDURE dashboard_private. track_locations_denorm_track_id (  );

ALTER TABLE dashboard_public.track_locations ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.track_locations TO authenticated;

GRANT SELECT ON TABLE dashboard_public.track_locations TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.track_locations TO authenticated;

GRANT DELETE ON TABLE dashboard_public.track_locations TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.track_locations FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_public.track_locations FOR INSERT TO authenticated WITH CHECK ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE POLICY auth_upd ON dashboard_public.track_locations FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE POLICY auth_del ON dashboard_public.track_locations FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

ALTER TABLE dashboard_public.tracks ADD COLUMN  bounds geometry(geometrycollection, 4326);

CREATE INDEX tracks_bounds_idx ON dashboard_public.tracks USING GIST ( bounds );

CREATE TABLE dashboard_public.track_groups (
  
);

ALTER TABLE dashboard_public.track_groups DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.track_groups ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.track_groups ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.track_groups ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.track_groups ADD CONSTRAINT track_groups_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.track_groups ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.track_groups ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.track_groups 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.track_groups ( created_by );

CREATE INDEX ON dashboard_public.track_groups ( updated_by );

ALTER TABLE dashboard_public.track_groups ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.track_groups ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.track_groups ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.track_groups ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.track_groups 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.track_groups ( created_at );

CREATE INDEX ON dashboard_public.track_groups ( updated_at );

ALTER TABLE dashboard_public.track_groups ADD COLUMN  track_id uuid;

ALTER TABLE dashboard_public.track_groups ALTER COLUMN track_id SET NOT NULL;

ALTER TABLE dashboard_public.track_groups ADD CONSTRAINT track_groups_track_id_fkey FOREIGN KEY ( track_id ) REFERENCES dashboard_public.tracks ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT track_groups_track_id_fkey ON dashboard_public.track_groups IS NULL;

CREATE INDEX track_groups_track_id_idx ON dashboard_public.track_groups ( track_id );

ALTER TABLE dashboard_public.track_groups ADD COLUMN  group_id uuid;

ALTER TABLE dashboard_public.track_groups ADD CONSTRAINT track_groups_group_id_fkey FOREIGN KEY ( group_id ) REFERENCES dashboard_public.groups ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT track_groups_group_id_fkey ON dashboard_public.track_groups IS NULL;

CREATE INDEX track_groups_group_id_idx ON dashboard_public.track_groups ( group_id );

ALTER TABLE dashboard_public.track_groups ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.track_groups ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.track_groups ADD CONSTRAINT track_groups_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT track_groups_owner_id_fkey ON dashboard_public.track_groups IS E'@omit manyToMany';

CREATE INDEX track_groups_owner_id_idx ON dashboard_public.track_groups ( owner_id );

ALTER TABLE dashboard_public.track_groups ALTER COLUMN owner_id SET DEFAULT uuid_nil();

CREATE FUNCTION dashboard_private.track_groups_denorm_track_id (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  IF (NEW.track_id IS NOT NULL) THEN
   SELECT ref.owner_id FROM "dashboard_public".tracks AS ref WHERE ref.id = new.track_id
   INTO new.owner_id;
  END IF;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_track_id 
 BEFORE INSERT ON dashboard_public.track_groups 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. track_groups_denorm_track_id (  );

CREATE TRIGGER _000000000_ensure_update_track_id 
 BEFORE UPDATE ON dashboard_public.track_groups 
 FOR EACH ROW
 WHEN ( old.track_id IS DISTINCT FROM new.track_id OR old.owner_id IS DISTINCT FROM new.owner_id ) 
 EXECUTE PROCEDURE dashboard_private. track_groups_denorm_track_id (  );

ALTER TABLE dashboard_public.track_groups ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.track_groups TO authenticated;

GRANT SELECT ON TABLE dashboard_public.track_groups TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.track_groups TO authenticated;

GRANT DELETE ON TABLE dashboard_public.track_groups TO authenticated;

CREATE POLICY auth_sel ON dashboard_public.track_groups FOR SELECT TO authenticated USING ( TRUE );

CREATE POLICY auth_ins ON dashboard_public.track_groups FOR INSERT TO authenticated WITH CHECK ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000')) OR group_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000')) );

CREATE POLICY auth_upd ON dashboard_public.track_groups FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000')) OR group_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000')) );

CREATE POLICY auth_del ON dashboard_public.track_groups FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000')) OR group_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000')) );

ALTER TABLE dashboard_public.tracks ADD COLUMN  tags citext[];

CREATE INDEX tracks_tags_idx ON dashboard_public.tracks USING GIN ( tags );

ALTER TABLE dashboard_public.user_profiles ADD COLUMN  local_leader_info text;

ALTER TABLE dashboard_public.tracks ADD COLUMN  rich_description text;

ALTER TABLE dashboard_public.tracks ADD COLUMN  feed_order int;

ALTER TABLE dashboard_public.tracks ALTER COLUMN feed_order SET DEFAULT 0;

CREATE INDEX tracks_feed_order_idx ON dashboard_public.tracks ( feed_order );

ALTER TABLE dashboard_public.tracks ADD COLUMN  discovery_description text;

ALTER TABLE dashboard_public.track_language_variations ADD COLUMN  rich_description text;

ALTER TABLE dashboard_public.track_language_variations ADD COLUMN  discovery_description text;

ALTER POLICY auth_sel ON dashboard_memberships_public.group_memberships TO authenticated USING ( (is_admin = FALSE AND entity_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.group_memberships_acl AS acl WHERE (acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000000000000001') = '00000000000000000000000000000001'))) OR is_admin = TRUE );

CREATE TABLE dashboard_public.addresses (
  
);

ALTER TABLE dashboard_public.addresses DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.addresses ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.addresses ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.addresses ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.addresses ADD CONSTRAINT addresses_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.addresses ADD COLUMN  address_line_1 text;

ALTER TABLE dashboard_public.addresses ADD CONSTRAINT addresses_address_line_1_chk CHECK ( character_length(address_line_1) <= 120 );

ALTER TABLE dashboard_public.addresses ADD COLUMN  address_line_2 text;

ALTER TABLE dashboard_public.addresses ADD CONSTRAINT addresses_address_line_2_chk CHECK ( character_length(address_line_2) <= 120 );

ALTER TABLE dashboard_public.addresses ADD COLUMN  address_line_3 text;

ALTER TABLE dashboard_public.addresses ADD CONSTRAINT addresses_address_line_3_chk CHECK ( character_length(address_line_3) <= 120 );

ALTER TABLE dashboard_public.addresses ADD COLUMN  city text;

ALTER TABLE dashboard_public.addresses ADD CONSTRAINT addresses_city_chk CHECK ( character_length(city) <= 120 );

ALTER TABLE dashboard_public.addresses ADD COLUMN  state text;

ALTER TABLE dashboard_public.addresses ADD CONSTRAINT addresses_state_chk CHECK ( character_length(state) <= 120 );

ALTER TABLE dashboard_public.addresses ADD COLUMN  county_province text;

ALTER TABLE dashboard_public.addresses ADD CONSTRAINT addresses_county_province_chk CHECK ( character_length(county_province) <= 120 );

ALTER TABLE dashboard_public.addresses ADD COLUMN  postcode text;

ALTER TABLE dashboard_public.addresses ADD CONSTRAINT addresses_postcode_chk CHECK ( character_length(postcode) <= 24 );

ALTER TABLE dashboard_public.addresses ADD COLUMN  other text;

ALTER TABLE dashboard_public.addresses ADD CONSTRAINT addresses_other_chk CHECK ( character_length(other) <= 120 );

ALTER TABLE dashboard_public.addresses ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.addresses ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.addresses 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.addresses ( created_by );

CREATE INDEX ON dashboard_public.addresses ( updated_by );

ALTER TABLE dashboard_public.addresses ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.addresses ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.addresses ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.addresses ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.addresses 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.addresses ( created_at );

CREATE INDEX ON dashboard_public.addresses ( updated_at );

ALTER TABLE dashboard_public.addresses ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.addresses ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.addresses ADD CONSTRAINT addresses_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT addresses_owner_id_fkey ON dashboard_public.addresses IS E'@omit manyToMany';

CREATE INDEX addresses_owner_id_idx ON dashboard_public.addresses ( owner_id );

ALTER TABLE dashboard_public.addresses ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.addresses TO authenticated;

GRANT SELECT ON TABLE dashboard_public.addresses TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.addresses TO authenticated;

GRANT DELETE ON TABLE dashboard_public.addresses TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.addresses FOR INSERT TO authenticated WITH CHECK ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_sel ON dashboard_public.addresses FOR SELECT TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_upd ON dashboard_public.addresses FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_del ON dashboard_public.addresses FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_sel_admin ON dashboard_public.addresses FOR SELECT TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000010000000000') = '00000000000000000000010000000000') );

CREATE TABLE dashboard_public.action_item_status_types (
  
);

ALTER TABLE dashboard_public.action_item_status_types DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.action_item_status_types ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.action_item_status_types ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.action_item_status_types ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.action_item_status_types ADD CONSTRAINT action_item_status_types_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.action_item_status_types ADD COLUMN  name text;

ALTER TABLE dashboard_public.action_item_status_types ADD COLUMN  status_for_user boolean;

ALTER TABLE dashboard_public.action_item_status_types ALTER COLUMN status_for_user SET DEFAULT TRUE;

ALTER TABLE dashboard_public.action_item_status_types ADD COLUMN  status_for_verifier boolean;

ALTER TABLE dashboard_public.action_item_status_types ALTER COLUMN status_for_verifier SET DEFAULT TRUE;

ALTER TABLE dashboard_public.action_item_status_types ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.action_item_status_types ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.action_item_status_types 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.action_item_status_types ( created_by );

CREATE INDEX ON dashboard_public.action_item_status_types ( updated_by );

ALTER TABLE dashboard_public.action_item_status_types ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.action_item_status_types ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.action_item_status_types ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.action_item_status_types ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.action_item_status_types 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.action_item_status_types ( created_at );

CREATE INDEX ON dashboard_public.action_item_status_types ( updated_at );

ALTER TABLE dashboard_public.action_item_status_types ADD COLUMN  ref text;

ALTER TABLE dashboard_public.action_item_status_types ADD CONSTRAINT action_item_status_types_ref_chk CHECK ( character_length(ref) <= 2048 );

ALTER TABLE dashboard_public.action_item_status_types ADD COLUMN  description text;

CREATE FUNCTION dashboard_private.action_item_status_types_inf_ref (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  new.ref = inflection.upper(inflection.underscore(new.ref));
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER insert_inf_ref 
 BEFORE INSERT ON dashboard_public.action_item_status_types 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. action_item_status_types_inf_ref (  );

CREATE TRIGGER update_inf_ref 
 BEFORE UPDATE ON dashboard_public.action_item_status_types 
 FOR EACH ROW
 WHEN ( OLD.ref IS DISTINCT FROM NEW.ref ) 
 EXECUTE PROCEDURE dashboard_private. action_item_status_types_inf_ref (  );

ALTER TABLE dashboard_public.action_item_status_types ADD CONSTRAINT action_item_status_types_ref_key UNIQUE ( ref );

COMMENT ON CONSTRAINT action_item_status_types_ref_key ON dashboard_public.action_item_status_types IS E'@omit';

ALTER TABLE dashboard_public.action_item_status_types ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.action_item_status_types TO authenticated;

GRANT SELECT ON TABLE dashboard_public.action_item_status_types TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.action_item_status_types TO authenticated;

GRANT DELETE ON TABLE dashboard_public.action_item_status_types TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.action_item_status_types FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_upd ON dashboard_public.action_item_status_types FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_del ON dashboard_public.action_item_status_types FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_sel ON dashboard_public.action_item_status_types FOR SELECT TO authenticated USING ( TRUE );

INSERT INTO dashboard_public.action_item_status_types ( name, ref, description ) VALUES ('Rejected', 'REJECTED', 'rejected'), ('Verified', 'VERIFIED', 'verified'), ('Completed', 'COMPLETED', 'completed');

ALTER TABLE dashboard_public.user_action_items ADD COLUMN  user_status_id uuid;

ALTER TABLE dashboard_public.user_action_items ADD CONSTRAINT user_action_items_user_status_id_fkey FOREIGN KEY ( user_status_id ) REFERENCES dashboard_public.action_item_status_types ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_action_items_user_status_id_fkey ON dashboard_public.user_action_items IS E'@omit manyToMany';

CREATE INDEX user_action_items_user_status_id_idx ON dashboard_public.user_action_items ( user_status_id );

ALTER TABLE dashboard_public.user_action_items ADD COLUMN  verifier_status_id uuid;

ALTER TABLE dashboard_public.user_action_items ADD CONSTRAINT user_action_items_verifier_status_id_fkey FOREIGN KEY ( verifier_status_id ) REFERENCES dashboard_public.action_item_status_types ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_action_items_verifier_status_id_fkey ON dashboard_public.user_action_items IS E'@omit manyToMany';

CREATE INDEX user_action_items_verifier_status_id_idx ON dashboard_public.user_action_items ( verifier_status_id );

ALTER TABLE dashboard_public.user_action_item_verifications ADD COLUMN  action_item_status_id uuid;

ALTER TABLE dashboard_public.user_action_item_verifications ADD CONSTRAINT user_action_item_verifications_action_item_status_id_fkey FOREIGN KEY ( action_item_status_id ) REFERENCES dashboard_public.action_item_status_types ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_action_item_verifications_action_item_status_id_fkey ON dashboard_public.user_action_item_verifications IS E'@omit manyToMany';

CREATE INDEX user_action_item_verifications_action_item_status_id_idx ON dashboard_public.user_action_item_verifications ( action_item_status_id );

ALTER TABLE dashboard_public.action_items ADD COLUMN  self_verifiable boolean;

ALTER TABLE dashboard_public.action_items ALTER COLUMN self_verifiable SET DEFAULT FALSE;

ALTER TABLE dashboard_public.action_item_types ADD COLUMN  self_verifiable boolean;

ALTER TABLE dashboard_public.action_item_types ALTER COLUMN self_verifiable SET DEFAULT FALSE;

ALTER TABLE dashboard_public.user_action_items ADD COLUMN  user_updated_at timestamptz;

CREATE INDEX user_action_items_user_updated_at_idx ON dashboard_public.user_action_items ( user_updated_at );

ALTER TABLE dashboard_public.user_action_items ADD COLUMN  verifier_updated_at timestamptz;

CREATE INDEX user_action_items_verifier_updated_at_idx ON dashboard_public.user_action_items ( verifier_updated_at );

CREATE TABLE dashboard_public.action_status_types (
  
);

ALTER TABLE dashboard_public.action_status_types DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.action_status_types ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.action_status_types ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.action_status_types ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.action_status_types ADD CONSTRAINT action_status_types_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.action_status_types ADD COLUMN  name text;

ALTER TABLE dashboard_public.action_status_types ADD COLUMN  status_for_user boolean;

ALTER TABLE dashboard_public.action_status_types ALTER COLUMN status_for_user SET DEFAULT TRUE;

ALTER TABLE dashboard_public.action_status_types ADD COLUMN  status_for_verifier boolean;

ALTER TABLE dashboard_public.action_status_types ALTER COLUMN status_for_verifier SET DEFAULT TRUE;

ALTER TABLE dashboard_public.action_status_types ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.action_status_types ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.action_status_types 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.action_status_types ( created_by );

CREATE INDEX ON dashboard_public.action_status_types ( updated_by );

ALTER TABLE dashboard_public.action_status_types ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.action_status_types ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.action_status_types ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.action_status_types ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.action_status_types 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.action_status_types ( created_at );

CREATE INDEX ON dashboard_public.action_status_types ( updated_at );

ALTER TABLE dashboard_public.action_status_types ADD COLUMN  ref text;

ALTER TABLE dashboard_public.action_status_types ADD CONSTRAINT action_status_types_ref_chk CHECK ( character_length(ref) <= 2048 );

ALTER TABLE dashboard_public.action_status_types ADD COLUMN  description text;

CREATE FUNCTION dashboard_private.action_status_types_inf_ref (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  new.ref = inflection.upper(inflection.underscore(new.ref));
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER insert_inf_ref 
 BEFORE INSERT ON dashboard_public.action_status_types 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. action_status_types_inf_ref (  );

CREATE TRIGGER update_inf_ref 
 BEFORE UPDATE ON dashboard_public.action_status_types 
 FOR EACH ROW
 WHEN ( OLD.ref IS DISTINCT FROM NEW.ref ) 
 EXECUTE PROCEDURE dashboard_private. action_status_types_inf_ref (  );

ALTER TABLE dashboard_public.action_status_types ADD CONSTRAINT action_status_types_ref_key UNIQUE ( ref );

COMMENT ON CONSTRAINT action_status_types_ref_key ON dashboard_public.action_status_types IS E'@omit';

ALTER TABLE dashboard_public.action_status_types ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.action_status_types TO authenticated;

GRANT SELECT ON TABLE dashboard_public.action_status_types TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.action_status_types TO authenticated;

GRANT DELETE ON TABLE dashboard_public.action_status_types TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.action_status_types FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_upd ON dashboard_public.action_status_types FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_del ON dashboard_public.action_status_types FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_sel ON dashboard_public.action_status_types FOR SELECT TO authenticated USING ( TRUE );

INSERT INTO dashboard_public.action_status_types ( name, ref, description ) VALUES ('Rejected', 'REJECTED', 'rejected'), ('Verified', 'VERIFIED', 'verified'), ('Completed', 'COMPLETED', 'completed');

ALTER TABLE dashboard_public.user_actions ADD COLUMN  user_status_id uuid;

ALTER TABLE dashboard_public.user_actions ADD CONSTRAINT user_actions_user_status_id_fkey FOREIGN KEY ( user_status_id ) REFERENCES dashboard_public.action_status_types ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_actions_user_status_id_fkey ON dashboard_public.user_actions IS E'@omit manyToMany';

CREATE INDEX user_actions_user_status_id_idx ON dashboard_public.user_actions ( user_status_id );

ALTER TABLE dashboard_public.user_actions ADD COLUMN  verifier_status_id uuid;

ALTER TABLE dashboard_public.user_actions ADD CONSTRAINT user_actions_verifier_status_id_fkey FOREIGN KEY ( verifier_status_id ) REFERENCES dashboard_public.action_status_types ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_actions_verifier_status_id_fkey ON dashboard_public.user_actions IS E'@omit manyToMany';

CREATE INDEX user_actions_verifier_status_id_idx ON dashboard_public.user_actions ( verifier_status_id );

ALTER TABLE dashboard_public.user_action_verifications ADD COLUMN  action_status_id uuid;

ALTER TABLE dashboard_public.user_action_verifications ADD CONSTRAINT user_action_verifications_action_status_id_fkey FOREIGN KEY ( action_status_id ) REFERENCES dashboard_public.action_status_types ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_action_verifications_action_status_id_fkey ON dashboard_public.user_action_verifications IS E'@omit manyToMany';

CREATE INDEX user_action_verifications_action_status_id_idx ON dashboard_public.user_action_verifications ( action_status_id );

ALTER TABLE dashboard_public.user_actions ADD COLUMN  user_updated_at timestamptz;

CREATE INDEX user_actions_user_updated_at_idx ON dashboard_public.user_actions ( user_updated_at );

ALTER TABLE dashboard_public.user_actions ADD COLUMN  verifier_updated_at timestamptz;

CREATE INDEX user_actions_verifier_updated_at_idx ON dashboard_public.user_actions ( verifier_updated_at );

ALTER TABLE dashboard_public.tracks ADD COLUMN  color text;

CREATE TABLE dashboard_public.track_types (
  
);

ALTER TABLE dashboard_public.track_types DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.track_types ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.track_types ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.track_types ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.track_types ADD CONSTRAINT track_types_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.track_types ADD COLUMN  name text;

ALTER TABLE dashboard_public.track_types ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.track_types ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.track_types 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.track_types ( created_by );

CREATE INDEX ON dashboard_public.track_types ( updated_by );

ALTER TABLE dashboard_public.track_types ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.track_types ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.track_types ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.track_types ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.track_types 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.track_types ( created_at );

CREATE INDEX ON dashboard_public.track_types ( updated_at );

ALTER TABLE dashboard_public.track_types ADD COLUMN  ref text;

ALTER TABLE dashboard_public.track_types ADD CONSTRAINT track_types_ref_chk CHECK ( character_length(ref) <= 2048 );

ALTER TABLE dashboard_public.track_types ADD COLUMN  description text;

CREATE FUNCTION dashboard_private.track_types_inf_ref (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  new.ref = inflection.upper(inflection.underscore(new.ref));
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER insert_inf_ref 
 BEFORE INSERT ON dashboard_public.track_types 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. track_types_inf_ref (  );

CREATE TRIGGER update_inf_ref 
 BEFORE UPDATE ON dashboard_public.track_types 
 FOR EACH ROW
 WHEN ( OLD.ref IS DISTINCT FROM NEW.ref ) 
 EXECUTE PROCEDURE dashboard_private. track_types_inf_ref (  );

ALTER TABLE dashboard_public.track_types ADD CONSTRAINT track_types_ref_key UNIQUE ( ref );

COMMENT ON CONSTRAINT track_types_ref_key ON dashboard_public.track_types IS E'@omit';

ALTER TABLE dashboard_public.track_types ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.track_types TO authenticated;

GRANT SELECT ON TABLE dashboard_public.track_types TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.track_types TO authenticated;

GRANT DELETE ON TABLE dashboard_public.track_types TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.track_types FOR INSERT TO authenticated WITH CHECK ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_upd ON dashboard_public.track_types FOR UPDATE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_del ON dashboard_public.track_types FOR DELETE TO authenticated USING ( EXISTS (SELECT 1 FROM dashboard_memberships_private.app_memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000000000001000000000') = '00000000000000000000001000000000') );

CREATE POLICY auth_sel ON dashboard_public.track_types FOR SELECT TO authenticated USING ( TRUE );

INSERT INTO dashboard_public.track_types ( name, ref, description ) VALUES ('user', 'USER', 'user'), ('group', 'GROUP', 'group'), ('object', 'OBJECT', 'object');

ALTER TABLE dashboard_public.tracks ADD COLUMN  type_id uuid;

ALTER TABLE dashboard_public.tracks ADD CONSTRAINT tracks_type_id_fkey FOREIGN KEY ( type_id ) REFERENCES dashboard_public.track_types ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT tracks_type_id_fkey ON dashboard_public.tracks IS E'@omit manyToMany';

CREATE INDEX tracks_type_id_idx ON dashboard_public.tracks ( type_id );

ALTER TABLE dashboard_public.objects ADD COLUMN  track_id uuid;

ALTER TABLE dashboard_public.objects ADD CONSTRAINT objects_track_id_fkey FOREIGN KEY ( track_id ) REFERENCES dashboard_public.tracks ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT objects_track_id_fkey ON dashboard_public.objects IS E'@omit manyToMany';

CREATE INDEX objects_track_id_idx ON dashboard_public.objects ( track_id );

ALTER TABLE dashboard_public.user_actions ADD COLUMN  track_id uuid;

GRANT INSERT ( track_id ) ON TABLE dashboard_public.user_actions TO authenticated;

ALTER TABLE dashboard_public.user_actions ADD CONSTRAINT user_actions_track_id_fkey FOREIGN KEY ( track_id ) REFERENCES dashboard_public.tracks ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT user_actions_track_id_fkey ON dashboard_public.user_actions IS E'@omit manyToMany';

CREATE INDEX user_actions_track_id_idx ON dashboard_public.user_actions ( track_id );

CREATE TABLE dashboard_public.object_type_value_tracks (
  
);

ALTER TABLE dashboard_public.object_type_value_tracks DISABLE ROW LEVEL SECURITY;

ALTER TABLE dashboard_public.object_type_value_tracks ADD COLUMN  id uuid;

ALTER TABLE dashboard_public.object_type_value_tracks ALTER COLUMN id SET NOT NULL;

ALTER TABLE dashboard_public.object_type_value_tracks ALTER COLUMN id SET DEFAULT dashboard_private.uuid_generate_v4();

ALTER TABLE dashboard_public.object_type_value_tracks ADD CONSTRAINT object_type_value_tracks_pkey PRIMARY KEY ( id );

ALTER TABLE dashboard_public.object_type_value_tracks ADD COLUMN  created_by uuid;

ALTER TABLE dashboard_public.object_type_value_tracks ADD COLUMN  updated_by uuid;

CREATE TRIGGER peoplestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.object_type_value_tracks 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. peoplestamps (  );

CREATE INDEX ON dashboard_public.object_type_value_tracks ( created_by );

CREATE INDEX ON dashboard_public.object_type_value_tracks ( updated_by );

ALTER TABLE dashboard_public.object_type_value_tracks ADD COLUMN  created_at timestamptz;

ALTER TABLE dashboard_public.object_type_value_tracks ALTER COLUMN created_at SET DEFAULT now();

ALTER TABLE dashboard_public.object_type_value_tracks ADD COLUMN  updated_at timestamptz;

ALTER TABLE dashboard_public.object_type_value_tracks ALTER COLUMN updated_at SET DEFAULT now();

CREATE TRIGGER timestamps_tg 
 BEFORE INSERT OR UPDATE ON dashboard_public.object_type_value_tracks 
 FOR EACH ROW
 EXECUTE PROCEDURE stamps. timestamps (  );

CREATE INDEX ON dashboard_public.object_type_value_tracks ( created_at );

CREATE INDEX ON dashboard_public.object_type_value_tracks ( updated_at );

ALTER TABLE dashboard_public.object_type_value_tracks ADD COLUMN  track_id uuid;

ALTER TABLE dashboard_public.object_type_value_tracks ALTER COLUMN track_id SET NOT NULL;

ALTER TABLE dashboard_public.object_type_value_tracks ADD CONSTRAINT object_type_value_tracks_track_id_fkey FOREIGN KEY ( track_id ) REFERENCES dashboard_public.tracks ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT object_type_value_tracks_track_id_fkey ON dashboard_public.object_type_value_tracks IS E'@omit manyToMany';

CREATE INDEX object_type_value_tracks_track_id_idx ON dashboard_public.object_type_value_tracks ( track_id );

ALTER TABLE dashboard_public.object_type_value_tracks ADD COLUMN  object_type_value_id uuid;

ALTER TABLE dashboard_public.object_type_value_tracks ALTER COLUMN object_type_value_id SET NOT NULL;

ALTER TABLE dashboard_public.object_type_value_tracks ADD CONSTRAINT object_type_value_tracks_object_type_value_id_fkey FOREIGN KEY ( object_type_value_id ) REFERENCES dashboard_public.object_type_values ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT object_type_value_tracks_object_type_value_id_fkey ON dashboard_public.object_type_value_tracks IS E'@omit manyToMany';

CREATE INDEX object_type_value_tracks_object_type_value_id_idx ON dashboard_public.object_type_value_tracks ( object_type_value_id );

ALTER TABLE dashboard_public.object_type_value_tracks ADD COLUMN  owner_id uuid;

ALTER TABLE dashboard_public.object_type_value_tracks ALTER COLUMN owner_id SET NOT NULL;

ALTER TABLE dashboard_public.object_type_value_tracks ADD CONSTRAINT object_type_value_tracks_owner_id_fkey FOREIGN KEY ( owner_id ) REFERENCES dashboard_public.users ( id ) ON DELETE CASCADE;

COMMENT ON CONSTRAINT object_type_value_tracks_owner_id_fkey ON dashboard_public.object_type_value_tracks IS E'@omit manyToMany';

CREATE INDEX object_type_value_tracks_owner_id_idx ON dashboard_public.object_type_value_tracks ( owner_id );

ALTER TABLE dashboard_public.object_type_value_tracks ALTER COLUMN owner_id SET DEFAULT uuid_nil();

CREATE FUNCTION dashboard_private.object_type_value_tracks_denorm_track_id (  ) RETURNS trigger AS $EOFCODE$ 
 
  BEGIN
  IF (NEW.track_id IS NOT NULL) THEN
   SELECT ref.owner_id FROM "dashboard_public".tracks AS ref WHERE ref.id = new.track_id
   INTO new.owner_id;
  END IF;
  RETURN NEW;
  END;
 
 $EOFCODE$ LANGUAGE plpgsql VOLATILE;

CREATE TRIGGER _000000000_ensure_insert_track_id 
 BEFORE INSERT ON dashboard_public.object_type_value_tracks 
 FOR EACH ROW
 EXECUTE PROCEDURE dashboard_private. object_type_value_tracks_denorm_track_id (  );

CREATE TRIGGER _000000000_ensure_update_track_id 
 BEFORE UPDATE ON dashboard_public.object_type_value_tracks 
 FOR EACH ROW
 WHEN ( old.track_id IS DISTINCT FROM new.track_id OR old.owner_id IS DISTINCT FROM new.owner_id ) 
 EXECUTE PROCEDURE dashboard_private. object_type_value_tracks_denorm_track_id (  );

ALTER TABLE dashboard_public.object_type_value_tracks ADD CONSTRAINT object_type_value_tracks_track_id_object_type_value_id_key UNIQUE ( track_id, object_type_value_id );

COMMENT ON CONSTRAINT object_type_value_tracks_track_id_object_type_value_id_key ON dashboard_public.object_type_value_tracks IS E'@omit';

ALTER TABLE dashboard_public.object_type_value_tracks ENABLE ROW LEVEL SECURITY;

GRANT INSERT ON TABLE dashboard_public.object_type_value_tracks TO authenticated;

GRANT SELECT ON TABLE dashboard_public.object_type_value_tracks TO authenticated;

GRANT UPDATE ON TABLE dashboard_public.object_type_value_tracks TO authenticated;

GRANT DELETE ON TABLE dashboard_public.object_type_value_tracks TO authenticated;

CREATE POLICY auth_ins ON dashboard_public.object_type_value_tracks FOR INSERT TO authenticated WITH CHECK ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE POLICY auth_upd ON dashboard_public.object_type_value_tracks FOR UPDATE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE POLICY auth_del ON dashboard_public.object_type_value_tracks FOR DELETE TO authenticated USING ( owner_id IN (SELECT acl.entity_id FROM dashboard_memberships_private.memberships_acl AS acl WHERE acl.actor_id = jwt_public.current_user_id() AND (acl.permissions & '00000000000000001000000000000000') = '00000000000000001000000000000000') );

CREATE POLICY auth_sel ON dashboard_public.object_type_value_tracks FOR SELECT TO authenticated USING ( TRUE );

ALTER TABLE dashboard_public.form_questions ADD COLUMN  page_title text;

ALTER TABLE dashboard_public.form_questions ADD COLUMN  page_num int;

ALTER TABLE dashboard_public.form_questions ALTER COLUMN page_num SET DEFAULT 0;